---
title: ARM的程序计数器PC(R15)以及异常返回地址
tags:
  - ARM
categories:
  - - ARM
  - - 所有
index_img: 'https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/arm.png'
date: 2022-03-18 11:29:08
math: true
---

### 程序计数器PC(R15)

**ARM**状态下，位**[1:0]**为0，位**[31:2]**用于保存**PC**；

**Thumb**状态下，位**[0]**为0，位**[31:1]**用于保存**PC**；

由于**ARM**体系结构采用了多级流水线技术，对于**ARM**指令集而言，**PC**总是指向当前指令的**下两条指令**的地址，即**PC**的值为当前指令（正在执行的指令）的地址值加**8**个字节（一个ARM指令32位，4个字节）。

#### 理解

这里需要回顾一下CPU执行指令的步骤和多级流水线技术

CPU在执行1条指令的时候，主要有3个步骤：

- 取指（将指令从内存或指令cache中取入指令寄存器）；

- 译码（指令译码器对指令寄存器中的指令进行译码操作，从而辨识出该指令是要执行add，或是sub，或是其它操作，从而产生各种时序控制信号）；

- 执行（指令执行单元根据译码的结果进行运算并保存结果） 

**取指**阶段占用的CPU硬件是**指令通路**和**指令寄存器**；**译码**阶段占用的CPU硬件是**指令译码器**；**执行**阶段占用的CPU硬件是指令**执行单元**和**数据通路**。三者占用的CPU硬件完全不同，这样就使得如下的操作得以进行：在对第1条指令进行译码的时候，可以同时对第2条指令进行取指操作；在对第1条指令进行执行的时候，可以同时对第2条指令进行译码操作，对第3条指令进行取指操作。显然，这样就可以将该程序的运行总时间从30秒缩减为12秒，提速近3倍。上面所述并行运行指令的方式就被称为流水线操作。可见：流水线操作的本质是利用指令运行的不同阶段使用的CPU硬件互不相同，并发的运行多条指令，从而提高时间效率。

这里以三级流水线为例：

![三级流水线](https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220318170255436.png)

`寄存器PC的值是即将被取指的指令的地址`

**正常情况下**，在该条指令被取入CPU后执行期间，PC的值保持不变，在该条指令执行完成的时间点上，硬件会自动将PC的值增加一个单位的大小，这样PC就指向了下一条将被取指和执行的指令。

**而在引入流水线后**，PC值的情况发生了变化，假定第1条指令的内存地址为X，则在时刻T（第一条指令即将被取指），PC的值变为X，并在时刻T至时刻T+1期间维持不变；在时刻T+1，PC的值变为X+1个单位，并在时刻T+1至时刻T+2期间维持不变；在时刻T+2，PC的值变为X+2个单位，并在时刻T+2至时刻T+3期间维持不变；在时刻T+3，PC的值将变为X+3个单位。**（为要保证流水线正常工作就得不停取指，每次取值PC值就会增加）**由此可见，在第1条指令的执行阶段，PC的值不再是该指令在内存中的位置，而是该指令在内存中的位置+2个单元。对于ARM指令集而言，每条指令的长度为32bit，占4byte，所以1条指令在内存中需要4byte存储。

**注意**：虽然存在多种级别的流水线，但ARM出于统一和前后兼容的考虑，`PC 的值 = 当前正在执行指令在内存中的地址 + 8 `这个结论在所有的流水线级别上都是相同的。

![读R15的限制](https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220318171259152.png)

### ARM处理器异常返回地址

下面以三种异常为例，说明**ARM处理器异常返回地址**：

1. **FIQ**（**Fast Interrupt Request**）
2. **IRQ**（**Interrupt Request**）
3. **ABORT**（中止）

在ARM处理器中一条指令的执行分为取指、译码、执行三个阶段，由于指令流水线的存在造成当前执行的指令的地址是PC-8(ARM指令集)，那么当前执行指令的下一条指令的地址应该是PC-4，所以在异常产生时处理器会将PC-4的值保存到对应模式的LR寄存器中，但是该返回地址是否能够被使用还要看具体产生的异常的种类而定。

**FIQ与RIQ异常：**

FIQ与RIQ异常返回处理是一样的，当处理器**执行完当前指令后**才去查询中断且查看是否允许中断，如果处理器产生了中断，这时PC的值已经更新，即PC指向了当前指令后**第三条指令的位置**(被中断指令地址加12)，产生FIQ与RIQ异常后处理器将PC-4的值保存到了对应模式下的LR，而它指向的是当前被中断指令的后面的第二条指令，因此在返回时我们需要人为的将LR中保存的值自减4以得到正确的返回地址。

说明：PC是发生中断的指令后面的第三条指令地址，PC-12是发生中断的指令地址，LR（R14）= PC - 4，LR - 4就是发生中断的指令地址后面的第一条指令(也就是PC - 8)。

![以FIQ为例](https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220318172408962.png)

**数据中止异常：**

产生该异常的时候程序要返回到有问题的指令处重新访问该数据，因此应该返回到产生异常的指令处而不是产生异常指令的下一条指令处。当异常产生时PC的值已经更新，所以PC指向的是异常产生指令的后面的第三条指令，而LR中保存的是PC-4的值即异常产生指令的后面的第二条指令的地址。所以在返回时我们需人为的对LR中的值进行自减8的处理。以保证异常正确的返回。

![数据中止异常](https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220318172659486.png)



**文章参考**：[ARM处理器异常返回地址_华清远见教育集团 (hqyj.com)](http://emb.hqyj.com/Column/7517.html)