<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Papers About Industrial Anomaly Detection</title>
    <link href="/%E6%89%80%E6%9C%89/Papers%20About%20Industrial%20Anomaly%20Detection/"/>
    <url>/%E6%89%80%E6%9C%89/Papers%20About%20Industrial%20Anomaly%20Detection/</url>
    
    <content type="html"><![CDATA[<h1 id="papers-about-industrial-anomaly-detection">Papers AboutIndustrial Anomaly Detection</h1><h2id="sota-2dtowards-total-recall-in-industrial-anomaly-detection">【SOTA-2D】TowardsTotal Recall in Industrial Anomaly Detection</h2><blockquote><p>cold-start problem：fit a model using nominal example images only</p><p>也可以认为是One-ClassClassification（OCC）分类，即仅采用隶属于一个类别的样本来训练分类器，其通常被用于某种极端场景，即训练样本仅包含正常样本，而异常样本不可得。</p></blockquote><p>提出了<strong>PatchCore</strong>，在detection和localization上达到sota，评价指标是AUROC，达到99.6%，数据集是MVTecAD</p><p><strong>AUROC</strong>：Area Under the Receiver OperatingCharacteristic，关注的是模型的分类能力，是针对不同阈值设置下的分类问题的性能测量，AUC（曲线下区域）ROC（接收器操作特征）曲线。</p><p>TP：True Positive，预测为正，且预测正确</p><p>TN：True Negative，预测为负，且预测正确</p><p>FP：False Positive，预测为正，但预测错误</p><p>FN：False Negative，预测为负，但预测错误</p><p>Recall：<span class="math inline">\(\frac{TP}{TP +FN}\)</span>，从所有实际中为正的类，有多少预测正确，Recall应该尽可能高</p><p>Precision：<span class="math inline">\(\frac{TP}{TP +FP}\)</span>，从我们预测为正的类，有多少是正确的，也应该尽可能高</p><p>ROC曲线以TPR（真正率）与FPR（假正率）绘制，其中TPR位于y轴上，FPR在x轴上</p><p>TPR = Recall = Sensitivity = <span class="math inline">\(\frac{TP}{TP+ FN}\)</span>（分母是真实正样本的个数）</p><p>Specificity = <span class="math inline">\(\frac{TN}{TN +FP}\)</span></p><p>FPR = 1 - Specificity = <span class="math inline">\(\frac{FP}{TN +FP}\)</span></p><p>ROC曲线的绘制（同一模型下，根据计算的score遍历选取不同的threshold）</p><p>AUROC面积的判断（比较不同模型之间的优劣）</p><p>threshold根据预测值列表排序得到</p><blockquote><p>人类只看到少量实例之后，便可以区分数据中的预期方差和异常值</p><p>在实际工业生产中，很容易得到正常示例的图像，但是要得到特定的缺陷异常产品是很昂贵和复杂的。</p></blockquote><h3id="patchcore-introduction"><strong>PatchCore</strong>-Introduction</h3><blockquote><p>只要一个patch是异常的，图像就可以被分类为异常</p><p>PatchCore在MVTecAD上几乎完美（99.6%），并且具有很高的样本效率，仅仅使用一小部分正常样例数据训练，就能在性能上与现有的异常检测方法相匹配。</p></blockquote><h3 id="related-work">Related Work</h3><p>现有大多数异常检测模型依赖于学习nominal数据固有的表示的能力，使用在大型外部自然图像数据集ImageNet上预训练的模型。</p><p>借鉴了SPADE和PaDiM的思路，预训练+特征袋(bag of feature).</p><p>SPADE从预训练的骨干网络中提出的nominal特征的记忆库memorybank，进行图像级和像素级异常检测。PatchCore使用了memorybank，具有领域感知的patch特征。memorybank被coreset下采样，降低推理成本。</p><h3 id="method">Method⭐</h3><ul><li><h4 id="locally-aware-patch-features"><strong>Locally aware patchfeatures</strong></h4></li></ul><p>使用了在ImageNet上预训练的网络<spanclass="math inline">\(\phi\)</span>（ResNet），利用层级特征（低层次-&gt;高层次）特征图。为何使用到中间特征，而不是仅仅使用网络最后一层的输出呢？</p><ol type="1"><li>丢失了更多的局部nominal信息</li><li>ImageNet预训练的网络中非常深入和抽象的特征偏向于自然图像分类任务，与coldstart工业异常检测任务差距大。</li></ol><p>如何保存这些中间层次的特征图？使用memorybank，存储patch级别的特征。[1，2，3，4] -&gt; [2, 3]。</p><p>在c*通道的三维张量上进行切片，中心位置（h,w），切片（patch）感受野（边长）p大于1，patch大小（领域大下）不均匀。</p><p>在（h, w）位置上，聚合感受野的像素特征。使用了adaptive averagepooling，得到locally aware patch-feature。</p><p>根据以前工作，多个特征层次的聚合可以提供一些好处。但为了保留所使用的通用性和空间分辨率，PatchCore只使用了两个中间特征层次j和j+1。计算两个层次上的特征再聚集，使用双线性重新缩放。</p><ul><li><h4id="coreset-reduced-path-feature-memory-bank"><strong>Coreset-reducedpath-feature memory bank</strong></h4></li></ul><p>随着训练图片数量增大，memorybank变得非常大。为了缩小M，又不丢失nominal信息，采用了贪心coreset采样方法。减少推理时间同时保持性能。minimax问题。</p><ul><li><h4 id="anomaly-detection-with-patchcore"><strong>Anomaly Detectionwith PatchCore</strong></h4></li></ul><p>通过计算测试图片的图像级别的异常分数</p><h2 id="datasetreal-3d-ad3d点云瑕疵检测nips-2023">【Dataset】Real3D-AD(3D点云瑕疵检测)[NIPS 2023]</h2><blockquote><p>迄今（2023）为止，高精度3D工业异常检测的最大数据集，此前的数据集都是通过单视图扫描得到的RGBD图像（2.5D）</p></blockquote><p>还提出了Reg3D-AD，基于配准的3D异常检测方法作为，提出了ADBENCH-3D</p><p>对比优势：</p><ol type="1"><li>MVTec 3D-AD：分辨率不够高，有盲点</li><li>Eyescandies：生成模拟数据集，与真实场景有差距，有盲点</li></ol><p>总结：目前异常检测大量数据集都是2D的，3D异常检测数据集2021年首次提出，到目前为止仅有2个数据集，MVTec3D-AD是之前唯一点云的</p><p>点云异常分两类</p><ol type="1"><li>残缺</li><li>冗余</li></ol><p>AD模型的任务：</p><blockquote><p>检测三维点云是否异常，如果有异常则定位异常区域 。</p></blockquote><h3 id="reg3d-admethod">Reg3D-AD【Method】</h3><p>本质上还是提取特征，并和特征库里的特征进行匹配。</p><p>采用双特征表示方法来保留训练原型的局部和全局特征，就是特征中点云坐标【局部】+抽象特征PointMAE【全局】</p><p>实现了Coreset采样技术来保持内存库的大小。</p><p>在计算anomaly分数之前，需要通过<strong>RANSAC</strong>算法进行配准</p><p><strong>RANSAC</strong>：随机抽样一致算法，从一组包含离群的被观测数据中估算出<strong>数学模型的参数</strong>，相比最小二乘法，它融合了不合格数据的思想，因此对于有部分错误数据的数据样本，能够更快更准的给出辨识结果。</p><p>配准之后，通过point-level特征和全局特征的平均分数计算point-level异常分割。具体来说，有两个memorybank，一个是局部特征库，一个是全局特征库，测试对象的对象级异常分数由这两个库计算出的异常分数求平均值。</p><p><strong>局部特征异常分数</strong>：测试对象的点级特征与其各自最接近的邻居的最大分数(max-min)</p><p>对分数进行重加权方法来调整异常分数</p><p>few-shot setting</p><h3 id="改进方向">【改进方向】</h3><ol type="1"><li><p>训练数据太少，每个类别的原型不超过4个，可以使用增强或生成相关技术优化原型数据的利用，保证所获取的点云数据不受空间相对位置的影响。</p></li><li><p>测试点云边缘被截断，容易被误检测。</p></li><li><p>使用2D / 视频方面异常检测的方法，应用到3D点云异常检测。</p></li><li><p>概率密度估计，模拟分布，Denoising Score Matching。</p></li><li><p>data-efficiency: the ability to learn from few datapoints, likehumans</p><p>generalization : robustness</p></li></ol><h2id="dpointcore-efficient-unsupervised-point-cloud-anomaly-detector-using-local-global-features">【3D】PointCore:Efficient Unsupervised Point Cloud Anomaly Detector Using Local-GlobalFeatures</h2><blockquote><p>采用多个特征存储库来保存局部和全局特征，计算复杂度高，特征之间不匹配。</p><p>提出了PointCore，只需要一个memorybank来存储局部（坐标）和全局（PointMAE）表示，为这些局部-全局特征分配不同的优先级，减少计算成本和推理中的不匹配干扰。为实现鲁棒性，引入了归一化排序方法，将不同尺度的值调整，将密集分布的数据转换为均匀分布。</p><p>在Real3D-AD数据集上是SOTA。</p></blockquote><h3 id="introduction-related-works">Introduction &amp; RelatedWorks</h3><p>基于三维点云的异常检测任务，在目前的文献中还相对未被探索。</p><p>Reg3D-AD此前已经将PatchCore的方法从二维图像引入到点云异常检测中，采用双特征表示方法，保留训练原型的局部和全局特征，检测精度高，但是推理速度慢。</p><p>目前的点云异常检测方法可以分为两类：</p><ul><li>基于重建reconstruction的方法，通过自编码器对输入点云进行重构，通过比较原始数据和重建数据之间的偏差来识别异常。但这些方法对点云的分辨率很敏感，导致推理速度很慢，精度也很差。</li><li>基于内存库memorybank的方法，其中内存库用于存储代表特征，以隐式构建正态分布并查找ood（out-of-distributed）缺陷。直接使用预训练的特征提取器encoder构建记忆库具有较快的训练速度，而不受点云分辨率的影响。但多个特征记忆库来保留局部和全局表示，是以计算复杂度和特征之间的不匹配为代价的。</li></ul><p>提出了一种基于局部-全局联合特征的无监督异常检测框架PointCore，贡献为：</p><ul><li>仅一个memorybank存储局部-全局表示，并为特征分配不同的优先级以减少计算成本和推理的不匹配干扰。</li><li>提出一种基于排序的归一化方法，消除各种anomalyscore之间的分布差异，并应用点到平面迭代最近点ICP算法对点云配准结果进行局部优化。</li><li>具有竞争力的推理时间和最佳性能。</li></ul><h2id="cvpr2024towards-scalable-3d-anomaly-detection-and-localization-a-benchmark-via-3d-anomaly-synthesis-and-a-self-supervised-learning-network">【CVPR2024】TowardsScalable 3D Anomaly Detection and Localization: A Benchmark via 3DAnomaly Synthesis and A Self-Supervised Learning Network</h2><blockquote><p>细粒度几何判别问题。</p><p>基于ShapeNet生成了Anomaly-ShapeNet，由40个类别下的1600个点云样本组成。为了实现三维异常定位的可扩展表征学习，我们提出了一种自监督方法：迭代掩码重建网络<strong>IMRNet</strong>。</p><p>在训练过程中，我们提出了一个几何感知的采样模块，以在点云下采样期间保留潜在的可能异常的局部区域。</p></blockquote><p>已经创建的3D异常检测数据集</p><ul><li>MVTecAD-3D【single-pose】</li><li>Real3D-AD【complete point clouds】</li><li>MAD【multi-pose】</li></ul><p>点云异常检测领域，主要需要解决两个问题：</p><ol type="1"><li>缺乏多样化的分布数据集</li><li>需要更有效的基于深度学习的方法。</li></ol><p>Real3D-AD在正常和异常样本的多样性以及点大小变化过大方面存在局限性。</p><blockquote><p>Anomaly-ShapeNet包含六种典型的异常类型：凸起、凹陷、孔洞、断裂、弯曲和裂缝。每个样本的点数从8000到30000不等。异常部分占整个点云的1%到10%。</p></blockquote><p>提出了一种基于迭代掩码重建的自监督方法IMRNet，IMRNet包括三个主要组成部分：</p><ol type="1"><li>【几何感知点云采样模块GPS】Geometry-aware Point-Cloud Samplingmodule</li><li>【Point-Patch掩码重建网络PMR】Point-Patch Reconstructionnetwork</li><li>【密集特征链接和比较模块DFC】Dense Feature Concatenate</li></ol><p>GPS首先采取关键点，然后以关键点为patch中心使用KNN操作生成patch，再送入PMR。PMR网络对这些point-patch进行掩码重建。重构的normal样本和输入点云一起送入DFC模块。DFC模块将重构的normal样本和输入点云的特征点进行比较（特征空间和点坐标空间），得到异常分数。</p><h4 id="dataset-statistics">Dataset statistics</h4><p>训练集每个类别4个正常样本，测试集每个类别28到40个样本（正常+异常），样本的点云数从8000到30000个点。与Real3DAD（唯一的3D扫描点云异常检测数据集）相比，提供更广泛的类别多样性。</p><h4 id="思路">思路</h4><ul><li>基于重建的方法，对每一个输入的点云，结合流模型，残缺点（补全），冗余点（去噪），重建得到重建点云和原始输入点云进行对比，计算出异常分数，分割出异常区域</li><li>基于特征库比对的方法，从训练数据（正常样本）中筛选出相互正交的代表特征，在推理的时候，与输入点云特征进行对比。</li><li>或者找出与输入点云最相近的代表特征，然后两个相结合增强重建出增强点云，和输入点云相对比，结合两种方法。</li></ul><h3 id="geometry-aware-point-cloud-sampling">Geometry-aware Point CloudSampling</h3><p>通常使用的均匀采样或者FPS采样，在涉及到点云异常检测时，可能导致异常结构的模糊表示。GPS通过首先计算点的几何特征来自适应采样点云来解决这个问题。</p><h2id="eccv2024r3d-ad-reconstruction-via-diffusion-for-3d-anomaly-detection">【ECCV2024】R3D-AD:Reconstruction via Diffusion for 3D Anomaly Detection</h2><blockquote><p>基于嵌入和基于重构的方法是最流行和最成功的方法。目前的方法在实际应用中存在两个主要挑战：</p><ol type="1"><li>嵌入式模型由于memory bank结构而遭受令人望而却步的计算和存储。</li><li>基于MAE机制的重构模型无法检测到未屏蔽区域的异常。</li></ol><p>本文提出了利用扩散模型重建异常点云，用于精确的3D异常检测。</p></blockquote><ul><li>基于嵌入的方法：将预训练编码器提取的特征映射到正态分布上学习，不在区间内的分布被归类为异常。在训练阶段存储一些代表性特征，以隐式构件特征分布。在测试阶段，计算测试对象与存储在内存中的所有模板点云之间的欧式距离来确定异常的存在。</li><li>基于重建的方法：训练一个能够准确重建正常点云的网络，<strong>异常点云由于不包括在训练过程中而无法有效重建的假设</strong>。通过对比输入点云与重建点云的差异，生成异常图。IMRNet为代表，利用PointMAE对输入进行多次迭代重建。</li></ul><h4 id="d基于流模型的异常检测">【2D】基于流模型的异常检测</h4><blockquote><p>基于流模型的方法使用学习分布和flow的双射特性来发现缺陷。</p></blockquote><ul><li>Cflow-ad: Real-time unsupervised anomaly detection with localizationvia conditional normalizing flows. In: WACV (2022)</li><li>Same same but differnet: Semi-supervised defect detection withnormalizing flows. In: WACV (2021)</li><li>U-flow: A u-shaped normalizing flow for anomaly detection withunsupervised threshold. arXiv preprint (2022)</li><li>Fastflow: Unsupervised anomaly detection and localization via 2dnormalizing flows.</li></ul><h2id="d-flowsame-same-but-differnet-semi-supervised-defect-detection-with-normalizing-flows.">【2D-Flow】Samesame but differnet: Semi-supervised defect detection with normalizingflows.</h2><blockquote><p>为每张图片分配似然，正常样本-高似然，异常样本-低似然。为实现鲁棒性和灵活性，对一张图片进行变换，分别计算对应的似然。根据似然得到score函数，计算score函数的梯度，可以对异常区域进行定位。</p><p>基于自编码器的方法失败，因为它们泛化太强，即异常可以像正常样本一样很好地重建。</p><p>通过流模型，将图像提取的特征y映射到latent spacez，通过最大化py似然。</p><p>image-level anomaly detection</p></blockquote><h2id="d-flowcflow-ad-real-time-unsupervised-anomaly-detection-with-localization-via-conditional-normalizing-flows">【2D-Flow】CFLOW-AD:Real-Time Unsupervised Anomaly Detection with Localization viaConditional Normalizing Flows</h2><blockquote><p>卖点：实时，速度快。</p></blockquote><h3id="d-flowcvpr2023pyramidflow-high-resolution-defect-contrastive-localization-using-pyramid-normalizing-flow">【2D-Flow】【CVPR2023】PyramidFlow:High-Resolution Defect Contrastive Localization using PyramidNormalizing Flow</h3><blockquote><p>语义分割需要有监督学习。</p><p>目前的工作可以分为两种类型：</p><ol type="1"><li>reconstruction-based：依赖生成模型VAE、GAN将缺陷图像进行编码然后重建出正常图像，通过对比两张图像定位缺陷。这种方法能够在单一纹理图像上表现良好，但是无法推广到非纹理图像。</li><li>anomaly-based的方法：利用神经网络区分正常和异常，提取预训练的特征，使用马氏距离活kNN估计它们的概率密度，较低的概率表示图像补丁的异常位置。但是这种方法定位的缺陷分辨率较低，极大地限制了实际工业应用。</li></ol><p>马氏距离：是欧氏距离在多变量分布（MultivariateDistributions）下的加强版，用于测量点与分布之间的距离。</p><p>基于预训练的方法依赖于与任务无关的外部先验，这限制了在不可预见场景中的泛化。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>Computer Vision</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Anomaly Detection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Real3DAD-Reg3DAD代码及训练推理过程</title>
    <link href="/%E6%89%80%E6%9C%89/Real3DAD-Reg3DAD%E4%BB%A3%E7%A0%81%E5%8F%8A%E8%AE%AD%E7%BB%83%E6%8E%A8%E7%90%86%E8%BF%87%E7%A8%8B/"/>
    <url>/%E6%89%80%E6%9C%89/Real3DAD-Reg3DAD%E4%BB%A3%E7%A0%81%E5%8F%8A%E8%AE%AD%E7%BB%83%E6%8E%A8%E7%90%86%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3id="real3dad-reg3dad代码及训练推理过程">Real3DAD-Reg3DAD代码及训练推理过程</h3><p><code>train</code></p><p>对train_loader（4个点云，例[1, 383913,3]）进行for循环，添加点云到<strong>basic_template</strong>，但使用了break只选择了第一个点云作为模板（纯点云坐标，[383913,3]）</p><p><code>test</code></p><p>对test_loader（100个点云，例[1, 182495,3]）使用predict_pmae，然后进行for循环，例[1, 16384,3]，再调用_predict_pmae</p><p>首先_embed_pointmae，将测试的点云和basic_template里的点云配准，得到reg_data，然后将reg_data维度互换，再通过deep_feature_extractor使用point-mae进行编码，得到<strong>pmae_features</strong>,<strong>center</strong>, <strong>ori_idx</strong>,<strong>center_idx</strong>，其中维度：</p><ul><li>pmae_features：[1, 1152, 16384]</li><li>center：[1, 16384, 3]</li><li>ori_idx：[1, 16384, 128]</li><li>center_idx：[1, 16384, 3]</li></ul><p>其中，num_group是16384，xyz映射后维度总和384*3=1152，group_size =128</p><p>一个group128个点，一共16384个group</p><p>patch_scores由 anomaly_scorer.predict得到，维度是[16384]向量</p><p>xyz_sampled 维度是[16384, 3]</p><p>以最近邻算法，对sample的点周围的点的label做fill操作</p><p>最后得到的full_scores维度是[182495]向量</p><p>过程中，sample的点的下标需要记录，sample_idx</p><p>patch_score得到的分数和sample_idx以及xyz_sampled是一一对应的</p><p>以airplane类举例，训练推理一个测试集（100个样例），需要3*2=6个小时</p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>Computer Vision</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Anomaly Detection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从多视角图片中重建带有任意拓扑的三维隐式曲面</title>
    <link href="/%E6%89%80%E6%9C%89/%E4%BB%8E%E5%A4%9A%E8%A7%86%E8%A7%92%E5%9B%BE%E7%89%87%E4%B8%AD%E9%87%8D%E5%BB%BA%E5%B8%A6%E6%9C%89%E4%BB%BB%E6%84%8F%E6%8B%93%E6%89%91%E7%9A%84%E4%B8%89%E7%BB%B4%E9%9A%90%E5%BC%8F%E6%9B%B2%E9%9D%A2/"/>
    <url>/%E6%89%80%E6%9C%89/%E4%BB%8E%E5%A4%9A%E8%A7%86%E8%A7%92%E5%9B%BE%E7%89%87%E4%B8%AD%E9%87%8D%E5%BB%BA%E5%B8%A6%E6%9C%89%E4%BB%BB%E6%84%8F%E6%8B%93%E6%89%91%E7%9A%84%E4%B8%89%E7%BB%B4%E9%9A%90%E5%BC%8F%E6%9B%B2%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h3id="从多视角图片中重建带有任意拓扑的三维隐式曲面">从多视角图片中重建带有任意拓扑的三维隐式曲面</h3><p>任意拓扑：开放曲面和闭合曲面</p><p>三维重建在计算机视觉和图形学中是一个非常经典的问题，对于具有非常复杂的拓扑结构的闭合曲面，现在的工作已经可以达到非常好的重建效果，然而现在通过可微分渲染来进行重建的方法，大多数都是针对有符号距离场的SDF，SDF是把空间表示成内部和外部，因此它只能重建闭合曲面，没办法重建开放曲面，比如植物的叶子，花朵，衣服等。</p><p>最近几年也出现了可以表征开放曲面的隐式表征，但是没有任何一种可以直接用来与可微分渲染进行结合。因此NeAT就是用来填补了这个缺口。</p><p>其基础思想就是为SDF场来补充一个validityfunction来表示当前这个位置曲面存在的概率，按照图中二维的举例，我们可以把SDF的零值面进行导出，得到一个闭合的曲面，而如果对SDF做了validity的补充，我们知道最下面的这条线，它的空间有效性是0，那我们在进行曲面导出之前，我们就可以把这里的SDF的值设成NaN。这样我们就可以通过marchingcubes的方法，导出一个开放曲面的模型出来。</p><p>下面是基于体渲染的微分渲染架构，用于从多目图片重建三维开放曲面。最左边是最开始的一幅图像，从上面采样一个像素，然后将这个像素投射到三维，生成了一束光线，得到三维空间中的采样点，最后用包含了三个子网络的NeAT-Net，来为每个采样点预测它的SDF值，validity值，以及颜色值，在训练阶段，将这些值传入渲染器，用体渲染的方法来计算出当前像素的颜色值以及mask值，然后与groundtruth对比得到loss，通过梯度回传来更新参数，在模型的导出阶段，把空间有效性概率小于50%的点都设成NAN，再用marchingcubes的方法就可以进行三维模型的导出。</p><p>下面讲核心的渲染器是如何实现的，首先从渲染闭合曲面和渲染任意曲面的区别讲起，传统的基于SDF的方法，它是不会渲染backface的，backface就是光线方向和法向夹角小于90°的面，对于开放曲面来说，有时候所有法向都是朝着差不多一个方向的，如果在模型后面摆一个相机，那么它所有的面都是backface，第二个区别是对表面内和表面外的定义，开放曲面是没有内外之说的，所以在定义内外时，只在表面的附近定义了法向的内和外，因此在定义对应的概率密度函数时，我们需要对传统的闭合曲面的概率密度函数进行改动，在光线方向和法线方向相同的时候，我们需要进行反号的操作。</p><p>之后我们就可以从概率密度函数公式1来推导不透明度函数公式2，再对公式2做离散化就可以得到离散版的sdf不透明度公式3，再乘以当前空间它有效的概率也就是空间有效性的validity最终得到物体表面的不透明度公式4，然后我们可以用β计算真实颜色。</p><p>接下来是实验部分，做了3个实验来验证，第一个实验是从多视角重建闭合曲面，第二个实验是从多视角重建开放曲面，在MGD和Deepfashion3D两个数据集的不同种类的衣服上都验证了方法，</p><p>后续研究方向，第一个是研究一些新的采样和加权机制，来重建这些高度负责的结构，第二个就是探索在没有相机参数的时候进行重建，这样可以提高处理野外图像的能力。</p>]]></content>
    
    
    <categories>
      
      <category>课程</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于标准化流的3D点云异常检测方法构想</title>
    <link href="/%E6%89%80%E6%9C%89/%E5%9F%BA%E4%BA%8E%E6%A0%87%E5%87%86%E5%8C%96%E6%B5%81%E7%9A%843D%E7%82%B9%E4%BA%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E6%9E%84%E6%83%B3/"/>
    <url>/%E6%89%80%E6%9C%89/%E5%9F%BA%E4%BA%8E%E6%A0%87%E5%87%86%E5%8C%96%E6%B5%81%E7%9A%843D%E7%82%B9%E4%BA%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E6%9E%84%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h1id="基于标准化流的3d点云异常检测方法构想">基于标准化流的3D点云异常检测方法构想</h1><blockquote><p>问题:question:：</p><ol type="1"><li>现有的数据集貌似针对单个物体只有一处异常（瑕疵），虽然异常种类有很多。</li></ol></blockquote><h4 id="现在的主流方法pushpin">现在的主流方法:pushpin:</h4><ol type="1"><li><strong>基于特征学习对比的方法</strong>：从包含大量正样本的训练集中提取特征，构建存储代表特征的memorybank，在推理的时候，将待检测的输入特征编码后和memory bank（bag offeature）中的代表特征逐一对比。</li><li><strong>基于重建自监督的方法</strong>：数据集中只包含正常样本，对正常的样本进行随机处理，得到异常的样本，训练一个重建的网络，将异常样本恢复得到正常样本。在推理的时候，将待检测的输入点云送入训练好的重建网络得到重建输出点云，然后将输入点云和重建输出点云进行对比，异常检测分割。</li></ol><h4 id="问题假设">问题假设</h4><blockquote><p>假设待检测的输入点云是完整干净的三维点云和异常信号噪声的一个联合分布（缺陷也可以视为一种噪声，在原本应该由正常点云占用的空间，将其遮盖吞噬）。</p></blockquote><h3 id="方法">方法</h3><p>点云去噪的思路是使用概率分布的方法对三维点云和噪声的联合特征作过滤，将点云去噪问题转化为从噪声点云的高维特征中分离或过滤出无噪声的点特征。从信号处理的角度解释，即无噪声的点云和噪声可以类比为信号的低频和高频信号，要恢复出光滑的信号，需要过滤掉高频信息，并使用低频信息恢复信号，因为低频信号往往编码了原始信号的主要特征。（杜师兄论文）</p><p>而点云异常检测可以视作点云去噪的对立操作，即从噪声点云的高维特征中分离或过滤出噪声，噪声对物体带来异常信号，对其进行检测分割操作便可检测得到异常。</p><blockquote><p>问题:question:：</p><p>如果输入的检测点云是正样本（不包含异常），怎么办？</p></blockquote><ol type="1"><li>学习关于噪声点云的分布，并把该点云转化（编码）为隐式表示</li><li>从噪声的隐式表示中过滤得到噪声因子</li><li>将上一步得到的噪声隐式表示恢复解码成三维点云。</li></ol><p>使用标准化流来拟合点云在欧拉空间和隐空间之间的映射。</p><ol type="1"><li>通过标准化流的正向传播把它转换为隐变量</li><li>过滤得到异常信号的噪声因子，进行标注</li><li>通过标准化流的逆向传播将隐变量从隐空间转换回欧拉空间，得到异常分割后的点云</li></ol><h4 id="特点">特点</h4><ul><li>隐空间可分离，通道之间互相独立，正向f能把噪声因子和干净点云的本质结构编码到分离的通道（噪声是由部分的通道控制的），维度增强模块给点云增加额外的通道数</li><li>标准化流可逆&amp;无损，一一对应，标注-&gt;分割，无需训练decoder网络</li><li>编码和解码使用一个统一架构来实现，网络共享正向和逆向传播的参数，使得网络参数量更小</li></ul><blockquote><p>问题:question:：如何将正常信号和异常信号进行分离?</p></blockquote><h4 id="流程">流程</h4><ol type="1"><li>类似于ShapeNet-Anomaly，在训练中，将ShapeNet中的完整点云，添加异常信号噪声，并采用数据增强技术，生成训练数据对。</li><li>对输入的数据分patch，各个patch之间批量处理，GPU并行处理，增加训练速度</li></ol><blockquote><p>问题:question:：点云去噪网络中，最终推理的时候，分patch去噪完成后，多个patch合并后还会经过下采样，下采样对异常检测的标准有影响。</p></blockquote><blockquote><p>问题:question:：在去噪中，噪声可以看作是围绕干净点云的高斯分布，但是在点云异常检测中，异常部分的点云可以看成是高斯分布吗？[点云语义分割的方法？]</p></blockquote><blockquote><p>问题：怎么计算异常分数，对于没有异常的点云？</p></blockquote><h3id="现有基于流模型的图像上的异常检测工作">现有基于流模型的图像上的异常检测工作</h3><blockquote><p>基于流模型的方法使用学习分布和flow的双射特性来发现缺陷。</p></blockquote><ul><li><strong>DifferNet</strong>【WACV2021】: Same Same But DifferNet:Semi-Supervised Defect Detection with Normalizing Flows</li><li><strong>Cflow-ad</strong>【WACV2022】: Real-time unsupervisedanomaly detection with localization via conditional normalizingflows.</li><li><strong>U-flow</strong>[arXiv preprint (2022) ]: A u-shapednormalizing flow for anomaly detection with unsupervised threshold.</li><li><strong>Fastflow</strong>: Unsupervised anomaly detection andlocalization via 2d normalizing flows.</li></ul>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>Computer Vision</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Anomaly Detection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Point Cloud with Normalizing Flow</title>
    <link href="/Point-Cloud/Point%20Cloud%20with%20Normalizing%20Flow/"/>
    <url>/Point-Cloud/Point%20Cloud%20with%20Normalizing%20Flow/</url>
    
    <content type="html"><![CDATA[<h1 id="point-cloud-with-normalizing-flow">Point Cloud with NormalizingFlow</h1><h4id="标准化流方法在点云处理中的应用">标准化流方法在点云处理中的应用</h4><ul><li>PointFlow首先被提出用来学习点云的分布，基于CNF的结构，作为首个将标准化流引入点云处理领域的工作，启发了更多基于标准化流的点云学习的案例。</li><li>C-Flow利用NFs来实现多模态（如图像和点云）学习的可行性。</li><li>DPF，一种离散的NFs网络来拟合点云，缓解PointFlow的收敛速度慢和训练困难的问题。</li><li>Go with theFlows，提出了NF的混合模型，并展现了该混合模型具有比单个NF模型更强的生成能力。</li></ul><p>以上工作都是在合成数据集上进行测试，把NFs应用到现实应用场景的研究较少。</p><h3 id="点云处理的学习网络框架">点云处理的学习网络框架</h3><blockquote><p>PointNet中的共享连续函数，用于提升点的通道数量，通常使用SharedMLPs来实现，这里的“共享”意味着所有的点处理所用的参数是相同的且各个点提取特征的过程是相互独立的。</p></blockquote><h4 id="标准化流理论">标准化流理论</h4><p>标准化流（Normalizingflows，NFs）方法，也被称作流模型是一种数据生成模型。标准化流由一系列可逆的分布变化组成，通常用于拟合一个复杂，难以解析的分布转换到较简单的先验分布的变换过程。标准化流对数据似然概率精确估计和可追踪的隐变量推理过程。</p><p>正向和逆向传播都是无损的数据变换过程，这意味着P在欧拉空间下和z在隐空间下表示的数据点是一一对应的（即双射），即在任意空间下对数据点的修改都会反映到其他空间上。</p><h4 id="维度增强">维度增强</h4><blockquote><p>标准化流模型限制了输入和输出数据的维度必须是一致的，限制点云的维度在分布变换过程中将被限制在3。这会导致维度瓶颈问题，限制隐变量的特征表达能力。</p></blockquote><p><strong>解决办法</strong></p><ul><li>加深流模块层数【×】：增加网络深度会引入大量的参数，牺牲网络的训练速度和训练的稳定性</li><li>使用多尺度架构【×】：将空间上的维度置换为通道上的维度，仅针对二维图像设计，并不适合具有无序性的三维点云数据。</li><li>提升输入点云的通道数：借助knn，邻结点，有条件的标准化流CNF</li></ul><h2 id="点云去噪">点云去噪</h2><blockquote><p>将噪声因子和潜在代码中的固有干净点投射到单独的通道上来精确区分它们。</p><p>将噪声和干净点分离到不同的维度，然后将与噪声相关的维度mask，从而生成干净的潜在代码。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>所有</category>
      
      <category>Point Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Point Cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Point Cloud Anomaly Detection Methods</title>
    <link href="/Point-Cloud/Point%20Cloud%20Anomaly%20Detection%20Methods/"/>
    <url>/Point-Cloud/Point%20Cloud%20Anomaly%20Detection%20Methods/</url>
    
    <content type="html"><![CDATA[<h1 id="point-cloud-anomaly-detection-methods">Point Cloud AnomalyDetection Methods</h1><h4 id="现有工作">现有工作</h4><table><thead><tr><th>方法</th><th>数据集</th><th>论文</th></tr></thead><tbody><tr><td>IMRNet</td><td>Anomaly-ShapeNet（提出）、Real3D-AD</td><td>CVPR2024</td></tr><tr><td>R3D-AD</td><td>Anomaly-ShapeNet、Real3D-AD</td><td>ECCV2024</td></tr><tr><td>Reg3D-AD</td><td>Real3D-AD（提出）</td><td>NIPS2023</td></tr><tr><td>PointCore</td><td>Real3D-AD</td><td>arxiv2024</td></tr></tbody></table><h2 id="imrnet">IMRNet</h2><blockquote><p>Iterative Mask Reconstruciton Network。</p><p>:tomato:在训练过程中，提出几何感知的采样模块，以在点云下采样阶段保留潜在的异常局部区域。然后，随机mask出点云patch，将visiblepatch送入transformer进行基于重建的自监督。在测试过程中，点云反复经过maskreconstructionnetwork，每次迭代的输出成为下一个输入。通过将最终重建的点云和初始输入的点云进行融合和对比，定位异常。</p></blockquote><h3 id="geometry-aware-sampling">Geometry-aware sampling</h3><p>给定一个点，利用周围的邻居点，计算出该点的法向量和曲率的变化量，构建一个rateof change memory bank，选取topk（按比例）个点进行采样，使得采样出的点属于异常区域的概率大。</p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>所有</category>
      
      <category>Point Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Point Cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3D Generation Survey</title>
    <link href="/%E6%89%80%E6%9C%89/3D%20Generation%20Survey/"/>
    <url>/%E6%89%80%E6%9C%89/3D%20Generation%20Survey/</url>
    
    <content type="html"><![CDATA[<h1 id="d-generation-survey">3D Generation Survey</h1><blockquote><p>综述：Advances in 3D Generation: A Survey</p></blockquote><h2 id="d表征neural-representation">3D表征：Neural Representation</h2><blockquote><p>生成过程通常涉及用于创建3D模型和渲染2D图像的<strong>场景表示</strong>和可微分<strong>渲染算法</strong>。</p><p>【1】直接监督场景表示的3D模型</p><p>【2】将场景表示渲染成图像并监督生成的2D效果图</p></blockquote><ul><li><h3 id="explicit-scene-representation显示表征">Explicit scenerepresentation（显示表征）</h3><ul><li><h4 id="point-clouds点云"><strong>PointClouds</strong>（点云）：</h4><blockquote><p>Surfels在计算机图形学中用于渲染点云（Splitting），可微分。</p></blockquote><ul><li>Neural point-based graphics.</li><li>Neural point cloud rendering via multi-plane projection.</li><li>Synsin: End-to-end view synthesis from a single image.</li><li>......（这些方法通常将特征嵌入点云中，并将其变换到目标视图以解码颜色值，从而允许更准确和详细的场景重建）</li><li>Ewa-splatting</li><li>Learning efficient point cloud generation for dense 3d objectreconstruction.</li></ul></li><li><h4 id="meshes">Meshes：</h4></li><li><h4 id="multi-layer-representations">Multi-layerRepresentations：</h4></li></ul></li><li><h3 id="implicit-representations">Implicit Representations</h3><ul><li><h4 id="nerfs广义">NeRFs（广义）</h4><ul><li><strong>NeRF</strong>：Representing scenes as neural radiance fieldsfor view synthesis</li><li><strong>Mip-nerf</strong>：A multiscale representation foranti-aliasing neural radiance fields</li><li><strong>Instant-ngp</strong>：Instant neural graphics primitiveswith a multiresolution hash encoding</li><li><strong>3dgs</strong>：3d gaussian splatting for real-time radiancefield rendering</li></ul></li><li><h4 id="neural-implicit-surfaces">Neural Implicit Surfaces</h4><ul><li><strong>NeuS</strong>：Learning neural implicit surfaces by volumerendering for multi-view reconstruction</li><li><strong>VolSDF</strong>：Volume rendering of neural implicitsurfaces</li></ul></li></ul></li><li><h3 id="hybrid-representations">Hybrid Representations</h3><ul><li><h4 id="voxel-grids">Voxel Grids</h4><ul><li><strong>Instant-NGP</strong>： Instant neural graphics primitiveswith a multiresolution hash encoding</li></ul></li><li><h4 id="tri-plane">Tri-plane</h4><ul><li><strong>TensoRF</strong>：Tensorial radiance fields</li></ul></li><li><h4 id="hybrid-surface-representation">Hybrid SurfaceRepresentation</h4><ul><li><strong>DMTet</strong>：Deep marching tetrahedra: a hybridrepresentation for high-resolution 3d shape synthesis</li></ul></li></ul></li></ul><h2 id="d生成模型diffusion-models">2D生成模型：Diffusion Models</h2><ul><li><h3id="diffusion-models-generative-artificial-intelligence">DiffusionModels / Generative Artificial Intelligence</h3><ul><li>DDPM：Denoising diffusion probabilistic models.</li><li>LDMS（Latent Diffusion）：High-resolution image synthesis withlatent diffusion models</li><li>IDDPM：Improved denoising diffusion probabilistic models</li><li><strong>Stable Diffusion</strong>：High-resolution image synthesiswith latent diffusion models.</li><li><strong>Imagen</strong>：Photorealistic text-toimage diffusionmodels with deep language understanding</li><li>Midjourney：Midjourney</li><li>DALL-E 3 ：OpenAI</li></ul></li><li><h3 id="gans">GANs</h3><ul><li>GAN：Generative adversarial nets</li><li>Image2StyleGAN：How to embed images into the stylegan latentspace</li></ul></li><li><h3 id="vaes">VAEs</h3></li><li><h3 id="autoregressive">Autoregressive</h3></li></ul><h2 id="background">Background</h2><ul><li>3D数据稀缺</li><li>评估指标（考虑多视图一致性）</li></ul><h2 id="d-generation-achievement">3D Generation Achievement</h2><ul><li>3D-GAN：Learning a probabilistic latent space of object shapes via3d generativeadversarial modeling.</li><li>DeepSDF：Learning continuous signed distance functions for shaperepresentation.</li><li>DMTet：Deep marching tetrahedra: a hybrid representation forhigh-resolution 3d shape synthesis.</li><li><strong>EG3D</strong>：Efficient geometry-aware 3d generativeadversarial networks</li><li><strong>DreamFusion</strong>：Text-to-3d using 2d diffusion.</li><li>PointE：Point-e: A system for generating 3d point clouds fromcomplex prompts.</li><li>Zero-1-to-3：Zero-1-to-3: Zero-shot one image to 3d object</li><li><strong>Instant3D</strong>：Instant3d: Fast textto-3d withsparse-view generation and large reconstruction model.</li><li>AutoSDF：Transformer + voxel grid</li><li>EG3D：GAN + tri-plane</li><li>SSDNeRF：diffusion + tri-plane</li></ul><h2 id="d-generation-methods">3D Generation Methods</h2><ul><li><h3 id="feedforward-generation">Feedforward Generation</h3><ul><li><h4 id="gan">GAN</h4><ul><li>point clouds：l-GAN/r-GAN，tree-GAN</li><li>voxel grids：3D-GAN，Z-GAN</li><li>meshes：MeshGAN</li><li>SDF：SurfGen，SDFStyleGAN</li></ul></li></ul></li><li><h3 id="optimization-based-generation">Optimization-BasedGeneration</h3></li><li><h3 id="procedural-generation">Procedural Generation</h3></li><li><h3 id="generative-novel-view-synthesis">Generative Novel ViewSynthesis</h3></li></ul><h2 id="related-datasets">Related Datasets</h2><h3 id="optimization-based-generation-1">Optimization-BasedGeneration</h3><ul><li><h4 id="dream-field">Dream Field：</h4><ul><li><h5 id="dreamfusion">DreamFusion：</h5><ul><li><h5 id="make-it-3d-image-to-3d">Make-it-3D (Image-to-3D)</h5></li><li><h5 id="magic3d-imagetext-to-3d">Magic3D(Image/text-to-3D)</h5></li><li><h5 id="prolificdreamer-text-to-3d">ProlificDreamer(text-to-3D)</h5></li></ul></li></ul></li></ul><h3 id="feedforward-generation-1">Feedforward Generation</h3><h4 id="gans-1">GANS：</h4><ul><li><h5 id="d-gans">3D GANS</h5><ul><li><h5 id="tree-gan-point-cloud">tree-GAN (point cloud)</h5></li></ul></li></ul><h4 id="vaes-1">VAEs</h4><ul><li><h5 id="nerf-vae">NeRF-VAE</h5></li></ul><h4 id="autoregressive-models">Autoregressive Models</h4><ul><li><h5 id="polygen">PolyGen</h5></li></ul><h4 id="normalizing-flows">Normalizing Flows</h4><ul><li><h5 id="pointflow">PointFlow</h5></li></ul><h4 id="diffusion-models">Diffusion Models</h4><ul><li><h5 id="meshdiffusion-mesh">Meshdiffusion (mesh)</h5></li><li><h5 id="lion-point-cloud">Lion (point cloud)</h5></li><li><h5 id="point-e-point-cloud">Point-E (point cloud)</h5></li><li><h5 id="diffusion-sdf-sdf">Diffusion-SDF (SDF)</h5></li><li><h5 id="shape-radiance-field">ShapE (Radiance Field)</h5></li></ul><h3 id="procedural-generation-1">Procedural Generation</h3><ul><li><h4 id="create-3d-models-and-textures-from-sets-of-rules">create 3Dmodels and textures from sets of rules</h4></li></ul><h3 id="generative-novel-view-synthesis-1">Generative Novel ViewSynthesis</h3><ul><li><h4 id="gan-based">GAN-based：</h4><ul><li>PixelSynth</li></ul></li><li><h4 id="diffusion-based">Diffusion-based：</h4><ul><li>Zero-1-2-3</li><li>Zero-1-2-3++</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>Computer Vision</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>3D Generation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Text-to-3D Generation</title>
    <link href="/%E6%89%80%E6%9C%89/Text-to-3D%20Generation/"/>
    <url>/%E6%89%80%E6%9C%89/Text-to-3D%20Generation/</url>
    
    <content type="html"><![CDATA[<h1 id="text-to-3d-generation">Text-to-3D Generation</h1><p>思路：</p><blockquote><p>diffusion基于文本生成二维图像成功的原因：可以从网络上收集到大量的图片文本对。</p><p>三维生成大模型的难点：三维数据稀缺，目前只能利用二维的生成能力提升迁移到三维</p></blockquote><ol type="1"><li>端到端，直接生成三维数据<ul><li>生成mesh：图卷积网络</li><li>生成点云：point-E</li></ul></li><li>利用diffusion，从二维升三维<ul><li>text-image，然后利用多视角图像进行三维重建，要求diffusion对多视角一致性</li><li>利用多视角diffusion的prior，然后使用分数蒸馏采样SDS损失</li></ul></li></ol><ul><li><h3id="magic3dhigh-resolution-text-to-3d-content-creation">Magic3d：High-resolutiontext-to-3d content creation</h3></li><li><h3id="dreambooth3d-subject-driven-text-to-3d-generation">Dreambooth3d:Subject-driven text-to-3d generation</h3></li><li><h3id="fantasia3d-disentangling-geometry-and-appearance-for-high-quality-textto-3d-content-creation">Fantasia3d:Disentangling geometry and appearance for high-quality textto-3d contentcreation</h3></li><li><h3id="prolificdreamer-high-fidelity-and-diverse-textto-3d-generation-with-variational-score-distillation.">Prolificdreamer:High-fidelity and diverse textto-3d generation with variational scoredistillation.</h3></li><li><h3id="dreamgaussian-generative-gaussian-splatting-for-efficient-3d-content-creation">Dreamgaussian:Generative gaussian splatting for efficient 3d contentcreation</h3></li></ul><h2 id="layout">Layout</h2><ol type="1"><li>Compositional 3d scene generation using locally conditioneddiffusion</li><li>Componerf: Text-guided multi-object compositional nerf with editable3d scene layout.</li><li>Set-the-scene: Global-local training for generating controllablenerf scenes.</li><li>LOOSEControl</li><li>GALA3D</li></ol>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>Computer Vision</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>3D Generation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Point Cloud Completion with Diffusion Models</title>
    <link href="/Point-Cloud/Point%20Cloud%20Completion%20with%20Diffusion%20Models/"/>
    <url>/Point-Cloud/Point%20Cloud%20Completion%20with%20Diffusion%20Models/</url>
    
    <content type="html"><![CDATA[<h1 id="point-cloud-completion-with-diffusion-models">Point CloudCompletion with Diffusion Models</h1><h2 id="related-works">Related works</h2><h3 id="paper-point-cloud-pre-training-with-diffusion-models">paper:Point Cloud Pre-training with Diffusion Models</h3><blockquote><p>consider the point cloud pre-training task as a conditionalpoint-to-point generation problem, introducing a conditional pointgenerator</p></blockquote><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">backbone -&gt; features <span class="hljs-function"><span class="hljs-params">(condition)</span> -&gt;</span> point-<span class="hljs-keyword">to</span>-point recovery<br></code></pre></td></tr></table></figure><p>借助Diffusion类似点云重建的过程，去训练encoder，提取点云特征用于下游任务。</p><h3id="paper-diffusion-probabilistic-models-for-3d-point-cloud-generation">paper:Diffusion Probabilistic Models for 3D Point Cloud Generation</h3><h3id="paper-a-conditional-point-diffusion-refinement-paradigm-for-3d-point-cloud-completion">paper:A Conditional Point Diffusion-Refinement Paradigm for 3D Point CloudCompletion</h3><blockquote><p>CD loss cannot capture the overall point density distribution,leading to non-uniform</p></blockquote><p><strong>Point Diffusion-Refinement(PDR) paradigm</strong> =<code>Conditional Generation Network(CGNet)</code> +<code>ReFinement Network(RFNet)</code></p><p>一阶段：CGNet用残缺点云输入利用DDPM得到粗略点云，和GT计算损失。</p><p>二阶段：RFNet对粗略点云进行细化。</p><p>使用CD损失监督训练会使得补全的点更倾向在输入的残缺点云周围，导致得到的点云不均匀。</p><p>EMD对密度分布更敏感，但是计算成本太高。</p><p>DDPM的扩散过程是两个连续点云之间的一对一的逐点映射，使得它可以使用简单的均方误差损失函数进行训练。</p><p>点云补全任务可以看作是DDPM框架下的条件生成问题。但是直接生成的点云缺乏光滑的表面和清晰的细节。</p><p>DDPM加噪的每一步可以看做是逐点的映射，因此点云中点之间的顺序保持不变，但由于加噪到最终得到高斯分布，每个点之间独立同分布是等价的，所以顺序无影响。</p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>所有</category>
      
      <category>Point Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Point Cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ProlificDreamer</title>
    <link href="/%E6%89%80%E6%9C%89/ProlificDreamer/"/>
    <url>/%E6%89%80%E6%9C%89/ProlificDreamer/</url>
    
    <content type="html"><![CDATA[<h3 id="prolificdreamer">ProlificDreamer</h3><p>今天我要分享的这篇论文是结合NeRF神经辐射场和生成模型Diffusion的一个3d生成的工作，叫做ProlificDreamer，使用作者提出的VSD的方法实现文本到3d内容的高保真和多样性的生成，这个可以称为里程碑之作，一作是清华大学的两个博士生，虽然代码没有开源但是github上只有一个readme文件，但已经有1.1k个star了。</p><p>从2020年DDPM论文真正让diffusion模型火起来到现在，diffusion模型在2d的文字到图像的生成上已经达到了非常好的效果，可以实现很高的分辨率和图像精度，比如imagen和stablediffusion这些工作。然而在3d方面的相关工作却发展缓慢，去年提出的相关工作有dreamfusion，nvidia提出的magic3d，latent-nerf这些，但是他们的效果都不是特别的好，而这篇论文实现的效果是非常的惊人的，下面是一个生成的内容，描述的是一个蓝色的什么鸟站在一大篮子的彩虹马卡龙上，可以看到它的纹理细节是非常丰富的，prolificdreamer不仅可以生成一个物体，他还能生成一整个的场景，包括前景后景深度这些。下面这些是论文中贴出的效果，可以得到非常逼真的纹理mesh网格，很高的一个分辨率和高保真的结构和复杂的一些光影烟雾这些。同时，在同一个prompt的输入下，也可以生成多样的效果。</p><p>论文首先介绍了它的三个前期工作，第一个就是最开始的Diffusionmodel，主要就是一个前向加噪，然后用网络预测噪声进行去噪的过程。然后是将diffusion与nerf相结合用做3d生成的工作，首先对于一个3d的场景，采样nerf中的经典方法，选取一个相机的视角，渲染出一张2d的图片，然后将这个渲染的图像和一个文本prompt送到这个texttoimage的diffusion里去，然后让模型去模拟预测一个噪声，通过这个噪声由计算损失函数，然后再梯度回传到nerf这边，去优化3d的场景，来让nerf这边生成渲染的图片和Diffusion当中给定textprompt生成的图片的分布近似。具体的以dreamfusion来举例，就是左边是一个神经辐射场，dreamfusion里用的就是mipnerf360，也是比较新的一个工作。然后右边是用的imagen，具体的论文我还没有看，但它里面也是用unet实现的，然后再dreamfusion里，在计算优化3d场景用的损失函数时，它用的SDS，分数蒸馏采样。首先这里nerf的模型的参数时θ，然后SDS的优化目标就是，优化nerf的模型参数θ，然后让nerf渲染图像的扩散加噪过程的边缘分布靠向预训练的text-image的边缘分布，公式中也是让它们的KL散度尽可能的小。</p><p>而这篇工作他就发现基于SDS的工作效果都不是特别的好，而SDS就是其中最重要的限制它们的一个因素，会导致生成内容过度的光滑，饱和度太高，颜色非常显然，并且生成的内容没有很好的多样性，于是，作者提出的这个工作主要就是将这里的这个换成了VSD。导致SDS效果不好的原因主要是SDS它倾向在不断优化中生成最可能的case，导致diffusion原有的多样性消失。比如输入的文本是山，而最有可能出现的是左上角的这种。因为以前仅仅建模一个nerf场，而如果我们可以同时建模四个nerf场，左边是四个nerf场，渲染出四种不同风格的图片。目的就是让3d渲染图片分布和diffusion的图片分布相同，但是直接计算p0的分布过于困难，于是作者就提出了迭代式的优化过程。作者这里不是使用神经网络模型来建模μ，而是一种基于粒子的方法来建模分布，用n个参数，每个参数被称为一个粒子，然后迭代优化μ的粒子，知道收敛。也就是说选用了n个参数来表示μ的分布，每个参数就表达了nerf场的参数，各不相同的参数就可以表达μ的大致的估计</p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>Computer Vision</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>3D Generation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息检索与Web挖掘第一次思考题</title>
    <link href="/%E6%89%80%E6%9C%89/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E4%B8%8EWeb%E6%8C%96%E6%8E%98%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%80%9D%E8%80%83%E9%A2%98/"/>
    <url>/%E6%89%80%E6%9C%89/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E4%B8%8EWeb%E6%8C%96%E6%8E%98%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%80%9D%E8%80%83%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3id="信息检索与web挖掘第一次思考题">信息检索与Web挖掘第一次思考题</h3><h4id="请说明词term作为基向量的好处及可能带来的问题设想2个可能的改进方案">1.请说明词（term）作为基向量的好处及可能带来的问题。设想2个可能的改进方案。</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">词（term）作为基向量的好处是可以降低维度，词嵌入将词转化为固定维度的实数向量，由于自然语言中的词汇量极大，直接使用词来表示文本将导致维度灾难。词作为基向量通过将词映射到低维空间，可以有效降低数据的维度。同时，好的词嵌入能够保持词的语义信心，即语义相近的词在嵌入空间中距离相近，有助于后续的NLP任务，如文本分类，情感分析等。低维向量计算效率更高，便于大规模数据处理。<br>这种方式可能带来的问题有，一个词可能有多个意义，但词作为基向量通常只为一个词分配一个向量，这可能无法准确地表示多义词的所有含义，词嵌入通常为每个词分配一个固定的向量，不考虑上下文的影响，这可能无法准确地捕捉词在特定上下文中的意义。<br>可以通过动态词向量和复合词嵌入的方案进行改进，使用上下文相关的词表示，如Transformer模型中的BERT，通过考虑词的上下文来生成动态的词嵌入，可以更好地处理多义词和上下文依赖问题。复合词嵌入则是结合多种词表示方法，如结合字符级别的嵌入和词级别的嵌入，可以同时捕捉到词的内部结构和全局语义信息，有助于处理未知次梁和提高模型的理解能力。<br></code></pre></td></tr></table></figure><h4id="ir系统的索引是什么类型的索引如果要尽可能增强搜索引擎的检索功能并尽量简化在线计算以提高检索性能索引系统可以预先存储哪些信息请列举所有可能的存储信息并说明理由">2.IR系统的索引是什么类型的索引？如果要尽可能增强搜索引擎的检索功能并尽量简化在线计算以提高检索性能，索引系统可以预先存储哪些信息？请列举所有可能的存储信息，并说明理由。</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">IR</span>系统的索引通常使用的是<span class="hljs-variable">Inverted</span> <span class="hljs-variable">index</span>，这种索引方式能够快速地找到包含特定查询词的文档。<br>为了增强搜索引擎的检索功能并提高检索性能，索引系统可以预先存储一下信息，<br><span class="hljs-number">1.</span>词频（<span class="hljs-variable">Term</span> <span class="hljs-variable">Frequency</span>），记录每个词在文档中出现的次数，这有助于评估词在文档中的重要性。<br><span class="hljs-number">2.</span>逆文档频率（<span class="hljs-built_in">Inverse</span> <span class="hljs-variable">Document</span> <span class="hljs-variable">Frequency</span>），记录每个词在整个文档集合中的稀有程度，可以评估词的区分度。<br><span class="hljs-number">3.</span>文档长度（<span class="hljs-variable">Document</span> <span class="hljs-built_in">Length</span>），每个文档的长度，进行长度归一化，以改善检索效果。<br><span class="hljs-number">4.</span>词位置（<span class="hljs-variable">Term</span> <span class="hljs-built_in">Position</span>），记录每个词在文档中的位置<br><span class="hljs-number">5.</span>文档频率（<span class="hljs-variable">Document</span> <span class="hljs-variable">Frequency</span>），记录每个词出现在多少个文档中，计算<span class="hljs-variable">IDF</span>的基础<br><span class="hljs-number">6.</span><span class="hljs-variable">Stopword</span> <span class="hljs-built_in">List</span>，对检索贡献不大的词可以预先存储在停用词列表中，方便再检索和查询时忽略<br><span class="hljs-number">7.</span>元数据（<span class="hljs-variable">Metadata</span>），如作者、日期、标题等，这些信息可以用于更加复杂的查询和结果排序<br><span class="hljs-number">8.</span>短语索引（<span class="hljs-variable">Phrase</span> <span class="hljs-variable">Indexing</span>），预先识别并索引常见的短语，可以加快短语查询的速度<br><span class="hljs-number">9.</span>连接分析信息（<span class="hljs-variable">Link</span> <span class="hljs-variable">Analysis</span> <span class="hljs-built_in">Information</span>），如<span class="hljs-variable">PageRank</span>等，用于评估文档的权威性和重要性<br><span class="hljs-number">10.</span><span class="hljs-variable">Cached</span> <span class="hljs-variable">Popular</span> <span class="hljs-variable">Queries</span>， 对于频繁的查询，可以缓存器结果以加快相应速度<br></code></pre></td></tr></table></figure><h4id="请说明衡量搜索引擎问答系统推荐系统的性能的常用指标都有哪些尽可能全面并概要说明衡量指标的计算方法">3.请说明衡量搜索引擎、问答系统、推荐系统的性能的常用指标都有哪些？尽可能全面，并概要说明衡量指标的计算方法。</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">搜索引擎常用的衡量指标有准确率、召回率、<span class="hljs-built_in">F1</span>分数、平均精度均值、归一化折损累计增益nDCG。准确率是指检索到的相关文档数与检索到的文档总数之比，召回率是指检索到的相关文档数与所有相关文档总数之比。<span class="hljs-built_in">F1</span>分数是准确率和召回率的调和平均数，用于综合衡量搜索引擎的性能。<span class="hljs-meta">MAP</span>是每个查询的准确率-召回率曲线下的面积的平均值，用于评估搜索引擎在不同查询上的性能。nDCG是评估搜索引擎结果列表的排序质量的指标，考虑了结果的相关性和位置。<br>问答系统常用的衡量指标有准确率、精确匹配度、BLEU分数、ROUGE分数。准确率是指问答系统正确回答的问题数与所有回答的问题总数之比。精确匹配率是指系统给出的答案与标准答案完全相同的问题数与所有问题的比例。BLEU是一种评估机器翻译质量的指标，也常用于问答系统，它衡量系统生成的答案与参考答案之间的重叠度。ROUGE是另一种用于评估自动文摘和问答系统性能的指标，它基于召回率来衡量系统生成的答案与参考答案之间的重叠度。<br>推荐系统常用的衡量指标有准确率和召回率、平均倒数排名、归一化折损累计增益、覆盖率、新颖性。准确率和召回率与搜索引擎类似，衡量推荐的项目中相关项目的比例和找到的相关项目的比例。MRR衡量推荐列表中第一个相关项目的排名的倒数。nDCG衡量推荐列表的排序质量。覆盖率是指推荐系统能够推荐的长尾项目的比例，衡量推荐系统的多样性和创新能力。新颖性是指推荐的项目对用户来说是新的比例。<br></code></pre></td></tr></table></figure><h4id="请比较链接分析算法pagerankhitstrustrank的原理和计算方法的异同点并为这些算法各设想2个除检索排序外的应用场景">4.请比较链接分析算法PageRank、HITS、TrustRank的原理和计算方法的异同点，并为这些算法各设想2个除检索排序外的应用场景。</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs">PageRank基于这样一个假设，一个网页被越多的其他网页链接，说明这个网页越重要。此外，来自重要网页的链接比来自不重要网页的链接更有价值。计算方法如下：<br>初始化：所有网页的PageRank值被设定为相同的值<br>迭代过程：在每次迭代中，每个网页将其当前的PageRank值平均分配给所有它链接到的网页。<br>游走模型：用户在浏览网页时，既可能按照链接浏览，也可能随机跳转到任意网页。<br>遍历结束：当PageRank值的分布收敛时，迭代结束。<br>HITS算法分别计算每个网页的权威性和枢纽性，权威性高的网页被许多其他网页链接，而枢纽性高的网页则连接到许多权威性高的网页。计算方法：<br>初始化：所有网页的权威性和枢纽值被设定为相同的值。<br>迭代过程：在每次迭代中，权威性值根据指向它的网页的枢纽性值更新，枢纽性值根据它指向的权威性值更新。<br>归一化：为了避免值无限增长，每次迭代后需要对权威性和枢纽性值进行归一化处理。<br>收敛：当权威性和枢纽性值的分布稳定时，迭代结束。<br>TrustRank结合PageRank和人工判断，它首先由一组种子网页（被认为可靠和权威的网页）开始，然后通过链接关系传播信任值到其他网页。计算方法：<br>选择种子网页：专家或用户评定一组权威的种子网页。<br>信任传播：使用类似PageRank的方法，但仅限于种子网页及其链接的网页，传播信任值<br>收敛：当信任值分布稳定时，迭代结束<br>这些算法相同点在于都是基于图论，使用链接分析来确定网页的重要性，都采用了迭代算法来计算网页的排名或分数，都可能受到链接欺骗的影响。不同点在于PageRank和HITs是自底向上的方法，而TrustRank结合了人工判断和自顶向下的方法。HITS区分了权威性和枢纽性，TrustRank通过限制信任传播的范围来提高算法的准确性。<br>除了检索排序外，PageRank可以用于社交网络分析、学术文献引用分析。HITS可以用于网络社区发现、电子商务推荐，TrustRank可以用于垃圾邮件过滤、社交媒体平台。<br></code></pre></td></tr></table></figure><h4id="bm25模型语言模型对tfidf及文档长度的利用与经典vsm模型有何不同请做下对比分析">5.BM25模型、语言模型对TF、IDF及文档长度的利用与经典VSM模型有何不同？请做下对比分析。</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">在经典的向量空间模型VSM中，文档和查询通常被表示为TF-IDF向量。TF-IDF是一种统计方法，用于评估一个词对于一个文档集或一个语料库中的其中一个文档的重要程度。在VSM中，TF通常被用来表示词在文档中的重要性，频率越高，认为词越重要。IDF用于降低常见词的权重，增加罕见词的权重。文档长度的影响通常通过文档长度的归一化来处理，比如使用文档的欧氏长度或余弦长度来进行归一化，以减少长文档对词权重的不当影响。<br>BM25是一种常用于信息检索的排名函数，它对TF、IDF和文档长度的处理方式与VSM有所不同，BM25使用一种改进的TF计算方法，它考虑了词频和文档长度的关系，通过一个公式来平滑高频词的权重，使得词频对权重的增加变得不那么剧烈。BM25中的IDF也略有不同，它使用了对数函数来计算IDF，并且有一个可调节的参数k1，可以用来控制TF的饱和度。BM25通过一个参数<span class="hljs-selector-tag">b</span>来控制文档长度对权重的影响，这个参数允许文档长度的归一化更加灵活，更好地适应不同的文档集合。语言模型通常不直接使用TF和IDF的概念。它们通过训练来学习词的分布和上下文关系，因此它们考虑的是词的语义和上下文信息，而不是简单的统计信息。对于文档长度，语言模型通常能够处理不同长度的输入，因为它们设计用来处理变长的序列数据。模型内部机制（如注意力机制）可以帮助模型聚焦于重要的部分，而不仅仅是统计词频。<br></code></pre></td></tr></table></figure><h4 id="请说明主题模型的训练和推理过程并设想主题模型的2个应用场景">6.请说明主题模型的训练和推理过程，并设想主题模型的2个应用场景。</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs">主题模型的训练过程包括<br>预处理：将文档集合进行预处理，包括分词、去除停用词、词干提取（stemming）或词形还原（lemmatization）等。<br>构建词袋模型：将每个文档表示为一个向量，其中每个元素对应于词汇表中的一个词，而元素的值是该词在文档中的频率。<br>初始化参数：为每个文档和每个主题分配随机的词分布（θ）和词-主题分布（β）。<br>吉布斯采样或变分推断：<br>吉布斯采样：通过迭代采样过程来更新文档中的词分配给主题的概率。<br>变分推断：使用变分方法来近似后验分布，优化文档-主题分布和词-主题分布的参数。<br>收敛判断：重复上述步骤直到模型收敛，即文档和词的分布变化小于某个阈值。<br>输出模型：最终得到的模型包括每个文档的主题分布和每个主题的词分布。<br>推理过程<br>输入新文档：对新的文档进行相同的预处理步骤。<br>计算主题分布：使用训练好的模型来计算新文档的主题分布。这通常通过推断新文档中每个词最可能属于哪个主题来完成。<br>生成主题表示：根据主题分布，选择最可能的主题或主题组合来表示文档。<br>输出结果：根据应用需求，输出可能是一个主题标签、主题列表或主题分布。<br>主题模型可以应用于文本分类和聚类，推荐系统和个性化搜索。<br></code></pre></td></tr></table></figure><h4 id="为什么固定窗口长度的简单神经语言模型无法解决数据稀疏问题">7.为什么固定窗口长度的简单神经语言模型无法解决数据稀疏问题？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">固定窗口长度的模型只能考虑窗口内的词来预测当前词，这限制了模型捕捉长距离依赖和深层次上下文关系的能力。在长文本中，重要的上下文信息可能超出了固定窗口的范围，导致模型无法充分利用这些信息。固定窗口长度的模型通常使用词袋模型来表示文本，这意味着模型的输入和输出空间都与词汇表的大小成线性关系。对于大型语料库，词汇表可能非常大，导致模型参数数量激增，增加了过拟合的风险，同时使得模型难以学习到每个词的精确表示。在固定窗口模型中，大多数词对的共现次数为零，这导致模型在训练过程中产生大量的稀疏梯度。稀疏梯度使得模型训练效率低下，因为许多参数更新是无效的，无法有效学习词之间的关联。固定窗口模型在训练时往往只能看到有限的上下文，这限制了模型的泛化能力。在遇到训练数据中未出现的词对或上下文时，模型可能无法做出准确的预测。<br></code></pre></td></tr></table></figure><h4id="什么是自注意力self-attention机制请分析transformer结构的特点以及带来的好处">8.什么是自注意力（self-attention）机制？请分析Transformer结构的特点以及带来的好处。</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">自注意力（<span class="hljs-variable">Self</span><span class="hljs-operator">-</span><span class="hljs-variable">Attention</span>）机制是一种在序列处理任务中用于捕捉序列内部各个元素之间关系的机制。它允许模型在处理一个序列（如一个句子）中的每个元素时，同时考虑序列中的所有其他元素，而不仅仅是相邻的元素或一个固定大小的上下文窗口。自注意力机制在<span class="hljs-variable">Transformer</span>模型中得到了广泛应用，并且是<span class="hljs-variable">Transformer</span>的核心组成部分。<br>自注意力机制通过以下步骤计算一个序列中每个元素的表示：<br>查询（<span class="hljs-built_in">Query</span>）、键（<span class="hljs-built_in">Key</span>）和值（<span class="hljs-variable">Value</span>）的计算：对于序列中的每个元素，通过矩阵变换得到其对应的查询向量、键向量和值向量。相似度计算：计算序列中每个元素的查询向量与其他所有元素的键向量之间的相似度，这通常使用点积来实现。权重分配：将计算出的相似度通过<span class="hljs-variable">softmax</span>函数转换为概率形式，称为注意力权重。加权求和：用注意力权重对值向量进行加权求和，得到加权后的值表示。输出合成：最后，将加权求和的结果通过另一个线性变换，得到该位置的最终输出表示。<br><span class="hljs-variable">Transformer</span>结构的主要特点包括：<br>自注意力层：<span class="hljs-variable">Transformer</span>使用自注意力机制来捕捉序列内部的长距离依赖关系。<br>多头注意力：<span class="hljs-variable">Transformer</span>采用多头注意力机制，将输入分割成多个头，每个头关注不同的信息，然后将这些头的输出合并起来，以获得更丰富的表示。<br>位置编码：由于<span class="hljs-variable">Transformer</span>不包含循环或卷积结构，因此它无法直接捕捉序列中的位置信息。为了解决这个问题，<span class="hljs-variable">Transformer</span>在自注意力层之前加入了位置编码，将位置信息注入到输入序列中。<br>前馈神经网络：在自注意力层之后，<span class="hljs-variable">Transformer</span>使用前馈神经网络来对每个位置的表示进行进一步的非线性变换。<br>残差连接和层归一化：<span class="hljs-variable">Transformer</span>在自注意力层和前馈神经网络层之间使用残差连接，并应用层归一化技术，这有助于模型训练的稳定性和性能。<br></code></pre></td></tr></table></figure><h4id="请对比分析rnnlstmgru及transformer在文本表征能力计算效率处理数据稀疏性及长句子等方面各有什么优缺点">9.请对比分析RNN、LSTM、GRU及Transformer在文本表征能力、计算效率、处理数据稀疏性及长句子等方面各有什么优缺点。</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs">在文本表征能力方面<br>RNN优点：能够处理变长序列数据，具有一定的上下文学习能力。缺点：由于梯度消失和梯度爆炸问题，难以捕捉长距离依赖。LSTM优点：通过引入门控机制，能够更好地捕捉长距离依赖。<br>缺点：参数数量多，模型复杂，难以训练。GRU优点：结合了LSTM的优点，但参数更少，更容易训练。<br>缺点：在某些任务上可能不如LSTM表现好。Transformer优点：自注意力机制能够同时考虑序列中的所有元素，有效捕捉长距离依赖和复杂的上下文关系。<br>缺点：原始Transformer缺乏对序列顺序的内在理解，需要位置编码来补充。<br>在计算效率方面<br>RNN优点：模型简单，计算成本低。<br>缺点：无法并行计算，因为后续输出依赖于前一个输出。LSTM优点：与RNN相比，计算成本略高，但能有效捕捉长距离依赖。缺点：同样无法并行计算，因为存在序列依赖。GRU优点：计算成本低于LSTM，效率更高。缺点：同样无法并行计算。Transformer优点：可以并行计算，特别是在使用GPU和TPU时，计算效率极高。缺点：模型复杂，初始训练成本较高。<br>在处理数据稀疏性<br>RNN优点：可以通过共享参数来处理不同长度的序列。缺点：对于稀疏数据，可能无法有效学习到重要的信息。LSTM优点：门控机制有助于模型专注于重要的信息，减少稀疏性问题。缺点：对于极其稀疏的数据，模型效果可能依然不佳。GRU优点：门控机制有助于处理稀疏数据。缺点：对于极其稀疏的数据，效果可能有限。Transformer优点：多头注意力机制有助于聚焦于重要信息，减少稀疏性问题。缺点：对于极其稀疏的数据，可能需要大量的训练数据和计算资源。<br>在长句子处理方面上<br>RNN优点：理论上可以处理任意长度的句子。缺点：实际中，长句子会导致梯度消失和梯度爆炸问题，影响模型性能。LSTM优点：比RNN更擅长处理长句子，能够捕捉长期依赖。缺点：长句子会导致训练时间增加，且可能需要更多的内存资源。GRU优点：比RNN更有效地处理长句子，捕捉长期依赖。缺点：长句子可能导致训练难度增加。Transformer优点：能够有效处理长句子，不受梯度消失和梯度爆炸问题的影响。缺点：长句子可能需要更多的内存和计算资源。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>课程</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件体系结构复习</title>
    <link href="/%E6%89%80%E6%9C%89/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    <url>/%E6%89%80%E6%9C%89/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="软件体系结构复习">软件体系结构复习</h1><h2 id="第一章">第一章</h2><h3 id="为什么要研究软件体系结构">1、为什么要研究软件体系结构？</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">研究软件体系结构在软件开发和维护过程中具有及其重要的意义，有助于<br>1、提高软件质量，通过研究软件体系结构，可以确保系统在设计阶段就具备良好的可扩展性、可维护性、可重用性和可靠性等质量属性。<br>2、降低开发成本，合理的软件体系结构能够减少软件开发过程中的重复劳动，提高开发效率。通过复用已有的组件和服务，可以降低新系统的开发成本。同时，良好的体系结构能够减少系统维护和升级的难度和成本，因为系统各组件之间的耦合度低，修改一个组件通常不会影响到其他组件。<br>3、支持复杂系统开发，体系结构设计阶段可以明确系统的整体架构和关键组件，为后续的详细设计和实现提供清晰的指导。<br>4、促进团队协作，通过体系结构描述，团队成员可以清晰地了解系统的整体结构和各组件的职责，从而更加有效地协作。<br>5、支持演化和升级，通过研究软件体系结构，可以确保系统在设计时就具备足够的灵活性和可扩展性，以应对未来的变化。<br>6、提高决策质量，以更加全面地了解系统的需求和约束条件，从而做出更加科学合理的决策。<br></code></pre></td></tr></table></figure><h3id="根据软件体系结构的定义你认为软件体系结构的模型应该由哪些部分组成">2、根据软件体系结构的定义，你认为软件体系结构的模型应该由哪些部分组成？</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs maxima">软件体系结构是描述软件系统结构的高层抽象，它关注于系统的整体结构、组件之间的交互关系以及指导这些组件设计和演化的原则和方针。一个全面的软件体系结构模型应该包含以下几个关键部分：<br><span class="hljs-number">1</span>、组件（<span class="hljs-built_in">components</span>）<br>组件是软件体系结构的基本构建块，它们封装了功能性和数据，对外提供接口供其他组件调用。组件可以是类、模块、子系统或服务的集合<br><span class="hljs-number">2</span>、连接件（connectors）<br>连接件定义了组件之间的交互方式，包括数据流、控制流和可能的异常处理机制。它们可以是简单的函数调用、消息传递、管道、共享内存、远程过程调用等。<br><span class="hljs-number">3</span>、配置（configuration）<br>配置描述了系统中组件和连接件的组织和布局方式，即他们是如何被组织成一个整体的。这包括组件的层次结构、拓扑结构以及它们在物理上或逻辑上的部署。<br><span class="hljs-number">4</span>、约束（constraints）<br>约束是对体系结构设计和实现的限制条件，这些条件可能起源于业务需求、技术限制、性能要求、安全策略或法律法规等。约束有助于确保系统结构的一致性和可行性。<br><span class="hljs-number">5</span>、风格（styles）/模式（patterns）<br>风格或模式是对常见体系结构设计的抽象和概括，它们提供了一组经过验证的、用于指导特定类型软件系统设计的原则和实践。常见的风格包括分层体系结构、客户端-服务器体系结构、事件驱动体系结构、微服务架构等。<br><span class="hljs-number">6</span>、原则（principles）<br>原则是指导体系结构设计和演化的基本原则，它们定义了设计决策背后的指导思想。例如，模块化原则鼓励将系统划分为独立、可替换的组件。<br><span class="hljs-number">7</span>、视图（views）<br>由于软件体系结构是一个复杂的系统，通常需要从不同的角度来描述它。视图就是针对特定关注点的体系结构描述，如逻辑视图、开发视图、物理视图和进程视图。<br><br></code></pre></td></tr></table></figure><h3id="详细了解什么是面向服务体系结构">3、详细了解什么是面向服务体系结构</h3><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">面向服务体系结构（Service-Oriented Architecture，<span class="hljs-keyword">SOA</span>）是一种软件设计模式，它将应用程序的不同功能单元（即服务）进行抽象、封装和集成，以实现软件系统的模块化、松耦合和可重用。<span class="hljs-keyword">SOA</span>的核心思想是将软件功能以服务的形式进行组织，这些服务具有明确定义的接口，并通过这些接口与外部交互，以实现软件系统的灵活性和可扩展性。<br><span class="hljs-keyword">SOA</span>的主要特点：<br><span class="hljs-number">1</span>、松耦合，<span class="hljs-keyword">SOA</span>通过定义清晰的服务接口，实现了服务之间的解耦，使得服务之间的依赖关系变得更加灵活。这有助于降低系统间的耦合度，提高系统的可维护性和可扩展性。<br><span class="hljs-number">2</span>、模块化，<span class="hljs-keyword">SOA</span>将复杂的业务功能抽象为简单的服务单元，使得系统的设计和开发变得更加模块化。这有助于提高系统的可重用性和可维护性。<br><span class="hljs-number">3</span>、平台无关性，<span class="hljs-keyword">SOA</span>的服务接口独立于实现，使得服务可以在不同的硬件平台、操作系统和编程语言上实现，提高了系统的跨平台能力。<br><span class="hljs-number">4</span>、易于扩展和维护，由于服务之间的松耦合和模块化设计，<span class="hljs-keyword">SOA</span>使得系统的扩展和维护变得更加容易。当需要添加新功能或修改现有功能时，只需对相应的服务进行修改，而无需影响其他服务。<br><span class="hljs-keyword">SOA</span>已经在企业信息系统、物联网、云计算等多个领域得到了广泛的应用。<br></code></pre></td></tr></table></figure><h2 id="第二章">第二章</h2><h3id="选择一个规模合适的系统为其建立41模型">1、选择一个规模合适的系统，为其建立“4+1”模型。</h3><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">选择一个中等复杂度的企业信息系统作为示例。这个系统可能包含多个模块，如用户管理、订单处理、库存管理、财务管理等，并且需要与外部系统（支付网关、物流系统）进行交互。以下是基于“<span class="hljs-number">4</span>+<span class="hljs-number">1</span>”视图模型的详细建立过程：<br><span class="hljs-number">1</span>、逻辑视图（Logical <span class="hljs-keyword">view</span>）<br>描述系统软件功能拆解后的组件关系，组件约束和边界、反映系统整体组成与系统如何构建的过程。使用UML的组件图和类图来表示逻辑视图，展示组件的层次结构和类之间的关系（关联、泛化、组合、聚合等）<br><span class="hljs-number">2</span>、物理视图（Physical <span class="hljs-keyword">view</span>）<br>描述系统软件到物理硬件的映射关系，反应系统的组件时如何部署到一组可计算机器节点上，用于指导软件系统的部署实施过程。（负载均衡、容错备份等）<br><span class="hljs-number">3</span>、处理流程视图（<span class="hljs-keyword">Process</span> <span class="hljs-keyword">view</span>）<br>捕获设计的并发性和同步性方面，解决系统如何执行的问题。描述系统如何处理并发请求和同步操作，确保数据的一致性和系统的稳定性。流程控制定义系统内部各组件之间的交互流程和控制逻辑。使用流程图或活动图表示系统的处理流程和控制逻辑。<br><span class="hljs-number">4</span>、开发视图（Development <span class="hljs-keyword">view</span>）<br>描述软件在其开发环境中的静态结构（系统和应用），侧重于软件开发环境上的软件模块静态结构。.<br><span class="hljs-number">5</span>、场景视图（<span class="hljs-keyword">Use</span> <span class="hljs-keyword">case</span> <span class="hljs-keyword">view</span>）<br>描述系统的参与者与功能用例间的关系，反映系统的最终需求和交互设计。<br></code></pre></td></tr></table></figure><h3id="引入了软件体系结构以后传统软件过程发生了哪些变化这种变化有什么好处">2、引入了软件体系结构以后，传统软件过程发生了哪些变化？这种变化有什么好处？</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">传统软件过程的设计开发更加具体和形象，模型使得软件过程更加方便和多样化，促进了软件系统的系统级复用，提高了系统的可维护性和可扩展性。<br>这种变化提高了软件开发的效率、降低了软件开发的成本、提高了软件质量、促进了团队成员之间的沟通和协作、支持了更复杂的软件系统的开发。<br></code></pre></td></tr></table></figure><h3id="软件体系结构的生命周期模型与软件生命周期模型有什么关系">3、软件体系结构的生命周期模型与软件生命周期模型有什么关系？</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">软件体系结构是贯穿于软件研发的整个生命周期的系统开发、运行、维护所实施的全部工作和任务的结构框架。它给出了软件开发活动各阶段之间的关系，为软件生命周期模型提供了很好的结构与参考，并构建了很好的开发方式。软件生命周期模型是指人们为了开发更好的软件而归纳总结的软件生命周期的典型实践参考，它描述了软件从产生到报废的整个生命周期。<br>软件体系结构生命周期模型为软件生命周期模型提供了结构上的指导和参考，使得软件生命周期的各个阶段更加明确和有序。软件体系结构的生命周期模型更侧重于从体系结构的角度来划分阶段，而软件生命周期模型则更加全面地覆盖了软件的整个生命周期。<br></code></pre></td></tr></table></figure><h3 id="详细了解41视图">4、详细了解4+1视图。</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">4<span class="hljs-string">+1</span>视图通过五个不同的视角来全面描述软件系统的各个方面，包括逻辑视图，开发视图、过程视图、物理视图、场景视图。<br>逻辑视图：关注系统提供最终用户的功能，即系统提供给用户的服务。展示了系统的静态结构和动态行为，以及系统内部如何实现这些功能。<br>开发视图：主要关注软件模块的组织和管理，定义了在开发环境中软件的静态组织结构，包括源代码的组织和模块间的依赖关系。<br>过程视图：也称运行视图和进程视图，主要关注系统的运行特性，特别是并发性、分布性、系统继承性和容错能力。它描述了系统组件之间的通信时序和数据的输入输出<br>物理视图：定义了软件到硬件的映射<br>场景视图：场景视图也称为用例视图，是“4<span class="hljs-string">+1</span>”视图中的“1”。它作为其他四个视图的补充，通过用例（use cases）或场景（scenarios）将其他几个视图串联起来，对它们进行解释和说明。<br></code></pre></td></tr></table></figure><h2 id="第三章">第三章</h2><h3id="试分析和比较bs二层cs和三层cs指出各自的优点和缺点">1、试分析和比较B/S，二层C/S和三层C/S，指出各自的优点和缺点。</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">B</span><span class="hljs-operator">/</span><span class="hljs-variable">S</span>架构：<br>优点：<br><span class="hljs-number">1</span>、无需安装客户端，用户可以直接通过<span class="hljs-variable">Web</span>浏览器访问系统，无需在本地计算机上安装专门的客户端软件，从而简化了用户的操作，降低了使用门槛。<br><span class="hljs-number">2</span>、跨平台性好，可以支持多种操作系统和浏览器。<br><span class="hljs-number">3</span>、易于维护和升级，系统的维护和升级主要集中在服务端进行，用户无需进行任何操作，降低了维护成本。<br><span class="hljs-number">4</span>、开放性和扩展性强，<span class="hljs-variable">B</span><span class="hljs-operator">/</span><span class="hljs-variable">S</span>架构可以方便地与其他<span class="hljs-variable">Web</span>应用和服务进行集成，支持广泛的<span class="hljs-variable">Web</span>技术和标准。<br>缺点：<br><span class="hljs-number">1</span>、安全性和性能方面可能不如<span class="hljs-built_in">C</span><span class="hljs-operator">/</span><span class="hljs-variable">S</span>架构，尤其是在处理大量并发请求或敏感数据时。<br><span class="hljs-number">2</span>、依赖网络，完全依赖于网络，如果网络不稳定或中断，系统将无法正常工作。<br><span class="hljs-number">3</span>、交互性受限，由于是基于<span class="hljs-variable">Web</span>浏览器的请求<span class="hljs-operator">-</span>响应模式，<span class="hljs-variable">B</span><span class="hljs-operator">/</span><span class="hljs-variable">S</span>架构在交互性方面可能不如<span class="hljs-built_in">C</span><span class="hljs-operator">/</span><span class="hljs-variable">S</span>架构流畅。<br>二层<span class="hljs-built_in">C</span><span class="hljs-operator">/</span><span class="hljs-variable">S</span>架构<br>优点：<br><span class="hljs-number">1</span>、数据操作能力强，<span class="hljs-built_in">C</span><span class="hljs-operator">/</span><span class="hljs-variable">S</span>架构具有强大的数据操作和处理能力，适用于需要频繁进行数据库操作的应用场景<br><span class="hljs-number">2</span>、适应性和灵活性，<span class="hljs-built_in">C</span><span class="hljs-operator">/</span><span class="hljs-variable">S</span>架构对软硬件的变化具有较大的适应性和灵活性，<br><span class="hljs-number">3</span>、功能构建隔离，有助于降低复杂复杂度并提高系统的可维护性。<br>缺点：<br><span class="hljs-number">1</span>、开发成本高<br><span class="hljs-number">2</span>、客户端依赖性强<br><span class="hljs-number">3</span>、维护和升级困难<br>三层<span class="hljs-built_in">C</span><span class="hljs-operator">/</span><span class="hljs-variable">S</span>架构<br>优点<br><span class="hljs-number">1</span>、高可维护性和可扩展性，通过合理的划分三层架构（表示层，业务逻辑层，数据访问层）提高了系统和软件的可维护性和可扩展性。<br><span class="hljs-number">2</span>、良好的可升级性和开放性：三层<span class="hljs-built_in">C</span><span class="hljs-operator">/</span><span class="hljs-variable">S</span>架构支持并行开发，可以选择最合适的开发语言和技术栈，同时也便于进行系统的升级和扩展。<br><span class="hljs-number">3</span>、安全性好，由于将业务逻辑层和数据访问分开处理，可以在中间层进行严格的权限控制和数据加密，提高系统的安全性。<br>缺点<br><span class="hljs-number">1</span>、开发难度大，需要更多的技术储备和开发经验<br><span class="hljs-number">2</span>、访问效率低，由于增加了中间层的数据处理和转发过程，可能会导致系统的访问效率降低<br><span class="hljs-number">3</span>、成本较高，三层<span class="hljs-built_in">C</span><span class="hljs-operator">/</span><span class="hljs-variable">S</span>架构需要更多的服务器和网络资源来支持系统的运行和维护，因此成本相对较高。<br></code></pre></td></tr></table></figure><h3id="组织或参与一个采用三层体系结构的软件项目的开发总结开发经验">2、组织或参与一个采用三层体系结构的软件项目的开发，总结开发经验。</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">三层体系结构包括：用户界面表示层，业务逻辑层，数据访问层。<br>1、数据访问层，主要是对原始数据的操作层，而不是指原始数据，是对数据的操作，为业务逻辑层或表示层提供数据服务。<br>2、业务逻辑层，主要是针对具体的问题的操作，对数据层的操作，对数据业务逻辑处理<br>3、表示层，主要表示Web方法，也可以表示成Winform方式。<br>采用三层结构主要是使项目结构更清楚，分工更明确，有利于后期的维护和升级，它未必会提升性能，因为当子程序模块未执行结束时，主程序模块只能处于等待状态，这说明将应用程序划分层次，会带来执行速度上的一些损失，但是从团队开发效率上来说可以感到大不相同的效果。<br></code></pre></td></tr></table></figure><h3id="在软件开发中采用异构结构有什么好处其负面影响有哪些">3、在软件开发中，采用异构结构有什么好处，其负面影响有哪些？</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs">采用异构结构可以<br>1、适应性和灵活性<br>异构结构允许系统根据实际需求，灵活选择最适合的组件和技术来实现功能，有助于快速适应不断变化的市场需求和技术发展。<br>2、资源优化<br>异构结构能够更有效地利用系统中的各种资源，避免资源浪费，通过将任务分配给最合适的处理器，可以提高系统的整体性能和效率<br>3、兼容性和互操作性<br>尽管存在多种不同的技术和标准，但异构结构通过适当的接口和协议设计，可以实现不同组件之间的兼容性和互操作性，有助于系统的集成和扩展。<br>4、降低维护成本<br>在某些情况下，系统可能包含一些遗留代码或旧系统，这些代码与新系统可能存在一定的不协调。通过采用异构结构，可以在不重写旧代码的情况下，将新系统与之集成，从而降低维护成本。<br>负面影响：<br>1、复杂性增加<br>2、标准不统一<br>3、资源分配和管理难度<br>4、性能瓶颈，性能差异<br>5、安全风险<br></code></pre></td></tr></table></figure><h3 id="详细了解一种体系结构风格">4、详细了解一种体系结构风格</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs">管道/过滤器风格<br>定义：管道/过滤器风格是一种数据流风格的软件体系结构，它将系统划分为一系列独立的过滤器和管道，在这种结构中，构件被称为过滤器，负责对数据进行加工处理，每个过滤器都有一组输入端口和输出端口，从输入端口接受数据，经过内部加工处理后，传送到输出端口上，数据通过相邻过滤器之间的连接件进行传输，连接件可以看作输入数据流和输出数据流之间的通路，这就是管道。<br><br>过滤器：是管道/过滤器风格中的基本构件，负责接受输入数据流，对其进行处理，并产生输出数据流，过滤器之间是相互独立的，一个过滤器的输出称为另一个过滤器的输入。<br>管道：连接过滤器的连接件，用于传输数据流，它确保了数据从一个过滤器流向另一个过滤器，而不需要过滤器之间的直接交互。<br>优点：简单性、支持复用、系统可扩展性和可进化性、系统并发性、便于系统分析<br>缺点：是批处理方式，不适合需要实时响应的交互式应用，不适合设计交互式应用系统，数据传输标准不统一，难以进行错误处理。<br>应用实例：传统的编译器是管道/过滤器风格的一个典型实例，编译器由词法分析，语法分析，语义分析，中间代码生成，中间代码优化和目标代码生成等模块组成，这些模块可以看作一系列的过滤器，它们依次对源代码进行处理，最终生成目标代码，每个模块的输出都是下一个模块的输入，通过管道进行数据传输。<br></code></pre></td></tr></table></figure><h2 id="第四章">第四章</h2><h3id="体系结构描述有哪些方法有哪些标准和规范">1、体系结构描述有哪些方法？有哪些标准和规范？</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm">体系结构描述的方法主要包括<br><span class="hljs-number">1</span>、图形表达方式，采用矩形框和有向线段组合而成，其中矩形代表抽象矩阵，有向线段代表连接件，即辅助各构件进行通信、控制或关联的元素。<br><span class="hljs-number">2</span>、模块内连接语言（MIL），是一种将几种传统程序设计语言的模块连接起来的语言，基于程序设计语言的语义基础，能够支持相对较大的软件单元进行描述，但过于依赖程序设计语言，可能限制了其处理和描述更抽象的高层次软件体系结构元素的能力。<br><span class="hljs-number">3</span>、基于软构件的系统描述语言，将软件系统描述成由许多以特定形式相互作用的特殊实体构造组成的组织或系统，例如，PCL和Darwin都可以用来在较高的抽象层次上对系统的体系结构进行建模。<br><span class="hljs-number">4</span>、软件体系结构描述语言（ADL），是参照传统程序设计语言的设计和开发经验，针对软件体系结构特点重新设计、开发和使用的专门的软件体系结构描述语言，它能够使用较小的独立体系结构元素来建造大型软件系统，同时关注构件和连接件的抽象特性，常见的有Wright、<span class="hljs-built_in">C2</span>、Rapide、xADL、MetaH等<br>标准和规范有IEEE P1471、Rational建议标准。<br></code></pre></td></tr></table></figure><h3id="体系结构描述语言与程序设计语言有什么区别">2、体系结构描述语言与程序设计语言有什么区别？</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">ADL是一种能够建立软件系统概念化结构的语言，它能够刻画体系结构的具体语法和概念框架，ADL的目的是为了描述和表达软件系统的体系结构，便于开发人员之间的交流和系统的建模，设计与分析，主要用于软件系统的体系结构建模、描述、分析和交流，帮助开发人员理解和构建系统的整体结构。<br>程序设计语言是计算机程序设计的基础工具，是计算机能够理解和执行的语言，它包含了一套语法、词法规则，用于定义和实现程序中的数据结构和算法。<br>主要区别在它们的应用层次和目的，ADL用于建立软件系统的高层次概念化体系结构，程序设计语言用于编写具体的程序代码，实现特定的功能或算法，是实现具体功能的工具。ADL关注系统设计层面的抽象描述，而程序设计语言则关注代码层面的具体实现。<br></code></pre></td></tr></table></figure><h3 id="详细了解一种设计模式">3、详细了解一种设计模式</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">工厂方法模式：是一种创建型设计模式，它定义了一个创建对象的接口，但让子类决定要实例化的类是哪一个。工厂方法让类的实例化推迟到子类中进行。<br>特点：<br>封装性：客户端不需要指导具体产品的创建过程，只需指导对应工厂的接口<br>扩展性：当需要增加新的产品时，只需新增相应的具体产品和对应的具体工厂类，无需修改原有代码，符合开闭原则<br>解耦：将产品的创建与使用解耦，降低了系统的耦合度。<br>角色：<br>抽象产品、具体产品、抽象工厂、具体工厂<br></code></pre></td></tr></table></figure><h2 id="第五章">第五章</h2><h3id="什么是动态软件体系结构动态软件体系结构与静态软件体系结构有什么区别">1、什么是动态软件体系结构？动态软件体系结构与静态软件体系结构有什么区别？</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">动态软件体系结构是指允许在系统运行时发生更新的软件体系结构。能支持系统在运行时根据需求、技术、环境或分布等因素的变化进行动态调整，而无需停止系统运行。动态软件体系结构的研究主要是针对那些需要长期运行且具有特殊使命的系统，如航空航天、生命维持、金融、交通等领域，这些系统的稳定性和可靠性至关重要。<br>区别在于：<br>1、运行时更新能力，静态软件体系结构一旦系统部署运行，其体系结构在运行时无法发生变化，除非通过停止系统并进行更新来实现。<br>2、适应性和灵活性<br>3、复杂性和挑战<br>4、应用场景<br>5、技术实现，动态软件体系结构通常基于构件和连接件模型，通过定义适当的接口和协议来实现动态更新。静态软件体系结构则更多依赖于传统软件开发方法和工具链，如需求分析，设计、编码、测试等。<br></code></pre></td></tr></table></figure><h3id="基于构件的动态软件体系结构模型的层次结构是什么">2、基于构件的动态软件体系结构模型的层次结构是什么？</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">主要分为三层：应用层，中间层和体系结构层。<br>应用层：处于最底层，包括构件连接，构件接口和执行，这一层是软件系统的核心功能实现部分，可以添加新的构件、删除或更新已经存在的构件，以满足系统的动态更新需求。<br>中间层：位于应用层和体系结构层之间，包括连接件配置，构件配置，构件描述以及执行，这一层是连接应用层和体系结构层的桥梁，负责管理和协调构件和连接件的具体配置和执行。<br>体系结构层：位于最上层，控制和管理整个体系结构，包括体系结构配置、体系结构描述和执行。这一层是系统的全局管理层，负责系统的整体架构设计和配置管理。<br></code></pre></td></tr></table></figure><h3id="如何使用πadl进行动态体系结构建模能使用一种动态描述语言对一个简单系统的体系结构进行描述">3、如何使用πADL进行动态体系结构建模？能使用一种动态描述语言对一个简单系统的体系结构进行描述。</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1、定义基础元素（构件、连接件、类型）<br>2、构件系统架构<br>3、描述动态行为<br>4、形式化验证<br></code></pre></td></tr></table></figure><h2 id="第六章">第六章</h2><h3id="什么是web服务体系结构与传统的结构相比使用web服务有哪些好处">1、什么是Web服务体系结构？与传统的结构相比，使用Web服务有哪些好处？</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Web服务体系结构是一种用于描述、发布、定位和调用Web服务的框架。它定义了三个主要角色：服务提供者（Service Provider）、服务请求者（Service Requester）和服务代理（Service Broker），以及三个基本操作：发布（Publish）、查找（<span class="hljs-keyword">Find</span>）和绑定（Bind）。这种结构允许网络组件（如服务器、客户端等）以松散耦合的方式相互交互，从而构建出灵活、可扩展的分布式系统。<br>Web服务通常是独立、模块化的应用程序，它们可以通过网络（通常是万维网）进行访问。这些服务遵循一系列标准协议和规范，如SOAP（Simple Object Access Protocol，简单对象访问协议）、WSDL（Web Services <span class="hljs-keyword">Description</span> Language，Web服务描述语言）和UDDI（Universal <span class="hljs-keyword">Description</span>, Discovery and Integration，统一描述、发现和集成）等，以确保服务的互操作性和可发现性。<br>与传统结构相比，使用Web服务的好处：<br><span class="hljs-number">1</span>、高度的通用性和易用性<br><span class="hljs-number">2</span>、平台、语言独立性<br><span class="hljs-number">3</span>、高度的集成性<br><span class="hljs-number">4</span>、松散耦合<br><span class="hljs-number">5</span>、容易部署和发布<br><span class="hljs-number">6</span>、跨Internet通信能力<br><span class="hljs-number">7</span>、更好的伸缩性<br></code></pre></td></tr></table></figure><h3id="试分析服务提供者服务请求者和服务代理三者的作用以及它们之间的工作流程">2、试分析服务提供者、服务请求者和服务代理三者的作用，以及它们之间的工作流程。</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs">服务提供者：是Web服务的实际拥有者和发布者。它们负责实现具体的Web服务，包括定义服务接口、编写服务实现代码，并将服务部署到网络上，以便其他服务请求者能够调用。服务提供者还需要将其提供的服务描述信息发布到服务注册中心（通常由服务代理承担），以便服务请求者能够发现并使用这些服务。<br>服务请求者：是使用Web服务的实体，它们可能是另一个Web服务、一个应用程序或是一个终端用户。服务请求者通过服务代理（或直接）查找所需的服务，获取服务的绑定信息（如服务的网络地址、调用方法等），并据此构造调用请求发送给服务提供者。服务请求者接收服务提供者返回的结果，并据此进行后续处理。<br>服务代理：在Web服务体系结构中充当中介角色，主要负责服务的注册、查找和绑定操作。它接收来自服务提供者的服务描述信息，并将这些信息存储在服务注册中心中，以便服务请求者能够查询。当服务请求者发出服务查询请求时，服务代理根据请求中的条件在服务注册中心中查找匹配的服务，并将服务的绑定信息返回给服务请求者。此外，服务代理还可能提供其他增值服务，如服务的监控、管理和优化等。<br>工作流程：<br>1、服务提供者发布服务<br>2、服务请求者查找服务<br>3、服务代理返回服务绑定信息<br>4、服务请求者调用服务<br>5、服务提供者执行服务并返回结果<br>6、服务请求者处理结果<br></code></pre></td></tr></table></figure><h3id="在实际开发中如何实现web服务和soa结构">3、在实际开发中，如何实现Web服务和SOA结构？</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">Web服务的实现<br><span class="hljs-number">1</span>、定义服务接口，使用WSDL来描述Web服务的接口，包括服务能够做什么、如何调用以及需要哪些参数等信息。WSDL是一种基于XML的语言，用于描述网络服务的公共接口。<br><span class="hljs-number">2</span>、实现服务逻辑，根据服务的需求选择合适的编程语言和框架来实现服务逻辑。例如，可以使用Java结合Spring框架，或者<span class="hljs-selector-class">.NET</span>结合ASP<span class="hljs-selector-class">.NET</span>等技术栈。将实现好的服务部署到服务器上，并确保服务可以通过网络进行访问。<br><span class="hljs-number">3</span>、发布服务，将服务的WSDL文件或其他描述信息发布到服务注册中心（如UDDI注册中心），以便服务请求者能够发现和调用这些服务。然而，在现代Web服务实现中，注册中心的使用越来越少，更多时候服务描述信息可能直接通过HTTP等协议进行共享。<br><span class="hljs-number">4</span>、调用服务，服务请求者（客户端）通过HTTP或其他协议向服务提供者发送请求，并接收响应。请求中包含了调用服务所需的参数和数据。使用SOAP（Simple <span class="hljs-selector-tag">Object</span> Access Protocol）或<span class="hljs-attribute">REST</span>（Representational State Transfer）等协议进行消息交换。SOAP是一种基于XML的协议，而<span class="hljs-attribute">REST</span>则是一种更轻量级的架构风格，它使用HTTP协议进行通信。<br>SOA结构的实现<br><span class="hljs-number">1</span>、设计服务，确保服务之间的耦合度尽可能低，以便服务的修改和升级不会对其他服务造成太大影响。<br><span class="hljs-number">2</span>、服务注册与发现，服务注册：服务提供者将服务信息注册到服务注册中心（可选），以便服务请求者能够发现和调用这些服务。服务发现：服务请求者通过服务注册中心或其他机制发现所需的服务，并获取服务的绑定信息。<br><span class="hljs-number">3</span>、消息传递与交互，选择适合的消息传递协议（如SOAP、<span class="hljs-attribute">REST</span>等）进行服务之间的交互。<br><span class="hljs-number">4</span>、服务治理，对服务的运行状态进行监控，及时发现并处理服务故障。<br></code></pre></td></tr></table></figure><h2 id="第八章">第八章</h2><h3id="什么是软件体系结构的可靠性为什么要研究软件体系结构的可靠性">1、什么是软件体系结构的可靠性？为什么要研究软件体系结构的可靠性？</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">软件体系结构的可靠性是指软件系统在规定的条件下和规定的时间区间内，完成规定功能的能力，这种能力体现了软件系统在面对各种错误、异常或挑战时，能够保持正常运行并满足用户需求的稳定性。包含，容错能力，健壮性，减少错误和漏洞。<br>研究软件体系结构的可靠性对于软件系统的开发、维护和运行具有重要意义。<br>1、提高用户信任度<br>2、降低维护和修复成本<br>3、满足行业标准和法规要求<br>4、提升系统性能和稳定性<br>5、促进技术创新和发展<br></code></pre></td></tr></table></figure><h3 id="如何模型化系统的可靠性">2、如何模型化系统的可靠性？</h3><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-number">1</span>、明确系统结构和组成，通过系统的详细说明书，确定系统所采用的体系结构风格，如串联系统、并联系统、冗余系统等。<br><span class="hljs-number">2</span>、构建可靠性模型，使用可靠性框图（RBD）来表示系统及其将每一个体系结构风格转换成状态图，并计算状态视图中每一个状态的可靠性及其相应的迁移概率。这有助于理解系统在不同状态下的行为及其对可靠性的影响。组成部分的可靠性关系。RBD是一种图形化工具，用于展示系统如何从其组成部分的可靠性中构建出整体的可靠性。将每一个体系结构风格转换成状态图，并计算状态视图中每一个状态的可靠性及其相应的迁移概率。这有助于理解系统在不同状态下的行为及其对可靠性的影响。<br><span class="hljs-number">3</span>、计算系统可靠性，串联系统：在串联系统中，如果系统功能正常则要求所有零部件都必须成功运行。对于n个独立的零部件串联来说，假设所有的零部件都是概率独立的，系统可靠性<span class="hljs-keyword">R</span>为所有零部件可靠性的乘积，即<span class="hljs-keyword">R</span> = <span class="hljs-keyword">R</span><span class="hljs-number">1</span> * <span class="hljs-keyword">R</span><span class="hljs-number">2</span> * ... * Rn，其中Ri为第i个零件的可靠性。并联系统：在并联系统中，如果任何一个零部件正常工作，系统就能正常工作。对于n个独立的零部件并联来说，系统可靠性<span class="hljs-keyword">R</span>至少为<span class="hljs-number">1</span>减去所有零部件同时失效的概率，即<span class="hljs-keyword">R</span> = <span class="hljs-number">1</span> - (<span class="hljs-number">1</span>-<span class="hljs-keyword">R</span><span class="hljs-number">1</span>) * (<span class="hljs-number">1</span>-<span class="hljs-keyword">R</span><span class="hljs-number">2</span>) * ... * (<span class="hljs-number">1</span>-Rn)。冗余系统：对于包含冗余部件的系统，需要根据冗余的类型（如工作冗余、备用冗余等）和冗余部件的可靠性来计算系统的整体可靠性。冗余系统的可靠性通常高于非冗余系统，因为它可以在部分部件失效时仍然保持系统的正常运行。<br><span class="hljs-number">4</span>、考虑其他因素，共模故障，维修性，环境因素<br><span class="hljs-number">5</span>、使用专业工具和方法，故障树分析（FTA），失效模式和影响分析（FMEA）<br></code></pre></td></tr></table></figure><h3id="软件体系结构风险分析有哪些基本步骤">3、软件体系结构风险分析有哪些基本步骤？</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">1、建模与文档化，使用特定的体系结构描述语言（如ADL）来建模，这有助于精确地表示软件系统的各个组成部分及其之间的关系。建模过程有助于深入理解系统的结构，并为后续的风险分析提供基础。<br>2、复杂性分析，利用模拟技术来评估软件系统的复杂性。复杂性是风险的重要来源之一，过高的复杂性可能导致系统难以维护、测试和理解，进而增加风险。通过模拟运行和性能测试等方法，可以识别系统中的复杂性和潜在的瓶颈。<br>3、严重性分析，FMEA是一种常用的风险分析方法，它通过分析系统中每个组成部分的失效模式及其对整个系统的影响，来评估风险的严重程度。结合模拟运行的结果，可以进一步验证和量化风险的严重性。<br>4、风险因子开发，在软件体系结构中，构建（即系统的各个组成部分）和连接件（即构建之间的交互方式）是风险的重要来源。为这些元素开发启发式风险因子，有助于更准确地评估它们对系统整体风险的影响。<br>5、风险评估与分析，利用图论中的算法（如路径分析、割集分析等）对CDG进行分析，可以量化系统中各个部分的风险水平，并识别出关键的风险路径和节点。这有助于制定针对性的风险缓解措施。<br>6、复审与演化，在软件开发的不同阶段对体系结构进行复审，以确保其符合设计要求并满足业务需求。复审过程中应重点关注潜在的风险点，并评估现有风险缓解措施的有效性。<br></code></pre></td></tr></table></figure><h3id="软件体系结构测试是什么熟悉使用抽象化学机进行测试的方法">4、软件体系结构测试是什么？熟悉使用抽象化学机进行测试的方法。</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs">软件体系结构测试是一种评估软件体系结构是否满足预期需求和设计目标的测试方法。更侧重于检查软件的整体结构、组件之间的交互以及它们如何共同工作以实现系统功能。这种测试方法主要关注以下几个方面：结构合理性、性能评估、可扩展性和可维护性、安全性。<br>抽象化学机是一种基于操作的系统框架，它不仅能够描述系统的静态特征，还能从系统操作的动态性方面进行描述，在软件体系结构测试中，CHAM可以用于模拟和验证软件体系结构的动态行为，从而帮助测试人员发现潜在的问题和缺陷。<br>步骤：<br>1、定义系统模型：<br>2、生成LTS（带标号的迁移系统）<br>3、设计测试用例<br>4、执行测试<br>5、验证测试结果<br>6、迭代优化<br></code></pre></td></tr></table></figure><h2 id="第九章">第九章</h2><h3 id="为什么要评估软件体系结构">1、为什么要评估软件体系结构？</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs">评估软件体系结构在软件开发过程中是至关重要的，原因主要体现在以下几个方面：<br>1、确保系统满足需求：<br>软件体系结构是系统设计的高级抽象，它定义了系统的组织结构和组件之间的交互方式。通过评估体系结构，可以验证系统是否能够按照预定的需求进行设计和构建，确保系统能够满足用户的期望。<br>2、提高系统的质量：<br>软件体系结构的质量直接影响整个软件系统的质量。评估体系结构可以帮助发现潜在的设计缺陷、性能瓶颈、安全漏洞等问题，从而及时采取措施进行修复和改进，提高系统的稳定性、可靠性和安全性。<br>3、促进团队协作：<br>软件体系结构为团队成员提供了一个共同的理解基础。通过评估体系结构，团队成员可以更好地理解系统的整体结构和各个组件的职责，促进团队成员之间的沟通和协作，提高开发效率。<br>4、支持决策制定：<br>在软件开发过程中，经常需要做出关于技术选型、架构调整等关键决策。评估软件体系结构可以为这些决策提供科学依据，帮助团队选择最合适的方案，减少决策失误和不必要的风险。<br>5、适应变化：<br>软件系统的需求和环境是不断变化的。评估软件体系结构可以帮助团队了解系统的可扩展性、可维护性和可重用性等特性，从而在面对需求变化时能够灵活地进行调整和优化，确保系统能够持续满足业务需求。<br>6、优化成本效益：<br>软件体系结构的选择和实现方式直接影响软件开发的成本和效益。通过评估体系结构，可以评估不同方案的成本效益比，选择性价比最高的方案，降低开发成本并提高系统的经济效益。<br>7、提高用户体验：<br>软件体系结构的设计直接影响系统的性能和用户体验。通过评估体系结构，可以优化系统的性能瓶颈和交互流程，提高系统的响应速度和易用性，从而提升用户的满意度和忠诚度。<br></code></pre></td></tr></table></figure><h3 id="从哪些方面评估软件体系结构">2、从哪些方面评估软件体系结构？</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs">性能：<br>定义：系统的影响能力，即系统对某个事件作出响应的时间或在某段时间内系统所能处理的事件个数。<br>评估内容：包括响应时间、吞吐量、并发用户数等指标，确保系统能够满足业务需求。<br>可靠性：<br>定义：软件系统在应用或系统错误面前，在意外或错误使用的情况下维持软件系统的功能特性的基本能力。<br>评估内容：包括容错性、健壮性等，确保系统能够稳定运行，减少故障和停机时间。<br>可用性：<br>定义：系统能够正常运行的时间比例。<br>评估内容：通常用两次故障间的时间长度或在出现故障时系统能够恢复正常的速度来表示。<br>安全性：<br>定义：系统在向合法用户提供服务的同时能够阻止非授权用户使用的企图或拒绝服务的能力。<br>评估内容：包括机密性、完整性、不可否认性及可控性等特性，确保系统数据的安全和隐私保护。<br>可修改性（可维护性、可扩展性、可移植性等）：<br>定义：能够快速地以较高的性能代价比对系统进行变更的能力。<br>评估内容：包括代码的可读性、可测试性、模块化程度等，确保系统易于维护和扩展。<br>功能性：<br>定义：系统所能完成所期望的工作的能力。<br>评估内容：验证系统是否满足业务需求，包括功能完整性、准确性等。<br>可变性：<br>定义：体系结构经扩充或变更而成为新体系结构的能力。<br>评估内容：考虑系统是否支持未来的变更和扩展，包括组件的替换、新增等。<br>可集成性：<br>定义：系统能与其他系统协作的程度。<br>评估内容：考虑系统与其他系统的接口兼容性、数据交换能力等。<br>互操作性：<br>定义：与其他环境或者系统本身相互作用的能力。<br>评估内容：验证系统是否能够在不同环境下正常工作，与其他系统的兼容性等。<br></code></pre></td></tr></table></figure><h3id="atam评估方法的基本步骤是什么">3、ATAM评估方法的基本步骤是什么？</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs">一、准备阶段<br>描述ATAM方法：向评估团队和参与人员介绍ATAM方法的基本原理、目的和流程，确保所有人对评估过程有清晰的理解。<br>二、引入背景信息<br>描述商业动机：阐述软件开发项目的商业目标、需求背景以及期望达到的商业效果，这有助于评估团队理解项目的重要性和优先级。<br>三、体系结构描述<br>描述体系结构：详细展示软件系统的体系结构，包括其主要组件、组件之间的关系以及它们如何协同工作。这可以通过体系结构图、组件描述文档等形式进行。<br>四、分析阶段<br>确定体系结构方法：识别并明确体系结构中的关键设计决策和模式，这些决策和模式将作为后续分析的基础。<br>生成质量属性效用树：针对软件系统的关键质量属性（如性能、可靠性、安全性等），构建效用树来量化这些属性对系统成功的重要性。效用树有助于评估团队理解不同质量属性之间的权衡关系。<br>五、场景分析与讨论<br>集体讨论确定场景优先级：通过头脑风暴和讨论，确定一系列能够代表系统关键使用情况和潜在风险的场景。然后，根据这些场景对系统成功的重要性进行优先级排序。<br>分析体系结构方法：针对每个优先级较高的场景，评估体系结构在该场景下的表现。这包括分析体系结构如何支持场景中的需求、可能存在的瓶颈和风险点等。<br>六、结果呈现与反馈<br>结果的表述：将评估结果整理成报告或演示文稿，向项目团队和相关利益方展示。报告应包含对体系结构优缺点的分析、潜在风险的识别以及改进建议等内容。<br>反馈：鼓励项目团队和相关利益方对评估结果进行反馈和讨论，以便进一步完善和优化体系结构。<br>七、总结与改进<br>总结评价：对整个评估过程进行总结和评价，包括评估方法的适用性、评估结果的准确性以及改进建议的有效性等。<br>提出改进建议：根据评估结果和反馈意见，提出针对体系结构的具体改进建议。这些建议应旨在提高系统的质量、性能和可维护性，以满足项目的商业目标和需求。<br></code></pre></td></tr></table></figure><h3id="详细了解一种体系结构风险分析方法">4、详细了解一种体系结构风险分析方法。</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">以SAAM（Scenario-based Architecture Analysis <span class="hljs-keyword">Method</span>，基于场景的体系结构分析方法）为例。<br>1、场景开发：<br>通过各类风险承担者（如用户、开发者、维护者等）协商讨论，开发一系列任务场景。这些场景应能够体现系统所支持的各种活动，或者描述系统在一定时期后可能进行的各种变化。<br>场景开发的关键是捕获系统的重用方式，以便分析体系结构在不同场景下的表现。<br>2、软件体系结构描述：<br>体系结构描述是<span class="hljs-title function_">SAAM</span>评估的前提和基础。它应该以一种易于理解、合乎语法规则的表示方式呈现，并能体现系统的计算构件、数据构件以及构件之间的关系（数据和控制）。<br>如果没有直接的体系结构描述可用，可以使用逆向工程的方法进行提取。<br>3、单个场景的评估：<br>将开发的场景进行分类，分为直接场景和间接场景。直接场景是指系统已经能满足的场景，而间接场景则需要对体系结构进行适当修改才能满足。<br>针对每个场景，分析体系结构是如何实现的，并列出为支持间接场景所需做出的修改，以及这些修改的难易程度、实现代价等。<br>生成一个关于特定体系结构的场景描述列表，记录每个场景对体系结构的要求和潜在影响。<br>4、场景交互的评估：<br>分析不同场景之间可能存在的交互作用，特别是当多个间接场景需要修改同一个构件或连接件时。<br>通过场景交互的分析，揭示系统构件划分的质量，并在一定程度上表达产品设计的功能分配。<br>生成一个列表中显示所有场景对系统中构件的影响。<br>5、总体评估：<br>对所有场景及其交互进行总体权衡和评价。按照重要性为每个场景及场景交互分派权值，权值的选择应反映该场景表现的质量因素的重要程度。<br>将所有权值相加得出总体评价，以评估体系结构在满足不同场景和质量属性方面的整体表现。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>课程</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Point Cloud Processing</title>
    <link href="/Point-Cloud/Point%20Cloud%20Processing/"/>
    <url>/Point-Cloud/Point%20Cloud%20Processing/</url>
    
    <content type="html"><![CDATA[<h1 id="point-cloud-processing">Point Cloud Processing</h1><h2id="pointnet深度学习研究点云的先驱">PointNet【深度学习研究点云的先驱】</h2><blockquote><p>直接通过神经网络处理点云，提取点云特征，用于对象分类、部件分割、场景语义解析。</p></blockquote><ol type="1"><li>通过MLP对n * 3的点云输入提取特征到逐点特征n * 64</li><li>再经过MLP将n * 64 --&gt; n * 1024</li><li>在1024个维度上执行maxpooling得到全局特征1 * 1024</li></ol><blockquote><p>缺点：一直在做点之间特征的单独提取，除了最后一层maxpolling获取全局信息外，没有将点与其周围点进行融合，提取局部特征。（要么是单个点，要么是所有点，没有类似于CNN的感受野处理周围局部的点）</p></blockquote><h2 id="pointnetpointnet改进版">PointNet++【PointNet改进版】</h2><blockquote><p>PointNet的缺陷在于没有提取局部特征，导致模型泛化、识别细粒度模式能力有限</p></blockquote><p>受CNN的启发，作者想在3D点集中找到结构相同的子区域和对应的区域特征提取器。</p><ul><li>set abstraction<ul><li>samling：使用FPS采样，从N个点中</li><li>采样N'个centroid</li><li>grouping：以采样得到的N'个centroid为中心，选取最近的K个点</li><li>pointnet：对group中的点应用pointnet（maxpolling）得到局部特征</li></ul></li></ul><p>两种特征融合方式：</p><ul><li>Multi-scale grouping</li><li>Multi-resolution grouping</li></ul><h2 id="foldingnet">FoldingNet</h2><blockquote><p>3D点云是从物体表面获得的（从CAD的边界表示中离散化/从LIDAR传感器中采样），直观上，任何3D物体表面都可以通过切割、挤压和拉伸等操作转换为2D平面。</p><p>返回来，可以通过某些折叠操作（folding），将2D点样本粘回对象表面，这些折叠操作初始化为2D网格样本。</p></blockquote><h2 id="snowflakenet">SnowflakeNet</h2><blockquote><p>将完整点云的生成建模为三维空间中点的雪花状生长，其中子点是在每个SPD之后通过拆分父点逐步生成的。</p><p>SPD中引入了skip-transformer，学习最适合局部区域的点分裂模式，由此，SPD可以生成局部紧凑和结构化的点云，具有高度详细的几何信息。</p></blockquote><p><strong>Seed generator</strong></p><p>种子生成器的目标是生成一个粗略但完整的点云P0，能够捕获目标形状的几何和结构。</p><h2 id="pointattn">PointAttN</h2><blockquote><p>消除了显示局部区域操作如KNN，只用FPS、MLP、Attention。</p><p>包含三个部分：特诊提取、种子生成器、点云生成器</p></blockquote><p>Geometric Details Perception（GDP）</p><ul><li>将输入点云特征矩阵X通过FPS下采样得到Y，将Y当作Query矩阵，从X矩阵中找到相似点特征进行聚合（包括形状的相似和距离的接近），从而在模型中感知到局部的几何结构。</li></ul><p>Self-Feature Augment（SFA）- 自注意力</p><ul><li>利用自注意力捕获全局信息</li><li>利用Attention Linear Transformation矩阵进行上采样升维</li></ul>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>所有</category>
      
      <category>Point Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Point Cloud Processing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>企业级软件开发技术</title>
    <link href="/%E6%89%80%E6%9C%89/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    <url>/%E6%89%80%E6%9C%89/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="企业级软件开发技术">企业级软件开发技术</h3><ul><li><p>J2EE产生背景</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">J2EE是Sun公司为了满足多层体系结构企业级应用开发的需求，在J2SE的基础上，根据企业级应用的各种需求，提出的一种标准。</span><br><span class="hljs-keyword"></span>背景：互联网的兴起，企业级应用的需求，跨平台的需求，分布式计算的需求（随着企业应用的复杂性增加，需要将应用逻辑分布在不同的服务器上，以提高性能、可靠性和可伸缩性。）<br></code></pre></td></tr></table></figure></li><li><p>J2EE设计的考虑</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">J2EE设计考虑到系统的可维护性和可扩展性进行了分层架构，包括客户层，Web层，业务层和企业信息系统层。考虑到业务逻辑的不同将系统划分为不同的组件，如JavaBeans、Servlet、Enterprise </span><span class="hljs-keyword">JavaBeans等，组件时可重用的，可替换的。</span><br></code></pre></td></tr></table></figure></li><li><p>J2EE针对分布式的处理，在分布式上的相关技术</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">J2EE平台本质上是一个分布式的服务器应用程序设计环境，是一个专为分布式计算设计的平台，它提供了一套标准化的规范和接口，使得开发者能够构建分布式、多层次、高可用性、可扩展的企业级应用。</span><br><span class="hljs-keyword"></span><br>与分布式相关的技术：<br>EJB、<span class="hljs-keyword">JMS、JPA、JTA、JAX</span><br></code></pre></td></tr></table></figure></li><li><p>J2EE的组成</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">四层模型<br>客户层-Web层-业务层-企业信息系统层<br>JavaApplet-JSP|<span class="hljs-string">Servlet</span>|<span class="hljs-string">EJB</span>|<span class="hljs-string">数据库</span><br></code></pre></td></tr></table></figure></li><li><p>J2EE和MVC的关系</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">J2EE是一个Java平台，提供了一系列规范和接口，用于开发多层次、分布式、可扩展、安全的企业级应用。J2EE包含了多个组件和技术，如Servlets、JavaServer </span>Pages、Enterprise <span class="hljs-keyword">JavaBeans、Java </span>Message Serice（<span class="hljs-keyword">JMS）。</span><br><span class="hljs-keyword"></span>MVC是一种设计模式，用于将应用分为三个核心部分：模型，视图和控制器。这种分离有助于管理复杂的应用，并使代码更易于维护和扩展。<br><span class="hljs-keyword">J2EE与MVC架构的关系在于，J2EE平台提供了实现MVC模式所需的技术和组件。J2EE应用中，模型可以时JavaBeans，Session </span><span class="hljs-keyword">Beans或实体Beans。视图通常是JSP页面、HTML、XML或JSON实现。控制器通常是Servlets实现。J2EE平台提供了构建MVC架构所需的所有工具和架构。</span><br></code></pre></td></tr></table></figure></li><li><p>Web容器和ejb容器的区别</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Web容器主要负责运行和管理Web应用程序，特别是基于Servlet和<span class="hljs-keyword">JSP的技术，Web容器处理客户端的HTTP请求，并将这些请求分发给相应的Servlet或JSP页面进行处理。Web容器的主要作用包括</span><br><span class="hljs-keyword"></span><span class="hljs-number">1</span>.请求处理，接受客户端的HTTP请求，并将其分发给相应的Web组件（如Servlet）<br><span class="hljs-number">2</span>.生命周期关系，负责Servlet的创建，初始化，服务请求，销毁等生命周期管理。<br><span class="hljs-number">3</span>.会话关系，管理用户会话，包括会话的创建，维护和销毁。<br><span class="hljs-number">4</span>.安全性：提供用户身份验证和授权等安全功能<br><span class="hljs-number">5</span>.日志记录：记录Web应用程序的运行记录<br><span class="hljs-number">6</span>.部署和配置：负责Web应用程序的部署和配置管理。<br><br>EJB<br>EJB容器主要负责运行和管理企业<span class="hljs-keyword">JavaBean，提供事务管理，安全性，并发控制，分布式计算等服务。</span><br><span class="hljs-keyword"></span>EJB容器的主要作用包括：<br><span class="hljs-number">1</span>.事务管理：提供声明式事务管理，确保业务操作的原子性，一致性，隔离性和持久性。<br><span class="hljs-number">2</span>.安全性：提供细粒度和安全控制<br><span class="hljs-number">3</span>.并发控制<br><span class="hljs-number">4</span>.生命周期管理<br><span class="hljs-number">5</span>.远程调用<br><span class="hljs-number">6</span>.资源池<br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Web容器主要处理HTTP请求和Web相关的功能，而EJB容器主要处理企业级业务逻辑和分布式服务。<br>Web容器运行Servlet和<span class="hljs-keyword">JSP，而EJB容器运行会话Bean、实体Bean和消息驱动Bean。</span><br><span class="hljs-keyword"></span>部署单元不同，Web容器部署Web应用程序（WAR），EJB容器部署企业应用（EAR），其中可能包含EJB（<span class="hljs-keyword">JAR）和Web（WAR）模块。</span><br></code></pre></td></tr></table></figure></li><li><p>JSP</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">JSP是一种动态网页技术，JSP技术允许开发者将Java代码和<span class="hljs-selector-tag">HTML</span>标记语言混合在一起，以创建动态的、基于Web的应用程序。JSP页面在服务端执行，生成<span class="hljs-selector-tag">HTML</span>或其他格式的内容，然后发送到客户端浏览器进行显示。<br>工作原理：<br><span class="hljs-number">1</span>.用户请求jsp页面，浏览器发送请求到服务器。<br><span class="hljs-number">2</span>.如果是第一次请求改jsp页面，服务器会将jsp文件转换为一个servlet（java类），然后编译这个java类。<br><span class="hljs-number">3</span>.服务器调用这个Servlet的service方法，处理请求并生成响应。<br><span class="hljs-number">3</span><span class="hljs-selector-class">.Servlet</span>生成<span class="hljs-selector-tag">HTML</span>内容，并将其作为响应发送回客户端浏览器。<br></code></pre></td></tr></table></figure></li><li><p>Servlet</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Servlet是<span class="hljs-keyword">Java提供的一种用于扩展服务器功能的技术。它是运行在Web服务器或应用服务器上的Java类，用于处理客户端请求并生成响应。Servlet通常用于处理HTTP请求，但它们也可以用于处理其他类型的协议。</span><br><span class="hljs-keyword"></span><span class="hljs-number">1</span>.当Web服务器（Tomcat）启动或第一次请求到达时，Servlet容器回加载并实例化Servlet。<br><span class="hljs-number">2</span>.初始化<br><span class="hljs-number">3</span>.处理请求，service（）<br><span class="hljs-number">4</span>.销毁<br></code></pre></td></tr></table></figure></li><li><p>EJB</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">EJB是一种<span class="hljs-keyword">Java </span>EE技术，用于开发和部署分布式、面向对象的业务逻辑。将业务逻辑从客户端界面和底层数据访问代码中分离出来，使得业务逻辑可以独立于应用程序的其他部分进行开发，部署和扩展。<br>三种<span class="hljs-keyword">Bean</span><br><span class="hljs-keyword"></span><span class="hljs-number">1</span>.会话<span class="hljs-keyword">Bean，代表客户端的一次操作或会话，有状态：Bean的状态改变，接下来的方法调用中，客户端会出现同样的状态，无状态：不用保存客户端的状态，方法调用之间没有存储信息，不会保存会话状态、</span><br><span class="hljs-keyword"></span><span class="hljs-number">2</span>.实体<span class="hljs-keyword">Bean，代表持久化数据，通常与数据库中的表行对应，用于表现O/R映射。</span><br><span class="hljs-keyword"></span><span class="hljs-number">3</span>.消息驱动<span class="hljs-keyword">Bean，用于处理异步消息，接受客户端发送的消息，并据此触发响应的业务逻辑。通常与JMS一起使用，</span><br></code></pre></td></tr></table></figure></li><li><p>JMS</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">JMS是一个Java EE的API，用于在两个或多个客户端之间异步发送和接受消息。JMS提供了一种标准的方式来实现消息传递，使得开发这可以专注于业务逻辑，而不必关心消息的底层传输细节。<br>JMS支持两种消息传递机制：<br><span class="hljs-number">1</span>.点对点模型，消息被发送到一个特定的队列，然后被一个或多个消费者接受，每个消息只能被一个消费者接受，一旦被消费，就会从队列中消失，保证了消息的顺序传递，并且会确保消息不会消失。<br><span class="hljs-number">2</span>.发布<span class="hljs-regexp">/订阅模式。消息被发送到一个特定的主题，然后被所有订阅了该主题的消费者接受，与点对点模型不同，发布/</span>订阅模型中的消息可以被多个消费者接受，而且消费者可以随时加入或离开主题。<br>主要组件：消息生产者，消息消费者，消息，队列管理器，主题管理器，JMS提供者<br></code></pre></td></tr></table></figure></li><li><p>JNDI</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">JNDI（Java </span>Naming <span class="hljs-keyword">and </span><span class="hljs-keyword">Directory </span>Interface）是一个<span class="hljs-keyword">Java </span>API， 用于在<span class="hljs-keyword">Java应用程序中查找和访问各种命名和目录服务。JNDI提供了一种统一的方式来访问不同类型的目录和命名服务，如DNS，LDAP，CORBA等。JNDI允许开发者将服务名称与实际服务实现分离，使得应用程序可以更加灵活和可配置。</span><br><span class="hljs-keyword"></span>主要概念：<br><span class="hljs-number">1</span>.命名上下文，包含一组名称和对象的目录结构，类似文件系统中的目录<br><span class="hljs-number">2</span>.目录服务i，提供了命名和目录功能的服务，如LDAP（Lightweight <span class="hljs-keyword">Directory </span>Access Protocol）服务。<br><span class="hljs-number">3</span>.绑定，将一个名称与一个对象关联起来的操作。<br><span class="hljs-number">4</span>.查找，根据名称在命名上下文中检索对象的操作。<br><span class="hljs-number">5</span>.引用<br></code></pre></td></tr></table></figure></li><li><p>ejb和javabean的区别</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">JavaBean是一种Java类，它遵循特定的命名和设计模式，JavaBean通常用于封装数据，作为一个简单的值对象或者数据容器。JavaBean类通常是可序列化的，并且提供无参构造函数。它的属性通过一组标准的getter和setter方法来访问和修改，JavaBean可以在任何Java应用程序中使用，包括桌面应用程序，Web应用程序等。</span><br><span class="hljs-keyword"></span>EJB是<span class="hljs-keyword">Java </span>EE的一部分，它是一个规划，用于开发和部署分布式、面向对象的业务逻辑，EJB旨在简化企业级应用程序的开发，提供事务管理、安全和分布式计算等底层服务，EJB分为会话<span class="hljs-keyword">Bean、实体Bean、消息驱动Bean，企业级、分布式、并发、生命周期</span><br><span class="hljs-keyword"></span><br><span class="hljs-number">1</span>.两者都是可重用的组件，都有get和set方法，都可以进行组装来构建<span class="hljs-keyword">java应用</span><br><span class="hljs-keyword"></span><span class="hljs-number">2</span>.<span class="hljs-keyword">JavaBean不能跨进程访问，较简单，EJB基于RMI技术，可以被远程访问，较复杂</span><br><span class="hljs-keyword"></span><span class="hljs-number">3</span>.<span class="hljs-keyword">JavaBean可以运行在一般的Web容器上，EJB必须部署在EJB容器中</span><br></code></pre></td></tr></table></figure></li><li><p>JDBC</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">是Java语言提供的一种数据库连接API，允许Java程序和多种关系型数据库进行交互。<br><span class="hljs-number">1.</span>加载数据库驱动<br><span class="hljs-number">2.</span>建立与数据库的连接<br><span class="hljs-number">3.</span>创建<span class="hljs-keyword">statement</span><br><span class="hljs-number">4.</span>执行<span class="hljs-keyword">SQL</span><br><span class="hljs-number">5.</span>处理结果<br><span class="hljs-number">6.</span>关系资源<br></code></pre></td></tr></table></figure></li><li><p>JDBC两种连接方式的特点和优缺点</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">直接连接：使用DriverManager<br>每次请求时，通过DriverManager直接创建一个新的连接。连接的创建和关闭通常在应用程序代码中显式进行。特点是简单，更容易理解，新手。缺点是每次数据库操作都要创建和关闭，增加数据库的负载和延迟。浪费系统资源。连接不复用<br><br>池连接（使用DataSource和连接池）<br>连接池是一个预先创建的连接集合，用于管理和复用数据库连接。应用程序从连接池中获取连接，使用完毕后返回到池中，而不是关闭连接。优点提高了应用程序的性能，避免过多的消耗系统资源。灵活，线程安全。缺点，复杂，配置需要学习时间。<br></code></pre></td></tr></table></figure></li><li><p>连接池优点、配置、特性、访问步骤</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">优点：性能提升、节约资源、加快响应、并发支持、稳定性强、配置灵活<br><br>配置：最大连接数、最小连接数、连接超时、测试连接、最大空余时间<br><br>特性：连接复用、自动收缩、负载均衡<br><br>访问步骤：加载驱动 -&gt; 创建数据源DataSource -&gt; 获取连接（从连接池） -&gt; 使用连接创建StateMent -&gt; 处理SQL结构 -&gt; 释放资源 -&gt; 关闭连接池<br></code></pre></td></tr></table></figure></li><li><p>EJB本地接口、远程接口</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">EJB访问过程：EJB客户端通过JNDI查找EJB的Home接口，然后通过Home接口获得EJB对外接口，获得对外接口后，调用对外接口定义的EJB业务方法，而真正的逻辑是Bean对象完成的<br></code></pre></td></tr></table></figure></li><li><p>消息中间件的原理</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs">基于消息队列的机制。允许应用程序根据队列来发送和接受消息，从而实现系统间的解耦和异步通信，<br>消息生产者：<br>发送消息的应用程序或服务，将消息发送到消息队列中，然后可以继续执行其他任务，无需等待消息被处理。<br>消息队列：<br>存储消息的缓冲区，确保消息在生产者发送和消费者接受之间得到暂存。队列通常由消息中间件管理，提供对消息的持久化，有序传递，优先级排序<br>消息消费者<br>从消息队列中接受消息的应用程序或服务<br>中间件服务<br>管理和协调消息传递的核心组件，接受生产者消息，存储队列，传递消费者消息<br>消息协议<br>定义消息格式和通信规则<br></code></pre></td></tr></table></figure></li><li><p>社交通讯软件的架构</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs">社交通讯软件的架构通常需要支持高并发、实时性、数据一致性以及高可用性。通常采用微服务架构、事件驱动架构或两者的结合。<br><br>客户端层：<br>IOS，Android，Web前端，用户交互，网络请求<br>API网关：<br>负责处理客户端的所有请求，进行路由、认证、授权、限流、熔断、日志记录，提供统一的接口给客户端，简化客户端的调用逻辑。<br>服务层；<br>微服务，消息服务，搜索，服务之间用RESTful方式交互<br>消息队列/中间件<br>RebbitMQ、Kafka，用于处理异步消息，事件广播、服务解耦。用户发送消息时，消息服务可以将消息写入消息队列，由其他服务异步处理和分发。<br>数据库层<br>缓存层<br>搜索引擎<br>文件存储<br>实时通讯<br>分布式<br>服务的注册与发现<br>持续集成<br></code></pre></td></tr></table></figure></li><li><p>持久化技术，ORM技术</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">持久化包括：<br>文件系统<br>关系数据库<br>非关系数据库<br>对象数据库<br>分布式数据库<br>内存数据库<br><br><span class="hljs-keyword">ORM技术</span><br><span class="hljs-keyword"></span>面向对象程序设计语言和关系数据库之间的桥梁，主要特点<br>映射，封装，数据持久化，事务管理，查询语言<br>常见<span class="hljs-keyword">ORM包括，Hibernate，</span><br></code></pre></td></tr></table></figure></li><li><p>JDBC、实体Bean和Hibernate特点</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">JDBC提供了最基础的数据库操作能力，适用于简单的数据库交互场景；实体Bean是EJB规范的一部分，主要用于表示业务数据，但在现代Java应用中已经较少使用；Hibernate是一个功能强大的ORM框架，适用于需要复杂对象关系映射和数据库操作的场景。<br></code></pre></td></tr></table></figure></li><li><p>缓存的分类</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs">读取缓存：解决读取速度慢<br>写入缓存：解决写入速度慢<br>读写缓存，狭义上解决介质读写速度不匹配问题，<br><br>HTTP缓存，页面级缓存，数据库缓存，opcode缓存，反向代理缓存，<br><br>按存储介质分，内存：网站进程内，同服务器独立进程，独立服务器，分布式服务器组。磁盘：本地文件和数据库，独立服务器<br>按照存储的数据分<br>延迟加载的缓存：<br></code></pre></td></tr></table></figure></li><li><p>大型网站设计一般涉及的主要缓存技术</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.浏览器缓存：图片、css、脚本存储<br>2.cdn缓存：内容分发网络缓存静态资源，图片，视频，css/js文件到全球各地的边缘服务器上，当用户请求这些资源时，CDN会从最近的边缘服务器提供内容，从而减少延迟和提高加载速度。<br>3.反向代理缓存：Nginx位于Web服务器前，缓存用于请求的动态内容，相同的请求再次到来时，代理服务器可以直接缓存的内容，减轻后端服务器的负担。<br>4.数据库缓存：MySQL的查询缓存，存储了查询结果，减少数据库的查询时间。<br>5.对象缓存系统：Redis用于存储小块的经常访问的数据，如用户会话，配置参数，计数器等， 这些数据通常在内存中，访问速度非常快<br>6.页面缓存，将整个动态生成的页面缓存起来，当用户请求相同的页面时，直接返回缓存的页面内容，而不是重新生成。<br>7.应用层缓存<br>8.分布式缓存：存储跨多个服务器共享的数据，确保所有服务器都能快速访问相同的数据副本。<br></code></pre></td></tr></table></figure></li><li><p>缓存失效</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">解决缓存失效有三种思路<br>1.使用consistent hashing算法，把数据缓存分片，减少缓存宕机对服务的影响范围。在服务器数量比较少时，增加虚拟节点保证服务器能均匀分布在圆环上。<br>2.缓存多份<br>3.实现缓存持久化或半持久化<br></code></pre></td></tr></table></figure></li><li><p>缓存的常见模型和应用场景</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs">常见缓存模型：<br>1.内存缓存：LRU、MRU、FIFO、LFU<br>2.磁盘缓存：用于存储那些不经常访问，但需要快速访问的数据<br>3.分布式缓存：Redis，Memcached用于分布式系统中，可以提供高性能、可扩展的缓存服务。<br>4.浏览器缓存：根据HTTP头部信息决定是否使用本地缓存的资源<br>5.数据库缓存：某些数据库管理系统如MySQL的查询缓存会缓存查询结果，以加快后续查询的速度。<br><br>应用场景：<br>1.Web应用：缓存经常请求的页面或数据，减少数据库负载，提高响应速度。<br>2.数据库查询优化：预先计算和存储复杂的查询结果，以便快速响应用户的请求<br>3.文件系统<br>4.电商平台<br>5.社交媒体：缓存用户动态、评论等<br>6.移动应用：在没有网络连接时也能访问内容<br>7.API服务<br>8.大数据处理<br></code></pre></td></tr></table></figure></li><li><p>负载均衡几种策略</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">1</span>.轮询<br><span class="hljs-number">2</span>.加权轮询<br><span class="hljs-number">3</span>.最少链接<br><span class="hljs-number">4</span>.加权最少连接<br><span class="hljs-number">5</span>，<span class="hljs-built_in">IP</span>哈希<br><span class="hljs-number">6</span>.URL哈希<br><span class="hljs-number">7</span>.基于延迟的负载均衡<br></code></pre></td></tr></table></figure></li><li><p>负载均衡下Session的处理方案，优缺点</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span><span class="hljs-keyword">Session</span>复制，<br><span class="hljs-number">2.</span>cookie-based <span class="hljs-keyword">session</span>，完全无状态，服务器不需要存储任何<span class="hljs-keyword">session</span>信息，所有的状态都存储在客户端的cookie中，安全性问题，大小限制<br><span class="hljs-number">3.</span>分布式缓存，redis，高性能，可伸缩性共，多个服务器之间共享<br><span class="hljs-number">4.</span>数据库<span class="hljs-keyword">session</span>存储，<br></code></pre></td></tr></table></figure></li><li><p>SOA（ESB）</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-keyword">SOA</span>，面向服务的架构，是一种设计方法，其中应用程序由一系列松散耦合的服务组成，这些服务通过标准化的接口和协议进行通信。<span class="hljs-keyword">SOA</span>关注于服务的重用性和互操作性。<br>ESB是一种中间件，它支持<span class="hljs-keyword">SOA</span>的实施，允许不同服务之间的消息传递，并且可以转换消息的格式以适应不同的接收者<br>微服务架构是一种将应用程序构建为一组小型，独立服务的方法，每个服务运行在自己的进程中，通常通过轻量级机制如HTP RESTful API进行通信，<br></code></pre></td></tr></table></figure></li><li><p>中台</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">在大型企业和互联网公司中，中泰通常指的是一个集中的服务平台，它提供一套共享的服务和工具，如用户管理，订单处理，数据分析，支付处理等，以支持多个业务线和产品。<br>中台提供的服务和工具可以被多个业务线和产品共<span class="hljs-selector-tag">i</span>想，避免重复开发的情况。<br>封装和抽象，数据整合，<br></code></pre></td></tr></table></figure></li><li><p>微服务架构</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">微服务架构是一种将应用程序设计为一组小型、独立服务的方法，每个服务运行在自己的进程中，通常通过轻量级机制进行通信，<br>优点，模块化，松散耦合，独立开发，独立部署，灵活性和扩展性，技术多样性，可以采用不同的技术栈，容错性，易于部署<br>缺点，复杂性，运维，初始成本<br><br></code></pre></td></tr></table></figure></li><li><p>系统拆分，水平和垂直</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">系统拆分呢是将一个大型、复杂的系统分解为多个较小的、更易于管理和维护的部分的过程，可以提高系统的可伸缩性，可维护性和可扩展性。<br>水平拆分：也称为分层架构，将系统按照不同的功能层次进行拆分，将表现层，业务逻辑层和数据访问层分离，每一层负责不同的功能，层与层之间通过定义良好的接口进行通信，提高了系统的模块化程序，便于管理和维护，各层可以独立开发，降低耦合，层数过多，系统复杂性增加<br><br>垂直拆分：将系统按照业务功能进行拆分，每个部分负责一个特定的业务领域或功能模块。每个模块专注于一个业务领域，可能会导致重估的功能实现，<br></code></pre></td></tr></table></figure></li><li><p>数据库拆分</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">水平拆分：将数据表按照某种规则，拆分到多个数据库中，每个数据库中包含相同的数据表结构，但是存储不同的数据集，提高了系统的可伸缩性，<br>垂直拆分，将不同的表或表的一部分拆分到不同的数据库中，通常基于业务功能或数据访问模式，将相关的表或数据存储在一起，以提高性能和可维护性，<br>功能拆分<br>地理拆分<br></code></pre></td></tr></table></figure></li><li><p>提高网站访问速度的常用方法</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs">CDN内容分发网络<br>压缩文件<br>减少HTTP请求<br>使用异步加载<br>优化图片<br>使用缓存<br>服务器优化，优化配置<br>数据库优化，<br>最小化HTTP重定向<br></code></pre></td></tr></table></figure></li><li><p>TOGAF</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">The Open <span class="hljs-keyword">Group</span> <span class="hljs-title">Architecture</span> Framework是一个开放的组织架构框架，提供了一套全面的结构化的方法来设计和实施企业架构。<br><br>主要的架构包含<br>业务架构，应用架构，技术架构，数据架构，安全架构，治理交媾，基础设施架构，服务架构，运营架构<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>课程</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>幻兽帕鲁服务器指令</title>
    <link href="/%E6%89%80%E6%9C%89/%E5%B9%BB%E5%85%BD%E5%B8%95%E9%B2%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/%E6%89%80%E6%9C%89/%E5%B9%BB%E5%85%BD%E5%B8%95%E9%B2%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="幻兽帕鲁服务器指令">幻兽帕鲁服务器指令</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta"># 启动幻兽帕鲁的服务</span><br>sudo systemctl start pal-<span class="hljs-keyword">server</span><br><span class="hljs-meta"># 重启幻兽帕鲁的服务</span><br>sudo systemctl restart pal-<span class="hljs-keyword">server</span><br><span class="hljs-meta"># 关闭幻兽帕鲁的服务</span><br>sudo systemctl stop pal-<span class="hljs-keyword">server</span><br><span class="hljs-meta"># 查询幻兽帕鲁服务的状态</span><br>sudo systemctl status pal-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 编辑配置文件</span><br>sudo nano ~<span class="hljs-regexp">/Steam/</span>steamapps<span class="hljs-regexp">/common/</span>PalServer<span class="hljs-regexp">/Pal/</span>Saved<span class="hljs-regexp">/Config/</span>LinuxServer/PalWorldSettings.ini<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>others</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3D gaussian splatting</title>
    <link href="/%E6%89%80%E6%9C%89/3d%20gaussian%20splatting/"/>
    <url>/%E6%89%80%E6%9C%89/3d%20gaussian%20splatting/</url>
    
    <content type="html"><![CDATA[<h1 id="d-gaussian-splatting">3D gaussian splatting</h1><h2 id="前置知识">前置知识</h2><h3 id="球谐函数">球谐函数</h3><p>我们在学习高等数学的时候都学习过傅里叶，任何一个二维函数都可以分解成为不同的正弦与余弦之和：<imgsrc="C:\Users\Huang\AppData\Roaming\Typora\typora-user-images\image-20231214180128456.png"alt="image-20231214180128456" /> <spanclass="math inline">\(f(x)=a_0+\sum_{n=1}^{+\infty}a_ncos\frac{n\pi}{l}x+b_nsin\frac{n\pi}{l}x\)</span>这里<span class="math inline">\(cos\frac{n\pi}{l}x\)</span>和<spanclass="math inline">\(sin\frac{n\pi}{l}x\)</span>就叫作基函数，原则上来讲当<spanclass="math inline">\(n-&gt;+\infty\)</span>时，我们就可以完美拟合这个函数，即使只有有限个<spanclass="math inline">\(n\)</span>，我们也可以对这个函数进行近似。 <spanclass="math inline">\(f(x) \approxa_0+\sum_{n=1}^{i}a_ncos\frac{n\pi}{l}x+b_nsin\frac{n\pi}{l}x\)</span></p><p>这种基函数的思想其实在数学中很常见。我们考虑一个有界，闭合的，平滑的曲面。 <imgsrc="C:\Users\Huang\AppData\Roaming\Typora\typora-user-images\image-20231214180552584.png"alt="image-20231214180552584" /></p><p><imgsrc="https://pic1.zhimg.com/v2-db5bb558d04a9a6e0ec0cebf67e4d2a0_r.jpg"alt="输入图片描述" /> 它可以用球面函数表示方法来表示<spanclass="math inline">\(f(\theta,\phi)\)</span>，这样一个函数同样可以有自己的基函数来组成。<imgsrc="https://pic3.zhimg.com/v2-44f5c58a5fef6b8f047a8c7167b040e2_r.jpg" />它的基函数长这样： <imgsrc="https://picx.zhimg.com/70/v2-cdfac824da2d8ed9581fc39b378b5681_1440w.avis?source=172ae18b&amp;biz_tag=Post"alt="输入图片描述" />这个就是球谐函数。球谐函数的推导比较复杂，而且是递推的，这里不做介绍，只列一些比较低阶的球谐函数的方程：<imgsrc="https://pic2.zhimg.com/80/v2-ba5369958555bd55af7b17c038d8bb95_1440w.webp"alt="输入图片描述" />因此，我任意一个球面坐标的函数，就可以用多个球谐函数来近似。 <spanclass="math inline">\(f(\theta,\phi) \approxa_0f_{l=0,m=0}f(\theta,\phi)+a_1f_{l=1,m=-1}f(\theta,\phi)+a_2f_{l=1,m=0}f(\theta,\phi)+a_3f_{l=1,m=1}f(\theta,\phi)+a_4f_{l=2,m=-2}f(\theta,\phi)+a_5f_{l=2,m=-1}f(\theta,\phi)+...\)</span>如果想要近似准确点，就多用一些level的球谐函数，如果不需要太准确，用较少的球谐函数就可以。### 3D Gaussian #### 一维高斯分布 一维高斯的概念我们都很熟悉，公式为：<span class="math inline">\(p(x)=\frac{1}{\sqrt {2\pi}\sigma}e^{-\frac{(x-u)^2}{2 \sigma^2}}\)</span> 其图像如下： <imgsrc="https://img-blog.csdnimg.cn/img_convert/0e39dc2b94811ede4d77da7ba7acb35d.png"alt="输入图片描述" /> 其均值为<spanclass="math inline">\(u\)</span>，方差为<spanclass="math inline">\(\sigma\)</span>，数据会以99%的概率落在<spanclass="math inline">\(u-3\sigma\)</span>到<spanclass="math inline">\(u+3\sigma\)</span>之中。 #### 三维高斯分布多维高斯的公式如下： <span class="math inline">\(\frac{1}{(2\pi)^{\frac{N}{2}}|\Sigma|}e^{-\frac{1}{2}(x-u)^T\Sigma^{-1}(x-u)}\)</span> 这个三维高斯画出来的图是什么样的呢？我们想像一下固定概率为<spanclass="math inline">\(p\)</span>的三维高斯分布长什么样。 <spanclass="math inline">\(\frac{1}{(2\pi)^{\frac{N}{2}}|\Sigma|}e^{-\frac{1}{2}(x-u)^T\Sigma^{-1}(x-u)}=p\)</span> <span class="math inline">\(-ln(2\pi)^{\frac{N}{2}}|\Sigma|-\frac{1}{2}(x-u)^T\Sigma (x-u)=lnp\)</span><span class="math inline">\((x-u)^T\Sigma (x-u)=-2lnp-2ln(2\pi)^{\frac{N}{2}}|\Sigma=C\)</span> 这里，<spanclass="math inline">\(\Sigma\)</span>是一个实对称矩阵，令： <spanclass="math inline">\(\Sigma=P^T\wedge P\)</span> <spanclass="math inline">\((x-u)^TP^T\wedge P(x-u)=(P(x-u))^T \wedgeP(x-u)=C\)</span> 令: <span class="math inline">\(y=P(x-u)\)</span>, 令<span class="math display">\[\wedge=\begin{bmatrix}\sigma_1^2 &amp; 0 &amp; 0\\0 &amp; \sigma_2^2 &amp; 0 \\0 &amp; 0 &amp; \sigma_3^2\end{bmatrix}\]</span> 原式子变为 <span class="math display">\[y^T \wedge y=\sigma_1^2y_1^2+\sigma_2^2y_2^2+\sigma_3^2y_3^2\]</span>这是一个标准的椭球的方程，所以原式子就是把标准椭球先经过经过一个旋转变换<spanclass="math inline">\(P^{-1}\)</span>，再挪到<spanclass="math inline">\(u\)</span>点得到。所以对于一个三维高斯而言，同一个椭球表面其概率密度相同，离<spanclass="math inline">\(u\)</span>越远，其概率越小。 <imgsrc="https://cdn-lfs.huggingface.co/datasets/huggingface/documentation-images/af041bd0ab2c29f6fd8dc04e12211f080463b9b86ca90f36091f5cb879338015?response-content-disposition=inline;%20filename*=UTF-8%27%27single-gaussian.png;%20filename=%22single-gaussian.png%22;&amp;response-content-type=image/png&amp;Expires=1701927748&amp;Policy=eyJTdGF0ZW1lbnQiOlt7IkNvbmRpdGlvbiI6eyJEYXRlTGVzc1RoYW4iOnsiQVdTOkVwb2NoVGltZSI6MTcwMTkyNzc0OH19LCJSZXNvdXJjZSI6Imh0dHBzOi8vY2RuLWxmcy5odWdnaW5nZmFjZS5jby9kYXRhc2V0cy9odWdnaW5nZmFjZS9kb2N1bWVudGF0aW9uLWltYWdlcy9hZjA0MWJkMGFiMmMyOWY2ZmQ4ZGMwNGUxMjIxMWYwODA0NjNiOWI4NmNhOTBmMzYwOTFmNWNiODc5MzM4MDE1P3Jlc3BvbnNlLWNvbnRlbnQtZGlzcG9zaXRpb249KiZyZXNwb25zZS1jb250ZW50LXR5cGU9KiJ9XX0_&amp;Signature=bd0u6vvomyoJvDXRp8gMuQlZQYKf-h34IuzVOqPd2grvENeF6Iqpj82GP~28cDs-HkRVMjMVfppvXHSVys0GAivVS4lj38IThJAOWc2xMFTUQ8vpBgC9aU8aDtY4IsF5RBQgNOj5dORAOuwWNCRkxSyWYJHOysd5gh0Q2Vf0A6PqAYhfhDx2J9rJMmh3xdKvMH0BPd4UeA8f~o2uRH0smJ9kRzeUllobY7GDlYI4rB1GZKwT3tQHYOoaVEqQUWz5-yRTJBZnYBwgd7IoilIE2FvapQDQph9vI-RoCRlUc7ZlG-8exYTmcgnj6w2tjvNHMPQuMXtPx8xZaH0J7x2-3w__&amp;Key-Pair-Id=KVTP0A1DKRTAX"alt="输入图片描述" /> 所以一个多元高斯轴的长度为<spanclass="math inline">\(\Sigma\)</span>的特征值。跟一维一样，有99%的概率落在3倍方差之内，也就是有99%的概率落在<spanclass="math inline">\(3\sigma_1,3\sigma_2,3\sigma_3\)</span>所在的椭球内，另外<spanclass="math inline">\(\sigma_1,\sigma_2,\sigma_3\)</span>为<spanclass="math inline">\(\Sigma\)</span>的特征值。 ### 图形学渲染-坐标变换<imgsrc="3d%20gaussian%20splatting_md_files/image_20231206202903.png?v=1&amp;type=image&amp;token=V1:0oFwG0rq7cAsSOXZ51cfebeE9BbFg7KRVhMvSX08UJw" />在传统图形学的渲染pipeline里面，需要把空间里面的物体投影到相机的平面，也就是需要知道空间中每个点投影到特定相机平面上的位置是多少，在传统图形学里面的流程通常是这样的：先把视椎内物体进行一个透视投影，压缩到一个非透视的空间内，然后使用正交投影，将视椎内物体压缩到各维度为[-1,1]的空间内。#### 透视投影 <imgsrc="3d%20gaussian%20splatting_md_files/image_20231206203006.png?v=1&amp;type=image&amp;token=V1:szGEi-Ale4_R-7Q6AmLefLtZDW8OqOl6f-YRFMZ5XQA" />设近平面为<span class="math inline">\(n\)</span>，远平面为<spanclass="math inline">\(f\)</span>，这里假设我们相机坐标的位置如下（采用右手坐标系）：空间内任一点<spanclass="math inline">\((x,y,z)\)</span>投影到相机平面的位置为<spanclass="math inline">\((x&#39;,y&#39;,z&#39;)\)</span>，投影矩阵为<spanclass="math inline">\(P\)</span>, 则有： <spanclass="math inline">\(x&#39;=\frac{n}{z}x,y&#39;=\frac{n}{z}y\)</span>换成齐次坐标表示，也就是经过。 <spanclass="math inline">\([x,y,z,1]^T-&gt;[nx,ny,?,z]\)</span> <spanclass="math display">\[P=\begin{bmatrix}n &amp;&amp; 0 &amp;&amp; 0 &amp;&amp; 0\\0 &amp;&amp; n &amp;&amp; 0 &amp;&amp; 0\\? &amp;&amp; ? &amp;&amp; ? &amp;&amp; ?\\0 &amp;&amp; 0 &amp;&amp; 1 &amp;&amp; 0\end{bmatrix}\]</span> 我们还有两个约束条件，在近平面上，所有点的<spanclass="math inline">\(z\)</span>坐标不会变，都为<spanclass="math inline">\(n\)</span>，在远平面上，所有点的<spanclass="math inline">\(z\)</span>坐也不会变： <spanclass="math inline">\([x,y,n,1]-&gt;[nx,ny,n^2,n]\)</span> <spanclass="math inline">\([x,y,f,1]-&gt;[x&#39;,y&#39;,f,1]=[\frac{nx}{f},\frac{ny}{f},f,1]=[nx,ny,f^2,f]\)</span>所以<span class="math inline">\(P\)</span>一定满足如下的形式： <spanclass="math display">\[P=\begin{bmatrix}n &amp;&amp; 0 &amp;&amp; 0 &amp;&amp; 0\\0 &amp;&amp; n &amp;&amp; 0 &amp;&amp; 0\\0 &amp;&amp; 0 &amp;&amp; A &amp;&amp; B\\0 &amp;&amp; 0 &amp;&amp; 1 &amp;&amp; 0\end{bmatrix}\]</span> 其中<span class="math inline">\(An+B=n^2\)</span>,<spanclass="math inline">\(Af+B=f^2\)</span> 解出来为： <spanclass="math inline">\(A=n+f, B=-nf\)</span> 因此，投影距离为： <spanclass="math display">\[P=\begin{bmatrix}n &amp;&amp; 0 &amp;&amp; 0 &amp;&amp; 0\\0 &amp;&amp; n &amp;&amp; 0 &amp;&amp; 0\\0 &amp;&amp; 0 &amp;&amp; n+f &amp;&amp; -nf\\0 &amp;&amp; 0 &amp;&amp; 1 &amp;&amp; 0\end{bmatrix}\]</span> #### 正交投影 <imgsrc="https://pic4.zhimg.com/v2-7a64b65b2506ad3209667df0de4e00ff_r.jpg" />下交投影相对较简单，只需要将非透视空间内的内容挪到坐标原点，并规范化到[-1,1]的空间内，设x坐标的范围为[l,r]，y坐标为[b,t]，z坐标为[n,f],我们可以先把坐标得到了零点，再做各个维度的压缩，从坐标到零点的变换矩阵为：<span class="math display">\[T_1=\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; -\frac{l+r}{2}\\0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2}\\0 &amp; 0 &amp; 1 &amp; -\frac{n+f}{2}\\0 &amp; 0 &amp; 0 &amp; 1\\\end{bmatrix}\]</span> 缩放矩阵如下： <span class="math display">\[T_2=\begin{bmatrix}\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0\\0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0\\0 &amp; 0 &amp; \frac{2}{n-f} &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\\\end{bmatrix}\]</span> 最后的矩阵就是两个矩阵乘起来： <span class="math display">\[T=T_2T_1=\begin{bmatrix}\frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\frac{r+l}{r-l}\\0 &amp; \frac{2}{t-b} &amp; 0 &amp; -\frac{t+b}{t-b}\\0 &amp; 0 &amp; \frac{2}{n-f} &amp; -\frac{n+f}{n-f}\\0 &amp; 0 &amp; 0 &amp; 1\\\end{bmatrix}\]</span> 综合一下，将一个坐标先经过矩阵<spanclass="math inline">\(P\)</span>, 再过<spanclass="math inline">\(T\)</span>的变换就可以变到NDC坐标系。 ###基于点的渲染这块不大熟，根据论文做个粗浅的理解，图形学里面有时候会对一些离散的点数据进行渲染（点云），因为点是没有体积的，所以我们可以有一个固定的几何表示（球，立方体）来对这个点进行表示，以球为例，投影到相机面上变会成一个圆，然后着色时，如果一个像素点上，有几个点都投影过来了，这时候使用<spanclass="math inline">\(\alpha\)</span> blending. <spanclass="math inline">\(C=\sum_{i=N}c_i \alpha_i\prod_{j=1}^{i-1}(1-\alpha_j)\)</span>这个公式其实跟神经辐射场推出来的离散公式也非常的像。 ## GaussianSplatting回想一下传统神经辐射场，我们将三维空间里连续数据存下来，然后使用体渲染公式，得到某一个像素点的颜色，由于空间中物体的通常是稀疏的，MLP里存放的三维体数据很多其实都存在浪费，另外raymatching的方法使得渲染速度变得相当地慢。像InstantNGP采用了hash表的方式，来减少无效数据的存放，Plenoctrees采用了八叉树来减少数据存放，但这些方法并没有改进raymarching。而且像InstantNGP因为人为缩小了存放的空间，所以实际是一种渲染质量对时间的妥协。所以，如果我们能够设计一种算法，能够自适应的学习三维空间里面物体的分布，同时可以减去raymarching这一繁琐的采样步骤，那理论上来说，就可以一定程度上解决现在nerf的问题。我们把Nerf的场景想像成一个非常非常密集的点，我们需要存储的点的信息，其实只会是那些在物体表面上的，因此我们能不能只存那些有物体地方的点呢，让神经网络去学习这些点的坐标与颜色，透明度等等，然后用基于点的渲染方式进行渲染，将渲染后的图片与图片计算损失函数，最后得到这些点的坐标，颜色与透明度。### 如何对点进行初始化 #### 随机初始化 #### sfm <imgsrc="3d%20gaussian%20splatting_md_files/image_20231206204307.png?v=1&amp;type=image&amp;token=V1:PRGBZH10idigKMUcwIwufxfLk1Wk6j7cHjBR32BImoA" />### 点体积的扩展 跟particle-basedrendering一样，因为点没有体积，所以需要对它进行一个扩展，扩展方式这篇论文与传统的particle-basedrendering不一样，它用的3D Gaussian表示。 <spanclass="math inline">\(G(x)=e^{-\frac{1}{2}x^T\Sigma^{-1}x}\)</span> <imgsrc="https://cdn-lfs.huggingface.co/datasets/huggingface/documentation-images/97360330c98cb8306438dbb070518a0d2bf6f373637b208a4d16b30baaec5856?response-content-disposition=inline%3B+filename*%3DUTF-8%27%27three-gaussians.png%3B+filename%3D%22three-gaussians.png%22%3B&amp;response-content-type=image%2Fpng&amp;Expires=1702125425&amp;Policy=eyJTdGF0ZW1lbnQiOlt7IkNvbmRpdGlvbiI6eyJEYXRlTGVzc1RoYW4iOnsiQVdTOkVwb2NoVGltZSI6MTcwMjEyNTQyNX19LCJSZXNvdXJjZSI6Imh0dHBzOi8vY2RuLWxmcy5odWdnaW5nZmFjZS5jby9kYXRhc2V0cy9odWdnaW5nZmFjZS9kb2N1bWVudGF0aW9uLWltYWdlcy85NzM2MDMzMGM5OGNiODMwNjQzOGRiYjA3MDUxOGEwZDJiZjZmMzczNjM3YjIwOGE0ZDE2YjMwYmFhZWM1ODU2P3Jlc3BvbnNlLWNvbnRlbnQtZGlzcG9zaXRpb249KiZyZXNwb25zZS1jb250ZW50LXR5cGU9KiJ9XX0_&amp;Signature=EhwMu9HDyrHVmOuwEM-VGahvo%7EemdTnVWjBCXbqNbjTTTJJia7Gg2VxDOOlUOu5Zg5K7zOlhUMG3719KCYLd4ZLo5Y2RRy52W85ttFtzlA-5g8ZtklpbgCeClLAf2InR8LyCRpcqSXub0EObBF5Xkh50Lfep9fIXYcNBRlY17uZcoqObKjy17hjW77EcoBere1Z2YGGrQgH2OqxGNkBou4Qh5Oz0MlXLxGu-6dvD-l3LuIEz9tFxU5AxCqH3t%7E0zWf9RDdxnoYckNq1ZupYChnwDZZdiIJUNhRK2wd5ZCV%7E%7ELVkVqYZgKhv0mkQI4NfqH6sBzIxN731lMpKhWmcJ5g__&amp;Key-Pair-Id=KVTP0A1DKRTAX" />这跟前面3DGaussian里的表示是一样的，只是省去了前面的常数项。跟前面那这球或者方形的表示不同，3DGaussian这种表示具有更强的灵活性，它可以用较少的点表示更复杂的形状。在这种表示下面，我们希望存储的信息就变成了： 1. 每个点的坐标； 2.每个点的高斯表示中的<span class="math inline">\(\Sigma\)</span>; 3.每个点的颜色； 4. 每个点的不透明度<spanclass="math inline">\(\alpha\)</span>； 这里的<spanclass="math inline">\(\Sigma\)</span>（协方差矩阵）是一个半正定矩阵，所以你当然不能对这个随机对这个距离进行初始化，然后随机迭代，因为要保证半正定这个条件，我们假定：<span class="math inline">\(\Sigma=P \wedge P^T=P\wedge^{\frac{1}{2}}\wedge^{\frac{1}{2}}P^T=(P \wedge^{\frac{1}{2}})(P\wedge^{\frac{1}{2}})^T\)</span>. 其中，<spanclass="math inline">\(P\)</span>是一个正交阵，可以理解为是一个旋转矩阵，<spanclass="math inline">\(\wedge^{\frac{1}{2}}\)</span>为一个全为正数的对角阵，可以理解为是一个scale矩阵，论文里的表示为：<span class="math inline">\(\Sigma=RSS^TR^T\)</span> ### 点的颜色的表示我们在Nerf里面为了去模拟一些高光的点，会入view dir，也不是不同view dir,其看过来颜色是不一样的，之前都用神经网络来存这一信息.那我们现在存的话怎么存，使用球谐函数，这其实是很多nerf都采用的存储方式。### 如何投影那怎么知道空间里面一个高斯投影到某个相机平面上，在相机平面上的什么位置呢？这里采用了跟之前NDC坐标有点类似的方法，使用“挤压”的方式，相机坐标<spanclass="math inline">\((t_1,t_2,t_3)\)</span>压缩到<spanclass="math inline">\((x_1,x_2,x_3)\)</span>上。 <spanclass="math display">\[x_1=\frac{t_1}{t_3}\\x_2=\frac{t_2}{t_3}\\x_3=\sqrt{t_1^2+t_2^2+t_3^2}\]</span> 这里<spanclass="math inline">\(x_3\)</span>设计成是因为在基于点的着色时，需要考虑一个射线出去的点的前后顺序，所以需要对相应位置进行保留。但是比较遗憾的是，这并不是一个线性变换，也就是无法通过求解一个变换矩阵把这个变换求解出来。但是我们可以使用一个线性变换对这个非线性变换进行近似。我们已经在高数中学过泰勒展开式：<span class="math inline">\(f(x) \approxf(x_0)+f&#39;(x_0)(x-x_0)\)</span> 这里的情况其实当函数为<spanclass="math inline">\(R-&gt;R\)</span>的情况，如果把这个扩展到高维呢<spanclass="math inline">\(R^m-&gt;R^n\)</span>。 <spanclass="math inline">\(f(\bold x)=f(\bold x_0)+\bold J (\bold x-\boldx_0)\)</span> 这里<spanclass="math inline">\(J\)</span>雅可比矩阵，可以看来一阶导的多维形式，假设我们输入为:<spanclass="math inline">\(x_1,x_2,...x_m\)</span>,输出为<spanclass="math inline">\(y_1,y_2,...,y_n\)</span> <spanclass="math display">\[J=\begin{bmatrix}\frac{\partial y_1}{x_1}&amp;&amp;\frac{\partialy_1}{x_2}&amp;&amp;...&amp;&amp;\frac{\partial y_1}{x_m}\\\frac{\partial y_2}{x_1}&amp;&amp;\frac{\partialy_2}{x_2}&amp;&amp;...&amp;&amp;\frac{\partial y_2}{x_m}\\...\\\frac{\partial y_n}{x_1}&amp;&amp;\frac{\partialy_n}{x_2}&amp;&amp;...&amp;&amp;\frac{\partial y_n}{x_m}\end{bmatrix}\]</span> 前面的非线性变换，使用这种方式进行近似的话，其雅可比矩阵为：<span class="math display">\[\begin{bmatrix}\frac{1}{t_3} &amp;&amp; 0 &amp;&amp; -\frac{t_1}{t_3^2}\\0 &amp;&amp; \frac{1}{t_3} &amp;&amp; -\frac{t_2}{t_3^2}\\\frac{t_1}{\sqrt{t_1^2+t_2^2+t_3^2}} &amp;&amp;\frac{t_2}{\sqrt{t_1^2+t_2^2+t_3^2}} &amp;&amp;\frac{t_3}{\sqrt{t_1^2+t_2^2+t_3^2}}\end{bmatrix}\]</span>我们可以对每个高斯在其中心点展开，得到其雅可比矩阵，就可以得到这个高斯的线性变换矩阵。因为高斯分布的性质，如果一个线性变换<spanclass="math inline">\(Ax+b\)</span>，高斯分布经过这个变换之后： <spanclass="math display">\[u&#39;=Au+b\]</span> <span class="math display">\[\Sigma&#39;=A \Sigma A^T\]</span> 所以一个世界坐标系下均值点为<spanclass="math inline">\([t_1,t_2,t_3]\)</span>，方差为<spanclass="math inline">\(\Sigma\)</span>的高斯经过这个变换后，会变为均值为<spanclass="math inline">\([x_1,x_2,x_3]\)</span>，方差为<spanclass="math inline">\(\Sigma&#39;=JW \SigmaW^TJ^T\)</span>，其中这里<spanclass="math inline">\(W\)</span>为世界坐标到相机坐标的转换。经过这个变换之后，我们只要丢掉<spanclass="math inline">\(\Sigma&#39;\)</span>的第三行的第三列就是投影到相机平面的协方差矩阵。### 像素点着色要计算像素点的着色，首先需要知道哪些高斯投影到这个像素点上，我们通过之前的计算已经知道空间里的一个高斯投影到相机平面上是一个什么新的高斯，通过前面对高斯的计算，我们也知道有99%的概率会落在<spanclass="math inline">\(3\sigma_1,3\sigma_2\)</span>之内，所以如果一个像素落在高斯的区间内，那我们认为这个像素被高斯所覆盖，为了简化计算，我们将范围扩大为<spanclass="math inline">\((max(3\sigma_1,3\sigma_2),max(3\sigma_1,3\sigma_2))\)</span>。到这里其实我们已经知道一个像素被哪些高斯覆盖了，论文里在这一步使用了一些加速的技巧。首先可以通过之前的计算，得到每个高斯覆盖的范围，对整个空间内的高斯进行排序。将空间分为一个一个tile，可以得到覆盖这个tile的高斯。对一个tile里的每个像素，计算tile中每个高斯对它的贡献度以及其透明度：<span class="math display">\[p_i\alpha_i \prod_{j=1}^{i-1}(1-p_i\alpha_j)\]</span> 这里: <span class="math display">\[p_i=e^{-\frac{1}{2}x^T\Sigma&#39;^{-1}x}\]</span>这里tile和像素点颜色的计算使用了cuda进行编写，使用了并行计算，这是Gaussian得以提高的原因。 ### Adaptive Control <imgsrc="3d%20gaussian%20splatting_md_files/image_20231206204535.png?v=1&amp;type=image&amp;token=V1:Tw9U09gs84XuJoRIcoi_mxn2beCoEVq6kJS4qZNvWfE" />因为3DGaussian的方法是对多个高斯进行优化，高斯的数量的设定当然很重要，如果是一个很简单的场景，少量高斯的数量应该就可以，但是如果是一个很复杂的场景，高斯的数量就需要增加，一个比较好的方法就是我们可以自适应来生成高斯的数量，因此，论文里有提到一个adaptivecontrol的方法。 每隔一定的训练时间(100 iter or 100iter)。会根据目前的情况决定哪些高斯应该被去除，哪些部分应该增加高斯表示。1. 哪些需要去掉？ 透明度非常低的（<spanclass="math inline">\(\alpha\)</span>低于某个阈值的），离相机距离非常近的（很可能是floater）。2. 其它另外对于一些表示过多或者不够的地方，也需要进行自适应调整，怎么算表示过多或者不够呢？这些地方通常是坐标梯度较大的地方，梯度较大，表示这里高斯表示其实不太合适，模型试图移动这些点，改善模型的表示，所以可以设置一个梯度的阈值，找到这些表示不好的地方。### 训练&amp;损失函数 <imgsrc="3d%20gaussian%20splatting_md_files/image_20231206204650.png?v=1&amp;type=image&amp;token=V1:dp6qOwfbi5hqIpuOxCFEnNGS-F_sUYFbe7MNptOlex0" /><span class="math inline">\(L=(1-\lambda)L_1+\lambdaL_{D-SSIM}\)</span></p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>Computer Vision</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>3D Vision</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Diffusion相关前置知识</title>
    <link href="/%E6%89%80%E6%9C%89/Diffusion%E7%9B%B8%E5%85%B3%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"/>
    <url>/%E6%89%80%E6%9C%89/Diffusion%E7%9B%B8%E5%85%B3%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h3 id="diffusion相关前置知识">Diffusion相关前置知识</h3><h4id="最大似然估计maximum-likelihood-estimation---mle">最大似然估计(MaximumLikelihood Estimation - MLE)</h4><p>对于拟合数据分布这件事，最常见的做法就是最大化此然估计：即真实数据分布里采样出来的数据要能够在你建模的数据分布里概率最大化。最大似然估计是一种统计方法，用来估计一个概率模型中的参数，使得该模型能够最大化观测数据出现的概率。<span class="math display">\[E_{X\sim{p_{data}(x)}}[logp_\theta(X)]\]</span> 公式中的<spanclass="math inline">\(X\)</span>取自真实分布，目标是使得<spanclass="math inline">\(X\)</span>在<spanclass="math inline">\(p_\theta\)</span>中概率最大。</p><h4 id="能量模型">能量模型</h4><p>首先，在一个复杂的系统里 若想要表示一个变量<spanclass="math inline">\(x\in{X}\)</span>的概率<spanclass="math inline">\(P(x)\)</span>，需要满足以下性质：</p><ul><li><span class="math inline">\(P(x)&gt;0\)</span></li><li>所有变量概率之和为1</li><li>方便计算</li></ul><p>很容易会想到使用指数函数(天然满足大于0)</p><p>所以<span class="math inline">\(P(x)\)</span>可以表示为： <spanclass="math display">\[P(x) = \frac {1}{Z}e^{f(x)}\]</span> <span class="math inline">\(f(x)\)</span>是关于<spanclass="math inline">\(x\)</span>的函数，其中<spanclass="math inline">\(Z\)</span>是正则(normalize)项 <spanclass="math display">\[Z = \textstyle\sum_{x\in{X}}e^{f(x)}\]</span> 所以 <span class="math display">\[P(x) = \frac{e^{f(x)}}{\sum_{x\in{X}}e^{f(x)}}\]</span> 这和softmax函数有些类似</p><p>统计物理中玻尔兹曼分布有着差不多的形式： <spanclass="math display">\[P(x) = \frac{e^{-E(x)}}{\sum_{x\in{X}}e^{-E(x)}}\]</span> 这里的<spanclass="math inline">\(E\)</span>表示状态的能量，之前的<spanclass="math inline">\(f(x)\)</span>就可以写成<spanclass="math inline">\(f(x) = -E(x)\)</span></p><p>所以这样的建模方法就叫做能量模型。通常在机器学习中E(x)可以表示为似然函数或者对数似然函数或者值函数，所以有时候求最大似然就可以被表示为求最小能量值。</p><p>比如在分类问题中，对于特征<span class="math inline">\(X = \{x_1, x_2,..., x_n\}\)</span>和标签<span class="math inline">\(y \inY\)</span>，我们可以建立能量函数<span class="math inline">\(E(x,y)\)</span>，这时候能量函数代表<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>的匹配程度，能量越低匹配程度越好。</p><p>所以，<span class="math inline">\(y^* =argmin_{y\in{Y}}E(X,y)\)</span></p><p>注意这时候最小化这个能量函数是用来推断结果的，区别于最小化损失函数可以用来训练能量函数<spanclass="math inline">\(E\)</span>。</p><h3 id="流型">流型</h3><p>以下定性的解释来自参考：https://www.zhihu.com/question/24015486/answer/194284643</p><p>流形学习的观点是认为，我们所能观察到的数据实际上是由一个低维流型映射到高维空间上的。由于数据内部特征的限制，一些高维中的数据会产生维度上的冗余，实际上只需要比较低的维度就能唯一地表示。</p><p>高维数据其实是由低维流型生成的，如果我们能够模拟这个生成过程，再通过对低维流型的微调，应该能得到对应的“有意义且有道理”的高维数据。</p><p>我们可以把生成过程看作：输入一个特征空间的低维编码，得到一个输出空间的高维图像。如何证明我们学习到的这个生成过程就是像人脑一样从低维流形映射到高维空间呢？还记得我们之前说过，流型空间一般应该是连续的，而映射到的高维空间的数据也应该在流形连续调整时变得连续且有意义。</p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>Computer Vision</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Diffusion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计原则</title>
    <link href="/%E6%89%80%E6%9C%89/Design%20Pattern/"/>
    <url>/%E6%89%80%E6%9C%89/Design%20Pattern/</url>
    
    <content type="html"><![CDATA[<h2 id="设计原则">设计原则</h2><p><strong>常用的七大原则：</strong></p><ol type="1"><li><p><strong>单一职责原则（Single Responsibility）</strong></p><p>对于类来说，即一个类应该只负责一项职责。否则因其中一个职责需要变更而导致类修改，可能会导致冷一个职责执行出错。</p><p><strong>注意事项和细节</strong></p><ul><li>降低类的复杂度，一个类只负责一项职责</li><li>提高类的可读性，可维护性</li><li>降低变更引起的风险</li><li>通常情况下，应该遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则，只有类中的方法足够少，可以在方法级别保持单一职责原则。</li></ul></li><li><p><strong>接口隔离原则（Interface Segregation）</strong></p><p>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</p><figure><imgsrc="E:\华为云盘\Typora\Design%20Pattern.assets\image-20230117103042144.png"alt="image-20230117103042144" /><figcaption aria-hidden="true">image-20230117103042144</figcaption></figure></li><li><p><strong>依赖倒转原则（Dependence Inversion）</strong></p><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象；依赖倒转原则的中心思想是面向接口编程；设计理念：相对于细节的多边性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多，在java中，抽象指的是接口或抽象类，细节就是具体的实现类。；使用接口或抽象类的目的是制定好规范，而不涉及具体的操作，把展现细节的任务交给他们的实现类去完成。</p><p>依赖关系传递的三种方式和应用案例：</p><ul><li>接口传递</li><li>构造方法传递</li><li>setter方式传递</li></ul><p>注意：低层模块尽量都要有抽象类或接口，或者两者都有；变量的申明尽量是抽象类或接口，利于程序扩展和优化。继承时遵循里氏替换原则。</p></li><li><p><strong>里氏替换原则（Liskov Substitution）</strong></p><p>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序p的行为没有发生变化，那么类型T2是类型T1的子类型，换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</p><p>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。</p><p>解决冲突的办法：通用的做法是，原来的父类和子类都继承一个更通俗的基类原有的继承关系去掉，采用依赖，聚合，组合等关系代替。</p></li><li><p><strong>开闭原则 | ocp原则（Open Closed）</strong></p><p>一个软件实体如类，模块和函数应该对扩展开放，对修改关闭，用抽象构建框架，用实现扩展细节，当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p></li><li><p><strong>迪米特法则</strong></p><p>一个对象应该对其他对象保持最少的了解</p><p>类与对象关系越密切，耦合度越大，迪米特法则又叫最少知道原则，即一个对象对自己依赖的类知道的越少越好，也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部，对外除了提供public方法，不对外泄露任何信息。迪米特法则还有个更简单的定义：只与直接的朋友通信。</p><p>直接朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系，耦合的方式很多，依赖，关联，组合，聚合等，其中，我们称出现成员变量，方法参数，方法返回值中的类为直接朋友，而出现在局部变量中的类不是直接的朋友，也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p><p>解决办法：将方法封装到自己的类，不要把具体的实现写到别人的类中。</p><p>注意事项：迪米特法则的核心是降低类之间的耦合，但是注意，由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完全没有依赖关系。</p></li><li><p><strong>合成复用原则</strong></p><p>尽量使用合成/聚合的方式，而不是使用继承</p><p>设计原则核心思想：</p><ul><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起</li><li>针对接口编程，而不是针对实现编程</li><li>为了交互对象之间的松耦合设计而努力</li></ul></li></ol><h2 id="umlunified-modeling-language">UML（Unified modelinglanguage）</h2><p>分类：</p><ol type="1"><li>用例图</li><li>静态结构图：类图、对象图、包图、组件图、部署图</li><li>动态行为图：交互图、状态图、活动图</li></ol><p>类图是描述类与类之间的关系的，是UML图中最核心的。</p><p>类之间的关系：依赖、泛化（继承）、实现、关联、聚合和组合</p><p>依赖：在类中用到了对方，包括类的成员属性、方法的返回类型、方法接受的参数类型、方法中使用到</p><p>聚合和组合都是整体与部分的关系，但是聚合整体和部分可以分开，而组合不能（在属性中new、级联删除）</p><h2 id="设计模式分为三类共23种">设计模式（分为三类，共23种）</h2><p>创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式</p><p>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式</p><p>行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式</p><h3 id="单例模式">单例模式</h3><blockquote><p>所谓类的单例模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。</p></blockquote><p>单例模式有八种方式：</p><ol type="1"><li><p>饿汉式（静态常量）</p><p>步骤如下：</p><ol type="1"><li>构造器私有化（防止外部通过new创建实例）</li><li>类的内部创建对象</li><li>向外暴露一个静态的公共方法，getInstance()</li></ol><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <span class="hljs-comment">// 1.构造器私有化，防止外部通过new创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br>    <span class="hljs-comment">// 2.本类内部创建对象实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <br>    <span class="hljs-comment">// 3.向外暴露一个静态的公共方法</span><br>    <span class="hljs-keyword">public</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-type">Singleton</span> <span class="hljs-variable">instance1</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br><span class="hljs-type">Singleton</span> <span class="hljs-variable">instance2</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br><span class="hljs-comment">// instance1 = instance2 (true, hashcode也相同)</span><br></code></pre></td></tr></table></figure><p>分析：写法简单，在类装载的时候就完成了实例化，避免了线程同步问题，但由于在类加载的时候就完成实例化，没有达到LazyLoading的效果，如果从始至终从未使用过这个实例，则会造成内存的浪费。此方式基于classloader机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类加载的原因有很多种(会导致没有使用getInstance，但是instance被创建了)，因此不能确定有其他的方式（或者其他的静态方法）导致类加载，这时候初始化instance就没有达到lazyloading的效果</p><p>结论：这种单例模式可用，可能造成内存浪费。</p></li><li><p>饿汉式（静态代码块）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <span class="hljs-comment">// 1.构造器私有化，防止外部通过new创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br>    <span class="hljs-comment">// 2.本类内部创建对象实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <br>    <span class="hljs-keyword">static</span> &#123;<span class="hljs-comment">// 在静态代码块中，创建单例对象</span><br>    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 3.向外暴露一个静态的公共方法</span><br>    <span class="hljs-keyword">public</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-type">Singleton</span> <span class="hljs-variable">instance1</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br><span class="hljs-type">Singleton</span> <span class="hljs-variable">instance2</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br><span class="hljs-comment">// instance1 = instance2 (true, hashcode也相同)</span><br></code></pre></td></tr></table></figure><p>分析：和上面的方式类似，只是将类实例化的过程放在了静态代码块中，也是在类加载的时候，就执行静态代码块中的代码，初始化类的实例，优缺点同上。</p><p>结论：这种单例模式可用，但是可能造成内存浪费</p></li><li><p>懒汉式（线程不安全）</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs smali">class Singleton &#123;<br><span class="hljs-keyword">private</span><span class="hljs-keyword"> static</span> Singleton instance;<br><br><span class="hljs-keyword">private</span> Singleton() &#123;<br><br>&#125;<br><br>// 提供一个静态的公共方法，当使用到该方法时，才去创建instance<br>// 即懒汉式，线程不安全<br><span class="hljs-keyword">public</span><span class="hljs-keyword"> static</span> Singleton getInstance() &#123;<br><span class="hljs-built_in">if </span>(instance == null) &#123;<br>           <span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>Singleton();<br>           <span class="hljs-built_in"> return </span>instance;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>起到了懒加载的效果，但是只能在单线程下使用</li><li>如果在多线程下，一个线程进入了if判断语句，还未来得及往下执行，另一个线程也通过了这个判断语句，这是便会产生多个实例，所以在多线程环境下不可使用这种方式</li></ol><p>结论：在实际开发中，不要使用这种方式</p></li><li><p>懒汉式（线程安全，同步方法），添加synchronized关键字</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs smali">class Singleton &#123;<br><span class="hljs-keyword">private</span><span class="hljs-keyword"> static</span> Singleton instance;<br><br><span class="hljs-keyword">private</span> Singleton() &#123;<br><br>&#125;<br><br>// 提供一个静态的公共方法，加入了同步处理的代码，解决线程安全问题<br>// 即懒汉式，线程不安全<br><span class="hljs-keyword">public</span><span class="hljs-keyword"> static</span> synchronized Singleton getInstance() &#123;<br><span class="hljs-built_in">if </span>(instance == null) &#123;<br>           <span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>Singleton();<br>           <span class="hljs-built_in"> return </span>instance;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决了线程不安全问题，但是效率太低了，每个线程在想获得类的时候，执行getInstance方法都要进行同步，而其实这个方法只执行一次实例化代码就够了，后面的想要获得该类实例，直接return就行了，方法进行同步效率太低了。</p><p>结论：在实际开发中，不要使用这种方式</p></li><li><p>懒汉式（线程安全，同步代码块）</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs smali">class Singleton &#123;<br><span class="hljs-keyword">private</span><span class="hljs-keyword"> static</span> Singleton instance;<br><br><span class="hljs-keyword">private</span> Singleton() &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span><span class="hljs-keyword"> static</span> Singleton getInstance() &#123;<br><span class="hljs-built_in">if </span>(instance == null) &#123;<br>synchronized (Singleton.class) &#123;<br><span class="hljs-built_in">instance </span>=<span class="hljs-built_in"> new </span>Singleton();<br>&#125;<br>&#125;<br><span class="hljs-built_in">return </span>instance();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法并不能起到线程同步的作用，加入一个线程进入了if判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例，</p><p>结论：在实际开发中，不能使用这种方式</p></li><li><p>双重检查（推荐使用，可以解决线程安全问题、效率和懒加载的问题）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton;<span class="hljs-comment">// 使得共享的变量一旦被修改就会被刷新到主存中</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 提供一个静态的公共方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题，同时保证了效率</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton  == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">// 第一次判断</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<span class="hljs-comment">// 保证只有一个线程在执行</span><br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">// 第二次检查</span><br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;)<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>双重检查概念是多线程开发中常使用到的，我们进行了两次if(singleton =null)检查，这样就可以保证线程安全了，这样，实例化代码只用执行一次，后面再次访问时，判断if(singleton==null)直接return实例化对象，也避免反复进行方法同步，线程安全、延迟加载、效率较高</p><p>结论：在实际开发中，推荐使用这种单例设计模式</p></li><li><p>静态内部类，推荐使用</p><p>特点：</p><ol type="1"><li>外部的类被装载时，静态内部类并不会立即被装载</li><li>静态内部类只会装载一次，装载时线程是安全的</li></ol><p>懒加载+线程安全</p><ol type="1"><li>SingletonInstance在Singleton进行装载时并不会被装载，可以实现懒加载的效果</li><li>在通过getInstance获得静态内部类中的静态属性时，才会导致SingletonInstance被加载</li><li>JVM在装载类的时候时线程安全的，这里使用了JVM底层提供的机制，保证初始化时线程安全</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 静态内部类完成</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> staic <span class="hljs-keyword">volatile</span> Singleton instance;<br>    <br>    <span class="hljs-comment">// 构造器私有化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <br>    <span class="hljs-comment">// 静态内部类，该类中有一个类型为Singleton的静态属性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonInstance</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-comment">// 提供一个静态的共有方法，直接返回SingletonInstance.INSTANCE</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingtonInstance.INSTANCE;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>特点：</p><ol type="1"><li>采用了类加载的机制保证初始化实例时只有一个线程</li><li>静态内部类方式在Singleton类被加载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会加载SingletonInstance类，从而完成Singleton的实例化</li><li>类的静态属性只会在第一次加载类的时候初始化，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</li></ol><p>总结：保证线程安全，利用静态内部类特点实现懒加载，效率高---&gt;推荐使用</p></li><li><p>枚举</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用枚举，可以实现单例</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Sington</span> &#123;<br>INSTANCE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayOK</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;ok&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>特点：</p><ol type="1"><li>借助JDK1.5中添加的枚举类型来实现单例模式，不仅可以避免多线程同步问题，而且还能防止反序列化重新创建新的对象</li><li>此方法为Effective Java作者John bloch所提倡</li></ol><p>结论：推荐使用</p></li></ol><p>总结：枚举、静态内部类、双重检查、饿汉式（内存浪费）</p><p>实际应用：Java中的Runtime</p><p>单例模式注意事项和细节说明</p><ol type="1"><li>单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</li><li>当想要实例化一个单例类时，必须要记住使用相应的获取对象的方法，而不是使用new</li><li>单例模式使用的场景：需要频繁的进行创建和销毁的对象，创建对象时耗时过多或耗费资源过多（即：重量级对象)，但又经常使用到的对象、工具类对象，频繁访问数据库或文件的对象（比如数据源、session工厂等）</li></ol><h3 id="工厂模式">工厂模式</h3><figure><imgsrc="E:\华为云盘\Typora\Design%20Pattern.assets\image-20230125090854491.png"alt="image-20230125090854491" /><figcaption aria-hidden="true">image-20230125090854491</figcaption></figure><figure><imgsrc="E:\华为云盘\Typora\Design%20Pattern.assets\image-20230125091220018.png"alt="image-20230125091220018" /><figcaption aria-hidden="true">image-20230125091220018</figcaption></figure><p>改进思路：修改代码可以接受，但是如果我们在其他地方也有创建Pizza的代码，就意味着，也需要修改，而创建Pizza的代码，往往有多处。</p><p>思路：把创建Pizza对象封装发到一个类中，这样我们有新的Pizza种类时，只需要修改该类就可，其它有创建到Pizza对象的代码就不需要修改了-&gt;简单工厂模式</p><h4 id="简单工厂模式">简单工厂模式</h4><p>介绍：</p><ol type="1"><li>简单工厂模式时属于创建型模式，是工厂模式的一种，简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单使用的模式</li><li>简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为</li><li>在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。</li></ol><figure><imgsrc="E:\华为云盘\Typora\Design%20Pattern.assets\image-20230125095025464.png"alt="image-20230125095025464" /><figcaption aria-hidden="true">image-20230125095025464</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleFactory</span> &#123;<br>    <span class="hljs-comment">// 根据orderType返回对应的Pizza对象</span><br>    <span class="hljs-keyword">public</span> Pizza <span class="hljs-title function_">createPizza</span><span class="hljs-params">(String orderType)</span> &#123;<br>        <span class="hljs-comment">// 使用简单工厂模式</span><br>        <span class="hljs-type">Pizza</span> <span class="hljs-variable">pizza</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        pizza.setName(orderType);<br>        <span class="hljs-keyword">if</span> (orderType.equals(<span class="hljs-string">&quot;greek&quot;</span>)) &#123;<br>            ...<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> () &#123;<br>            ...<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> () &#123;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderPizza</span> &#123;<br>    <span class="hljs-comment">// 定义一个简单工厂对象</span><br>    SimpleFactory simpleFactory;<br>    <span class="hljs-type">Pizza</span> <span class="hljs-variable">pizza</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderPizza</span><span class="hljs-params">(SimpleFactory simpleFactory)</span> &#123;<br>        setFactory(simpleFactory);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFactory</span><span class="hljs-params">(SimpleFactory simpleFactory)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">orderType</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">// 用户输入的</span><br>        <span class="hljs-built_in">this</span>.simpleFactory = simpleFactoryj;<span class="hljs-comment">//设置简单工厂对象</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            orderType = getType();<br>            pizza = <span class="hljs-built_in">this</span>.simpleFactory.createPizza(orderType);<br><br>            <span class="hljs-keyword">if</span>(pizza != <span class="hljs-literal">null</span>) &#123;<br>                pizza.prepare();<br>                ...<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 失败</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderPizza</span> &#123;<br>        <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> &#123;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PizzaStore</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用简单工厂模式</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderPizza</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleFactory</span>());<br>        <span class="hljs-comment">// 退出程序</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态工厂模式可以将SimpleFactory中的create设置为static</p><h4 id="工厂方法模式">工厂方法模式</h4><p>定义了一个创建对象的抽象方法，由子类决定要实例化的类，工厂方法模式将对象的实例化推迟到子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderPizza</span> &#123;<br>    <span class="hljs-keyword">abstract</span> Pizza <span class="hljs-title function_">createPizza</span><span class="hljs-params">(String orderType)</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderPizza</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Pizza</span> <span class="hljs-variable">pizza</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        String orderType;<br>        <span class="hljs-keyword">do</span> &#123;<br>            orderType = getType();<br>            pizza = createPizza(orderType);<span class="hljs-comment">// 抽象方法，由工厂子类完成</span><br>            pizza.prepare();<br>            ...<br>            <br>        &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>        <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BJOrderPizza</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Orderpizza</span> P &#123;<br>    <span class="hljs-type">Pizza</span> <span class="hljs-variable">pizza</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (orderType.equals(<span class="hljs-string">&quot;chees&quot;</span>)) &#123;<br>        pizza = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BJCheesePizza</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> &#123;<br>        ...<br>    &#125;<br>    <span class="hljs-keyword">return</span> pizza<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PizzaStore</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">BJOrderPizza</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="抽象工厂模式">抽象工厂模式</h4><p>定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类</p><p>将工厂抽象成两层，AbsFactory抽象工厂和具体实现的工厂子类</p><figure><imgsrc="E:\华为云盘\Typora\Design%20Pattern.assets\image-20230125211116191.png"alt="image-20230125211116191" /><figcaption aria-hidden="true">image-20230125211116191</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个抽象工厂模式的抽象层（接口）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AbsFactory</span> &#123;<br>    <span class="hljs-comment">// 让下面的工厂子类来具体实现</span><br>    <span class="hljs-keyword">public</span> Pizza <span class="hljs-title function_">createPizza</span><span class="hljs-params">(String orderType)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BJFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AbsFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Pizza <span class="hljs-title function_">createPizza</span><span class="hljs-params">(String orderType)</span> &#123;<br>        <span class="hljs-type">Pizza</span> <span class="hljs-variable">pizza</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (orderType.equals(<span class="hljs-string">&quot;cheese&quot;</span>)) &#123;<br>            pizza = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BJCheesePizza</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> () &#123;<br>            ...<br>        &#125;<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LDFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AbsFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Pizza <span class="hljs-title function_">createPizza</span><span class="hljs-params">(String orderType)</span> &#123;<br>        <span class="hljs-type">Pizza</span> <span class="hljs-variable">pizza</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (orderType.equals(<span class="hljs-string">&quot;cheese&quot;</span>)) &#123;<br>            pizza = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LDCheesePizza</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> () &#123;<br>            ...<br>        &#125;<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderPizza</span> &#123;<br>    AbsFactory absfactory;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderType</span><span class="hljs-params">(AbsFactory )</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFactory</span><span class="hljs-params">(AbsFactory factory)</span> &#123;<br>        <span class="hljs-type">Pizza</span> <span class="hljs-variable">pizza</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">orderType</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-built_in">this</span>.factory = factory;<br>        <span class="hljs-keyword">do</span> &#123;<br>            orderType = getType();<br>            pizza = factory.createPizza(orderType);<br>            ...<br>        &#125; <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>三种工厂模式：简单工厂模式、工厂方法模式、抽象工厂模式</p><p>设计模式的依赖抽象原则</p><h3 id="原型模式">原型模式</h3><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。</p><p>原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节</p><p>原理：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sheep</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>...<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            sheep = (Sheep)<span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(e.getMessage());<br>        &#125;<br>        <span class="hljs-keyword">return</span> sheep;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>Spring中原型bean的创建，就是原型模式的应用</p><h4 id="浅拷贝">浅拷贝</h4><ol type="1"><li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。</li><li>对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</li><li>浅拷贝是使用默认的clone()方法来实现的</li></ol><h4 id="深拷贝">深拷贝</h4><ol type="1"><li>复制对象的所有基本数据类型的成员变量值</li><li>为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝</li></ol><p>深拷贝实现方式1：重写clone方法来实现深拷贝</p><p>深拷贝实现方式2：通过对象序列化实现深拷贝</p><p><strong>只有实现了Serializable接口的类的对象才能被序列化</strong>。Serializable接口是一个空接口，只起到标记作用。<strong>如果对象的属性是对象，属性对应类也必须实现Serializable 接口</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeepCloneableTarget</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>, Cloneable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">final</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">private</span> String cloneName;<br>    <span class="hljs-keyword">private</span> String cloneClass;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DeepCloneableTarget</span><span class="hljs-params">(String cloneName, String cloneClass)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cloneName = cloneName;<br>        <span class="hljs-built_in">this</span>.cloneClass = cloneClass<br>    &#125;<br>    <br>    <span class="hljs-comment">// 因为该类的属性都是String，因此这里使用默认的克隆方法完成即可</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone(); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeepProtoType</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>, Cloneable &#123;<br>    <span class="hljs-keyword">public</span> Sring name;<br>    <span class="hljs-keyword">public</span> DeepCloneableTarget deepCloneableTarget;<span class="hljs-comment">// 引用类型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DeepProtoType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>    &#125;<br>    <span class="hljs-comment">// 深拷贝</span><br>    <span class="hljs-comment">// 1.使用clone方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedExpetion &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">deep</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 完成对基本数据类型的克隆</span><br>        deep = <span class="hljs-built_in">super</span>.clone();<br>        <span class="hljs-comment">// 对引用类型的属性进行单独处理</span><br>        <span class="hljs-type">DeepProtoType</span> <span class="hljs-variable">deepProtoType</span> <span class="hljs-operator">=</span> (DeepProtoType)deep;<br>        <span class="hljs-comment">// DeepCloneableTarget中的属性都是基本数据类型</span><br>        deepProtoType.deepColoneableTatget = (DeepCloneableTarget)deepCloneableTarget.clone();<br>        <span class="hljs-keyword">return</span> deepProtoType;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 2.通过对象序列化实现（推荐）</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deepClone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 创建流对象</span><br>       <span class="hljs-type">ByteArrayOutputSream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ByteArrayInputSream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 序列化操作</span><br>            bos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-comment">// ObjectOutputStream只有一个public权限的构造方法，该构造方法需要传入一个OutputStream表示将对象二进制流写入到指定的OutputStream</span><br>           oos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>            oos.writeObject(<span class="hljs-built_in">this</span>);<span class="hljs-comment">// 将当前这个对象以对象流的方式输出（序列化）</span><br>             <br>            <span class="hljs-comment">// 反序列化</span><br>            bis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputSream</span>(bos.toByteArray());<br>            ois = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputSream</span>(bis);<br>            <span class="hljs-type">DeepProtoType</span> <span class="hljs-variable">cpoyObj</span> <span class="hljs-operator">=</span> (DeepProtoType)ois.readObject();<br>            <span class="hljs-keyword">return</span> cpoyObj;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                bos.close();<br>                oos.close();<br>                ois.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>                ...<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原型模式的注意事项和细节</p><ol type="1"><li>创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率</li><li>不用重新初始化对象，而是动态地获得对象运行时的状态</li><li>如果原始对象发生变化（增加或者减少属性），其他克隆对象也会发生相应的变化，无需修改代码</li><li>在实现深克隆的时候可能需要比较复杂的代码</li><li>缺点：需要为每一类配备一个克隆方法，这对全新的类来说不是很难，但是对已有的类进行改造时，需要修改其源代码，违背了ocp原则</li></ol><h3 id="建造者模式">建造者模式</h3><p>是一种对象构建模式，可以将复杂对象的建造过程抽象出来，使这个抽象过程的不同实现方式可以构造出不同表现的对象</p><p>建造者模式的四个角色：</p><ol type="1"><li>Product</li><li>Builder</li><li>ConcreteBuilder</li><li>Director</li></ol><h3 id="适配器模式">适配器模式</h3><ol type="1"><li>类适配器</li><li>对象适配器</li><li>接口适配器</li></ol><h4 id="类适配器模式注意事项">类适配器模式注意事项</h4><ol type="1"><li>java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点，因为这要求dst必须是接口，有一定局限性</li><li>src类的方法在Adapter中都会暴露出来，也增加了使用的成本</li><li>由于继承了src类，所以它可以根据需要重写src的方法，使得Adapter的灵活性增强了。</li></ol><h4 id="对象适配器">对象适配器</h4><ol type="1"><li>基本思路和类适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题，即：持有src类，实现dst类接口，完成src-&gt;dst的适配</li><li>根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系</li><li>对象适配器模式是适配器模式中常用的一种</li></ol><h4 id="接口适配器">接口适配器</h4><ol type="1"><li>适配器模式又称缺省适配器模式</li><li>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现，那么该抽象类的子类（匿名内部类）可有选择地覆盖父类中的某些方法来实现需求</li><li>适用于一个接口不想使用其他所有的方法的情况</li></ol>]]></content>
    
    
    <categories>
      
      <category>课程</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更改windows的cmd默认打开路径</title>
    <link href="/Windows/%E6%9B%B4%E6%94%B9windows%E7%9A%84cmd%E9%BB%98%E8%AE%A4%E6%89%93%E5%BC%80%E8%B7%AF%E5%BE%84/"/>
    <url>/Windows/%E6%9B%B4%E6%94%B9windows%E7%9A%84cmd%E9%BB%98%E8%AE%A4%E6%89%93%E5%BC%80%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<ol type="1"><li><h3 id="打开注册表">打开注册表</h3><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220401115105930.png" /></p></li><li><h3 id="找到下面的项">找到下面的项</h3></li></ol><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">HKEY_CURRENT_USER\Software\Microsoft\Command Processor<br>或者<br>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><h3 id="新增一个字符串">新增一个字符串</h3><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220401115430752.png" /></p></li><li><h3 id="查看效果">查看效果</h3><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220401115457954.png" /></p><p>也可改成其他路径。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>所有</category>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM前索引偏移寻址和后索引偏移寻址</title>
    <link href="/%E6%89%80%E6%9C%89/ARM%E5%89%8D%E7%B4%A2%E5%BC%95%E5%81%8F%E7%A7%BB%E5%AF%BB%E5%9D%80%E5%92%8C%E5%90%8E%E7%B4%A2%E5%BC%95%E5%81%8F%E7%A7%BB%E5%AF%BB%E5%9D%80/"/>
    <url>/%E6%89%80%E6%9C%89/ARM%E5%89%8D%E7%B4%A2%E5%BC%95%E5%81%8F%E7%A7%BB%E5%AF%BB%E5%9D%80%E5%92%8C%E5%90%8E%E7%B4%A2%E5%BC%95%E5%81%8F%E7%A7%BB%E5%AF%BB%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220401124111357.png" /></p><h3 id="寻址模式2--加载和存储字或无符号字节">寻址模式2-加载和存储字或无符号字节</h3><p>有九种寻址模式用于计算Load and Store字或无符号字节指令的地址。一般的指令语法是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">LDR | STR&#123;&lt;cond&gt;&#125; &#123;B&#125; &#123;T&#125; &lt;Rd&gt;, &lt;addressing_mode&gt;<br></code></pre></td></tr></table></figure><p>其中<addressing_mode>是下面列出的九个选项之一：</p><p>LDR、LDRB、STR和STRB均可使用以下9个选项。对于LDRBT、LDRT、STRBT和STRBT，只有post-indexed（后索引）选项（列表中的最后三个）可用。对于A10-14页的PLD中描述的PLD指令，只有offset （偏移）选项（列表中的前三个）可用。</p><ol type="1"><li><code>[&lt;Rn&gt;, #+/-&lt;offset_12&gt;]</code> Immediateoffset</li><li><code>[&lt;Rn&gt;, +/-&lt;Rm&gt;]</code> Register offset</li><li><code>[&lt;Rn&gt;, +/-&lt;Rm&gt;, &lt;shift&gt; #&lt;shift_imm&gt;]</code>Scaled register offset</li><li><code>[&lt;Rn&gt;, #+/-&lt;offset_12&gt;]!</code> Immediatepre-indexed</li><li><code>[&lt;Rn&gt;, +/-&lt;Rm&gt;]!</code> Register pre-indexed</li><li><code>[&lt;Rn&gt;, +/-&lt;Rm&gt;, &lt;shift&gt; #&lt;shift_imm&gt;]!</code>Scaled register pre-indexed</li><li><code>[&lt;Rn&gt;], #+/-&lt;offset_12&gt;</code> Immediatepost-indexed</li><li><code>[&lt;Rn&gt;], +/-&lt;Rm&gt;</code> Register post-indexed</li><li><code>[&lt;Rn&gt;], +/-&lt;Rm&gt;, &lt;shift&gt; #&lt;shift_imm&gt;</code>Scaled register post-indexed</li></ol><h3 id="前索引寻址">前索引寻址</h3><p>以Immediate pre-indexed举例：</p><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220401124224562.png" /></p><p>This addressing mode calculates an address by adding or subtractingthe value of an immediate offset to or from the value of the baseregister Rn. If the condition specified in the instruction matches thecondition code status, the calculated address is written back to thebase register Rn.</p><p>这种寻址模式通过对基寄存器Rn的值加或减一个立即偏移量的值来计算地址。如果指令中指定的条件与条件代码状态匹配，则计算出的地址被写回基寄存器Rn。</p><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220401124928200.png" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">if U == 1 then <br>    address = Rn + offset_12<br>else /* if U == 0 */<br>    address = Rn - offset_12<br>if ConditionPassed(cond) then<br>    Rn = address<br></code></pre></td></tr></table></figure><p>这种寻址模式用于指针访问数组，并自动更新指针值。（类似于a[++i]）</p><h3 id="后索引寻址">后索引寻址</h3><p>以Immediate post-indexed举例：</p><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220401125139620.png" /></p><p>This addressing mode uses the value of the base register Rn as theaddress for the memory access. If the condition specified in theinstruction matches the condition code status, the value of theimmediate offset is added to or subtracted from the value of the baseregister Rn and written back to the base register Rn.</p><p>这种寻址模式使用基寄存器Rn的值作为内存访问的地址。如果指令中指定的条件与条件代码状态相匹配，则立即偏移量的值将与基寄存器Rn的值相加或相减，并写入基寄存器Rn。</p><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220401125336156.png" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">address = Rn<br>if ConditionPassed(cond) then<br>    if U == 1 then <br>        Rn = Rn + offset_12<br>    else /* U == 0 */<br>        Rn = Rn - offset_12<br></code></pre></td></tr></table></figure><p>这种寻址模式用于指针访问数组，并自动更新指针值。（类似于a[i++]）</p>]]></content>
    
    
    <categories>
      
      <category>ARM</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM指令格式以及第二个操作数的immed_8r形式</title>
    <link href="/%E6%89%80%E6%9C%89/ARM%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F%E4%BB%A5%E5%8F%8A%E7%AC%AC%E4%BA%8C%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84immed-8r%E5%BD%A2%E5%BC%8F/"/>
    <url>/%E6%89%80%E6%9C%89/ARM%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F%E4%BB%A5%E5%8F%8A%E7%AC%AC%E4%BA%8C%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84immed-8r%E5%BD%A2%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="基本语法格式">基本语法格式</h3><p><strong>编码指令格式</strong></p><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220318180225611.png" /></p><p>ARM是<strong>三地址</strong>指令格式，指令的基本格式如下：</p><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220318175303792.png" /></p><p>其中&lt;&gt;号内的项是必须的，{}号内的项是可选的。各项的说明如下：</p><p><strong>Opcode</strong>：指令助记符；</p><p><strong>cond</strong>：执行条件；</p><p><strong>S</strong>：是否影响CPSR寄存器的值；</p><p><strong>Rd</strong>：目标寄存器；</p><p><strong>Rn</strong>：第1个操作数的寄存器；</p><p><strong>operand2</strong>：第2个操作数；</p><h3 id="第二个操作数12位">第二个操作数（12位）</h3><p>灵活的使用第2个操作数<strong>"operand2"</strong>能够提高代码效率。它有如下的形式：</p><ul><li><strong>#immed_8r</strong>——<strong>常数表达式</strong>（立即数-immediateoperand）；</li><li><strong>Rm</strong>——寄存器方式；</li><li>Rm,shift——<strong>寄存器移位方式</strong>；</li></ul><p><strong>#immed_8r——常数表达式</strong></p><p>该常数必须对应8位位图，即一个8位的常数通过循环右移偶数位得到。</p><p><strong>这里需要注意的点：</strong></p><ol type="1"><li>8位数</li><li>循环右移偶数位</li></ol><p><strong>理解</strong>：ARM需要使用12位的编码来表示32位数。那么如何实现这一点呢？</p><p>8位存数据，4位存移位的次数（实际是移位数÷2）</p><p><strong>理解</strong>：4位只有16种可能值，而32位数可以循环移位32次（32种可能），并且为什么必须是右移偶数位呢，而不能是奇数位呢？</p><p>为什么会有立即数这样的规定呢，这是由于所有的ARM指令是<strong>精简指令集</strong>，指令长度固定都是32位，对于ARM数据处理指令自然也是一样。数据处理指令大致可包含3类，数据传送指令、数据算术逻辑运算指令和数据比较指令。在以条ARM数据处理指令中，除了要包含处理的数据值外，还要标识ARM命令名称,控制位,寄存器等其他信息。</p><p>这样在一条ARM数据处理指令中，能用于表示要处理的数据值的位数只能小于32位。ARM在指令格式中设定，只能用指令机器码32位中的<strong>低12位</strong>来表示要操作的常数。ARM处理器是按32位来处理数据的，ARM处理器处理的数据是32位，如果简单的用这12位来表示，显然范围太小了，为了扩展到32位，因此使用了构造的方法，在12位中<strong>用8位表示基本数据值</strong>，用4位表示位移值，通过用8位基本数据值往右循环移动<strong>4位位移值×2次</strong>，来表示要操作的常数。这里要强调终的循环次数是4位位移值乘以2得到的，所以得到的终循环次数肯定是一个偶数，为什么要乘以2呢，实质还是因为范围不够，4位表示位移次数，最大才15次，加上8位数据还是不够32位，这样只能通过ALU的内部结构设计将4位位移次数乘以2,这样就能用12位表示32位常数了。通过循环偶数位得的到操作数，扩大了操作数的范围，但也带来了问题，并不是每个数据都能通过8位基本数据循环移动偶数为得到，如果你在ARM数据处理指令中使用的操作数,不是立即数。</p><p><strong>理解</strong>：为什么是右移？</p><p>arm中只有循环右移</p><p><strong>理解</strong>：立即数能表示所有的32位数吗？</p><p>不能，只能表示32位数中的一部分，不是每个数都能通过8位基本数据循环移动偶数次得到。</p>]]></content>
    
    
    <categories>
      
      <category>ARM</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM的程序计数器PC(R15)以及异常返回地址</title>
    <link href="/%E6%89%80%E6%9C%89/ARM%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8PC-R15-%E4%BB%A5%E5%8F%8A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%97%B6%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <url>/%E6%89%80%E6%9C%89/ARM%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8PC-R15-%E4%BB%A5%E5%8F%8A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%97%B6%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="程序计数器pcr15">程序计数器PC(R15)</h3><p><strong>ARM</strong>状态下，位<strong>[1:0]</strong>为0，位<strong>[31:2]</strong>用于保存<strong>PC</strong>；</p><p><strong>Thumb</strong>状态下，位<strong>[0]</strong>为0，位<strong>[31:1]</strong>用于保存<strong>PC</strong>；</p><p>由于<strong>ARM</strong>体系结构采用了多级流水线技术，对于<strong>ARM</strong>指令集而言，<strong>PC</strong>总是指向当前指令的<strong>下两条指令</strong>的地址，即<strong>PC</strong>的值为当前指令（正在执行的指令）的地址值加<strong>8</strong>个字节（一个ARM指令32位，4个字节）。</p><h4 id="理解">理解</h4><p>这里需要回顾一下CPU执行指令的步骤和多级流水线技术</p><p>CPU在执行1条指令的时候，主要有3个步骤：</p><ul><li><p>取指（将指令从内存或指令cache中取入指令寄存器）；</p></li><li><p>译码（指令译码器对指令寄存器中的指令进行译码操作，从而辨识出该指令是要执行add，或是sub，或是其它操作，从而产生各种时序控制信号）；</p></li><li><p>执行（指令执行单元根据译码的结果进行运算并保存结果）</p></li></ul><p><strong>取指</strong>阶段占用的CPU硬件是<strong>指令通路</strong>和<strong>指令寄存器</strong>；<strong>译码</strong>阶段占用的CPU硬件是<strong>指令译码器</strong>；<strong>执行</strong>阶段占用的CPU硬件是指令<strong>执行单元</strong>和<strong>数据通路</strong>。三者占用的CPU硬件完全不同，这样就使得如下的操作得以进行：在对第1条指令进行译码的时候，可以同时对第2条指令进行取指操作；在对第1条指令进行执行的时候，可以同时对第2条指令进行译码操作，对第3条指令进行取指操作。显然，这样就可以将该程序的运行总时间从30秒缩减为12秒，提速近3倍。上面所述并行运行指令的方式就被称为流水线操作。可见：流水线操作的本质是利用指令运行的不同阶段使用的CPU硬件互不相同，并发的运行多条指令，从而提高时间效率。</p><p>这里以三级流水线为例：</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220318170255436.png"alt="三级流水线" /><figcaption aria-hidden="true">三级流水线</figcaption></figure><p><code>寄存器PC的值是即将被取指的指令的地址</code></p><p><strong>正常情况下</strong>，在该条指令被取入CPU后执行期间，PC的值保持不变，在该条指令执行完成的时间点上，硬件会自动将PC的值增加一个单位的大小，这样PC就指向了下一条将被取指和执行的指令。</p><p><strong>而在引入流水线后</strong>，PC值的情况发生了变化，假定第1条指令的内存地址为X，则在时刻T（第一条指令即将被取指），PC的值变为X，并在时刻T至时刻T+1期间维持不变；在时刻T+1，PC的值变为X+1个单位，并在时刻T+1至时刻T+2期间维持不变；在时刻T+2，PC的值变为X+2个单位，并在时刻T+2至时刻T+3期间维持不变；在时刻T+3，PC的值将变为X+3个单位。<strong>（为要保证流水线正常工作就得不停取指，每次取值PC值就会增加）</strong>由此可见，在第1条指令的执行阶段，PC的值不再是该指令在内存中的位置，而是该指令在内存中的位置+2个单元。对于ARM指令集而言，每条指令的长度为32bit，占4byte，所以1条指令在内存中需要4byte存储。</p><p><strong>注意</strong>：虽然存在多种级别的流水线，但ARM出于统一和前后兼容的考虑，<code>PC 的值 = 当前正在执行指令在内存中的地址 + 8</code>这个结论在所有的流水线级别上都是相同的。</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220318171259152.png"alt="读R15的限制" /><figcaption aria-hidden="true">读R15的限制</figcaption></figure><h3 id="arm处理器异常返回地址">ARM处理器异常返回地址</h3><p>下面以三种异常为例，说明<strong>ARM处理器异常返回地址</strong>：</p><ol type="1"><li><strong>FIQ</strong>（<strong>Fast Interrupt Request</strong>）</li><li><strong>IRQ</strong>（<strong>Interrupt Request</strong>）</li><li><strong>ABORT</strong>（中止）</li></ol><p>在ARM处理器中一条指令的执行分为取指、译码、执行三个阶段，由于指令流水线的存在造成当前执行的指令的地址是PC-8(ARM指令集)，那么当前执行指令的下一条指令的地址应该是PC-4，所以在异常产生时处理器会将PC-4的值保存到对应模式的LR寄存器中，但是该返回地址是否能够被使用还要看具体产生的异常的种类而定。</p><p><strong>FIQ与RIQ异常：</strong></p><p>FIQ与RIQ异常返回处理是一样的，当处理器<strong>执行完当前指令后</strong>才去查询中断且查看是否允许中断，如果处理器产生了中断，这时PC的值已经更新，即PC指向了当前指令后<strong>第三条指令的位置</strong>(被中断指令地址加12)，产生FIQ与RIQ异常后处理器将PC-4的值保存到了对应模式下的LR，而它指向的是当前被中断指令的后面的第二条指令，因此在返回时我们需要人为的将LR中保存的值自减4以得到正确的返回地址。</p><p>说明：PC是发生中断的指令后面的第三条指令地址，PC-12是发生中断的指令地址，LR（R14）=PC - 4，LR - 4就是发生中断的指令地址后面的第一条指令(也就是PC - 8)。</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220318172408962.png"alt="以FIQ为例" /><figcaption aria-hidden="true">以FIQ为例</figcaption></figure><p><strong>数据中止异常：</strong></p><p>产生该异常的时候程序要返回到有问题的指令处重新访问该数据，因此应该返回到产生异常的指令处而不是产生异常指令的下一条指令处。当异常产生时PC的值已经更新，所以PC指向的是异常产生指令的后面的第三条指令，而LR中保存的是PC-4的值即异常产生指令的后面的第二条指令的地址。所以在返回时我们需人为的对LR中的值进行自减8的处理。以保证异常正确的返回。</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220318172659486.png"alt="数据中止异常" /><figcaption aria-hidden="true">数据中止异常</figcaption></figure><p><strong>文章参考</strong>：<ahref="http://emb.hqyj.com/Column/7517.html">ARM处理器异常返回地址_华清远见教育集团(hqyj.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>ARM</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM微处理器的存储器格式</title>
    <link href="/%E6%89%80%E6%9C%89/ARM%E6%9C%80%E5%A4%A7%E5%AF%BB%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E5%AD%97%E9%95%BF%E3%80%81%E6%8C%87%E4%BB%A4%E9%95%BF%E5%BA%A6/"/>
    <url>/%E6%89%80%E6%9C%89/ARM%E6%9C%80%E5%A4%A7%E5%AF%BB%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E5%AD%97%E9%95%BF%E3%80%81%E6%8C%87%E4%BB%A4%E9%95%BF%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="arm微处理器的存储器格式">ARM微处理器的存储器格式</h2><h3 id="最大寻址空间"><strong>最大寻址空间</strong></h3><p><strong>ARM</strong>体系结构所支持的最大寻址空间为<strong>4GB</strong>(<spanclass="math inline">\(2^{32}\)</span>字节)</p><h3 id="字长指令长度"><strong>字长、指令长度</strong></h3><p>ARM处理器的字长是<strong>32位</strong>，则一条汇编指令的长度也是32位，也就是四个字节(8位一个字节)，而内存中一个地址单元是一个字节，也就是说一条指令要占据4个地址单元。假设程序顺序执行（一条接一条，没有跳转），假设当前正在CPU中执行的指令A的首地址是0，也就是说指令A的存放位置是内存中的0—3这4个地址单元。</p><p>ARM是一种32位处理器，即ARM处理器处理的数据通常是以32位二进制位基本单位的。ARM中的一个32位数叫做一个字。在存储器中，ARM的一个基本数据需要占用4个连续存储单元，为了判断哪四个单元为一个字，ARM规定一个字所占用的4个连续存储单元的第一个单元地址的低2位必须是00(能被被四整除)。</p><h3 id="大端格式小端格式"><strong>大端格式、小端格式</strong></h3><p>根据字的4字节在4个存储单元中的存储顺序，ARM提供了两种存储方式：小端方式和大端方式。系统默认的是小端方式，即字的低位字节在地址的底端（小端）。</p><p><strong>理解</strong>：</p><p><strong>所谓的大端模式，</strong>是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；</p><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220311114119021.png" /></p><p><strong>所谓的小端模式，</strong>是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。</p><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220311114322099.png" /></p><p>例如，<strong>16bit</strong>宽的数<strong>0x1234</strong>在Little-endian（小端）模式CPU内存中的存放方式（假设从地址<strong>0x4000</strong>开始存放）为：</p><table><thead><tr><th>内存地址</th><th>0x4000</th><th>0x4001</th></tr></thead><tbody><tr><td>存放内容</td><td>0x34</td><td>0x12</td></tr></tbody></table><p>而在Big-endian（大端）模式CPU内存中的存放方式则为：</p><table><thead><tr><th>内存地址</th><th>0x4000</th><th>0x4001</th></tr></thead><tbody><tr><td>存放内容</td><td>0x12</td><td>0x34</td></tr></tbody></table><p><strong>32bit</strong>宽的数0x12345678在Little-endian（小端）模式CPU内存中的存放方式（假设从地址<strong>0x4000</strong>开始存放）为：</p><table><thead><tr><th>内存地址</th><th>0x4000</th><th>0x4001</th><th>0x4002</th><th>0x4003</th></tr></thead><tbody><tr><td>存放内容</td><td>0x78</td><td>0x56</td><td>0x34</td><td>0x12</td></tr></tbody></table><p>　　而在Big-endian（大端）模式CPU内存中的存放方式则为：</p><table><thead><tr><th>内存地址</th><th>0x4000</th><th>0x4001</th><th>0x4002</th><th>0x4003</th></tr></thead><tbody><tr><td>存放内容</td><td>0x12</td><td>0x34</td><td>0x56</td><td>0x78</td></tr></tbody></table><p>为什么会有大小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEILC51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。</p><h3 id="指令长度及数据类型"><strong>指令长度及数据类型</strong></h3><p><strong>ARM</strong>微处理器的指令长度可以是<strong>32</strong>位（在<strong>ARM</strong>状态下），也可以为<strong>16</strong>位（在<strong>Thumb</strong>状态下）。</p><p><strong>ARM</strong>微处理器中支持字节（<strong>8</strong>位）、半字（<strong>16</strong>位）、字（<strong>32</strong>位）三种数据类型，其中，字需要<strong>4</strong>字节对齐（地址的低两位为<strong>0</strong>）、半字需要<strong>2</strong>字节对齐（地址的最低位为<strong>0</strong>）</p><p><strong>ARM</strong>微处理器中的字为32位（4字节）、半字为16位（2字节）、字节为8位（1字节）。</p><p>大多数计算机使用<strong>字节（8位的数据块）作为最小可寻址的存储器单位</strong>，而不是访问存储器中单独的位。存储器的每一个字节都由唯一的数字标识，称为该字节的<strong>地址</strong>，所有可能地址的集合称为存储器空间。</p><p>举例来说，ARM处理器工作状态有如下两种：</p><p>ARM状态：执行字对齐的32位ARM指令。</p><p>Thumb状态：执行半字对齐的16位Thumb指令。</p><p><strong>对于字对齐：</strong></p><p>假如，第一次取ARM指令1的地址为 0x00000000，由于ARM指令占32位（4个字节），因此地址0x0000 0001、0x00000002、0x00000003（分别指向一个字中的4个字节的地址）都是指令1的地盘。那么第二次取ARM指令2的地址为0x0000 0004，同样的道理，0x0000 0005、0x0000 0006、0x00000007也都是指令2的地盘，以此类推：</p><p>指令1：<strong>0x0000 0000</strong>——0x0000 0003</p><p>指令2：<strong>0x0000 0004</strong>——0x0000 0007</p><p>指令3：<strong>0x0000 0008</strong>——0x0000 000B</p><p>指令4：<strong>0x0000 000C</strong>——0x0000 000F</p><p>…</p><p>观察各个指令的<strong>起始地址</strong>：</p><p>若按十进制来看分别是：0、4、8、12、…<strong>都可以被4整除</strong>。</p><p>若按二进制来看bit1和bit0都是0：也就是说它们的起始地址都是0bxxxxxxxxxxxxxxxx xxxxxxxx xxxxxx<strong>00</strong>（32位地址）</p><p>同理，对于Thumb指令，他们的起始地址都是0bxxxxxxxx xxxxxxxx xxxxxxxxxxxxxxx<strong>0</strong>（32位地址）</p>]]></content>
    
    
    <categories>
      
      <category>ARM</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于OracleDBConsoleorcl服务无法启动问题原因分析与解决办法</title>
    <link href="/Oracle/%E5%85%B3%E4%BA%8EOracleDBConsoleorcl%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/Oracle/%E5%85%B3%E4%BA%8EOracleDBConsoleorcl%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2id="关于oracledbconsoleorcl服务无法启动问题原因分析与解决办法">关于OracleDBConsoleorcl服务无法启动问题原因分析与解决办法</h2><h3 id="问题描述">问题描述</h3><p>不久前我在windows电脑上成功安装了Oracle10g，并顺利地启动了OracleDBConsoleorcl并且登上了OEM(Oracle企业管理器)网页。</p><p>但是在今天，我发现OracleDBConsoleorcl怎么也没有办法启动，不管是通过管理员命令行输入命令启动还是通过任务管理的服务手动打开。</p><h3 id="原因分析">原因分析</h3><p>经过上网搜索问题相关资料，我发现原因在于OracleDBConsoleorcl服务会根据当前计算机所连接到的ip地址信息来配置一些文件，启动这个服务的时候就会用到这些文件，而问题就出在了这里，每次重新联网后ip地址都会重新动态分配，这样分配的ip和第一次安装oracle时使用的ip信息不一样，所以导致oracleconsoleorcl服务无法启动了。</p><h3 id="解决办法">解决办法</h3><ol type="1"><li><p>删除资料档案库</p><p>会同时删除OracleDBConsoleORCL服务，并删除用户SYSMAN及其所属对象</p></li><li><p>重新创建资料档案库</p><p>会重新添加OracleDBConsoleORCL服务，并创建SYSMAN用户及其所属对象。</p></li></ol><h3 id="解决步骤方法1">解决步骤(方法1)</h3><ol type="1"><li><p>此时Oracle的监听器服务和数据库服务必须处于启动状态</p></li><li><p>以管理员身份运行CMD</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">emca -repos drop<br></code></pre></td></tr></table></figure><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220305201200469.png" /></p><p>输入以下信息:</p><ul><li>数据库 SID: orcl</li><li>监听程序端口号: 1521</li><li>SYS 用户的口令:</li><li>SYSMAN 用户的口令:</li><li>SYSMAN 用户的口令:</li><li>是否继续? [是(Y)/否(N)]: y</li></ul></li><li><p>启动数据库配置助手</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dbca<br></code></pre></td></tr></table></figure><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220305201351570.png" /></p><ul><li>第一步时选择“配置数据库选件”</li></ul><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220305201554141.png" /></p><ul><li>后面的操作只需要一直点击下一步</li><li>在选择是否使用EM资料档案库时，一定要选中，默认没有选中</li></ul><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220305201616361.png" /></p><ul><li>dbca检查到系统中已经没有EM资料档案库，于是就会重新创建</li><li>OracleDBConsoleORCL服务也会重新添加了</li></ul><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220305202803186.png" /></p></li></ol><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220305204411971.png" /></p><h3 id="解决步骤方法2">解决步骤(方法2)</h3><p>重新配置</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">emca -config dbcontrol db -repos recreate<br></code></pre></td></tr></table></figure><p>启动</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">emctl <span class="hljs-literal">start</span> dbconsole<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>所有</category>
      
      <category>Oracle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Oracle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS7安装Mysql5.7</title>
    <link href="/%E6%89%80%E6%9C%89/CentOS7%E5%AE%89%E8%A3%85Mysql5-7/"/>
    <url>/%E6%89%80%E6%9C%89/CentOS7%E5%AE%89%E8%A3%85Mysql5-7/</url>
    
    <content type="html"><![CDATA[<h3 id="centos安装mysql5.7">CentOS安装Mysql5.7</h3><ol type="1"><li><h5 id="下载并安装mysql官方的-yum-repository">下载并安装Mysql官方的Yum Repository</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget http:<span class="hljs-regexp">//</span>dev.mysql.com<span class="hljs-regexp">/get/my</span>sql57-community-release-el7-<span class="hljs-number">11</span>.noarch.rpm<br></code></pre></td></tr></table></figure></li><li><h5 id="安装mysql的软件仓库">安装MySQL的软件仓库</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rpm</span> -ivh mysql57-community-release-el7-<span class="hljs-number">11</span>.noarch.rpm<br></code></pre></td></tr></table></figure></li><li><h5 id="安装mysql服务">安装MySQL服务</h5><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">yum -y install mysql-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p><strong>可能遇到的问题</strong></p><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220225112053832.png" /></p><p><strong>问题描述：</strong>源MySQL 5.7 Community Server” 的 GPG密钥已安装，但是不适用于此软件包。</p><p><strong>解决办法：</strong></p><ol type="1"><li><p>执行以下命令：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">rpm --<span class="hljs-keyword">import</span> https:<span class="hljs-comment">//repo.mysql.com/RPM-GPG-KEY-mysql-2022</span><br></code></pre></td></tr></table></figure></li><li><p>重试安装命令</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">yum -y install mysql-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure></li></ol></li><li><h5 id="安装成功">安装成功</h5><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220225112334882.png" /></p></li></ol><h3 id="启动mysql服务">启动Mysql服务</h3><ol type="1"><li><h5 id="启动命令">启动命令</h5><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span>  mysqld.service<br></code></pre></td></tr></table></figure></li><li><h5 id="查看mysql运行状态">查看MySQL运行状态</h5><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">systemctl <span class="hljs-keyword">status</span> mysqld.service<br></code></pre></td></tr></table></figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220225112442932.png" /></li></ol>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习-理解ROC、AUC以及rank-loss</title>
    <link href="/%E6%89%80%E6%9C%89/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%90%86%E8%A7%A3ROC%E3%80%81AUC%E4%BB%A5%E5%8F%8Arank-loss/"/>
    <url>/%E6%89%80%E6%9C%89/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%90%86%E8%A7%A3ROC%E3%80%81AUC%E4%BB%A5%E5%8F%8Arank-loss/</url>
    
    <content type="html"><![CDATA[<h1 id="理解rocauc以及rank-loss">理解ROC、AUC以及rank-loss</h1><h3 id="roc">ROC</h3><p><img src="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220115103747376.png" alt="西瓜书P33" style="zoom:200%;" /></p><p>理解：以ROC在医学检测中的应用举例，首先我们需要将混淆矩阵中的各个元素赋予对应的含义。</p><p><img src="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220115111426556.png" alt="分类结果混淆矩阵" style="zoom:200%;" /></p><p>在医学检测中，我们可以按照下面的含义解释上述各元素（正例为阳性-得病，反例为阴性-健康）</p><ul><li>TP：预测结果是正例，真实情况是正例，可以看作是医生正确诊断出病例</li><li>FN：预测结果是反例，真实情况是正例，可以看作是医生漏诊，将得病诊断为健康</li><li>FP：预测结果是正例，真实情况是反例，可以看作是医生误诊，将健康诊断为得病</li><li>TN：预测结果是反例，真实情况是反例，可以看作是医生检查出没有得病</li></ul><p>我们再来看ROC中的TPR和FPR。 <span class="math display">\[TPR = {TP \over TP + FN}\]</span></p><p><span class="math display">\[FPR = {FP \over TN + FP}\]</span></p><ul><li>TPR：<span class="math display">\[真正例 \over真实情况是正例\]</span>即在所有实际为正例的样本中，被正确地判断为正例的比率，可以看作是在所有得病的人中，有多少人被医生正确地诊断出阳性。</li><li>FPR：<span class="math display">\[假正例 \over真实情况是反例\]</span>即在所有实际为反例的样本中，被错误地判断为正例的比率，可以看作是在所有健康的人当中，有多少人被医生误诊为得病。</li></ul><p>那么对于一个机器学习的学习器而言，我们希望的是TPR越高越好，而FPR越低越好。然后实际情况是，当我们的阈值减小时，TPR和FPR会同时增大，当阈值为0的时候，即所有的实例都被预测为正例，此时的TPR为1，因为所有的阳性都被诊断出来了；此时的FPR为1，因为所有健康的人都被诊断为阳性。</p><p>ROC曲线就是以TPR为纵轴，以FPR为横轴，如图。</p><p><img src="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220115141452830.png" alt="ROC曲线" style="zoom:200%;" /></p><p>如图可见，如果想要TPR尽可能的高，那么相应的阴影部分的面积也会增大。我们进行学习器的比较时，与P-R图相似，若一个学习器的ROC曲线被另一个学习器的曲线完全”包住“，则可断言后者的性能优于前者；若两个学习器的ROC曲线发生交叉，则难以一般性地断言两者孰优孰劣。此时如果一定要进行比较，则较为合理的判据是比较ROC曲线下的面积，即AUC（AreaUnder ROC Curve）。</p><p><img src="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220115143800508.png" alt="image-20220115143800508" style="zoom:200%;" /></p><p><img src="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220115144442178.png" alt="image-20220115144442178" style="zoom:200%;" /></p><p>这里的AUC的公式比较好理解，就是通过坐标计算出一小块一小块的面积的和。</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220115151620674.png"alt="ROC曲线可能出现的3种情况" /><figcaption aria-hidden="true">ROC曲线可能出现的3种情况</figcaption></figure><p>对应3种情况：</p><ol type="1"><li>如果<span class="math display">\[y_i =y_{i+1}\]</span>那么小块形状是矩形，真正例率不变，假正例率增加<spanclass="math inline">\(1 \overm-\)</span>，水平向右移动，面积就是$(x_{i+1} - x_i) y_i $</li><li>如果<span class="math inline">\(x_i =x_{i+1}\)</span>那么小块形状是垂直的线段，真正例率增加<spanclass="math inline">\(1 \overm+\)</span>，假正例率不变，垂直向上移动，面积就是0</li><li>如果下一个点<span class="math inline">\((x_{i+1},y_{i+1})\)</span><span class="math inline">\(在\)</span><spanclass="math inline">\((x_{i}, y_{i})\)</span><spanclass="math inline">\(的右上方，真正例率和假正例率同时增加，面积按照梯形面积公式计算，\)</span><spanclass="math inline">\({1\over2}\cdot(x_{i+1}-x_i)\cdot(y_{i+1}-y_i)\)</span></li></ol><p><img src="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220115151949690.png" alt="image-20220115151949690" style="zoom:200%;" /></p><p>综上，总的AUC计算公式，如下。</p><p><img src="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220115143829171.png" alt="rank-loss" style="zoom:200%;" /></p><p>这里引入了一个loss</p><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220115153949762.png" /></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>F1度量为何用调和平均而不用算术平均</title>
    <link href="/%E6%89%80%E6%9C%89/F1%E5%BA%A6%E9%87%8F%E4%B8%BA%E4%BD%95%E7%94%A8%E8%B0%83%E5%92%8C%E5%B9%B3%E5%9D%87%E8%80%8C%E4%B8%8D%E7%94%A8%E7%AE%97%E6%9C%AF%E5%B9%B3%E5%9D%87/"/>
    <url>/%E6%89%80%E6%9C%89/F1%E5%BA%A6%E9%87%8F%E4%B8%BA%E4%BD%95%E7%94%A8%E8%B0%83%E5%92%8C%E5%B9%B3%E5%9D%87%E8%80%8C%E4%B8%8D%E7%94%A8%E7%AE%97%E6%9C%AF%E5%B9%B3%E5%9D%87/</url>
    
    <content type="html"><![CDATA[<h3 id="p-r图">P-R图</h3><p>查准率P（Precision）和查全率R（Recall）是一对矛盾的度量，一般来说，查准率高时，查全率往往偏低；而查全率高时，查准率往往偏低。</p><p><img src="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220110203102931.png" alt="P-R曲线" style="zoom:200%;" /></p><p><img src="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220110203245081.png" alt="西瓜书P31" style="zoom:200%;" /></p><h3 id="f_1值"><span class="math inline">\(F_1值\)</span></h3><p><img src="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220110203305121.png" alt="西瓜书P32" style="zoom:200%;" /></p><blockquote><p>当我看到西瓜书这个地方的时候，觉得一切都很有道理，但是突然又觉得不讲道理。虽然我知道F1度量肯定是人为规定的一个式子，但是为什么F1度量用的是调和平均，为什么不简单的使用算术平均或者其他的平均式综合考虑查准率和查全率。</p></blockquote><p>书上的解释是与算术平均（<span class="math inline">\(P + R \over2\)</span>）和几何平均（<span class="math inline">\(\sqrt{(P \timesR)}\)</span>）相比，调和平均更重视较小值。</p><p>于是我又去看了吴恩达的机器学习课程的相关内容，才算是搞懂了。</p><p><img src="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220110205407917.png" alt="吴恩达机器学习系列课程-精确度和召回率的权衡" style="zoom:200%;" /></p><p>如果我们有不同的算法，我们如何比较不同的查准率和召回率。具体一点，假设我们有三个不同的学习算法，或者这三个不同的学习曲线是同样的算法但是临界值（Threshold）不同，我们怎样决定哪一个算法是最好的？</p><p>我们可以用一个评估度量来决定算法的优劣。那么我们怎么得到一个评估度量值呢？</p><p>你可能会去尝试的一件事情是计算一下查准率和召回率的平均值（算术平均）<span class="math display">\[Average = { P + R \over 2}\]</span>但是这可能并不是一个很好的解决办法。因为，如果我们的回归模型总是预测y =1（阈值很低），那么你可能得到非常高的召回率，得到非常低的查准率。相反地，如果你的模型总是预测y= 0，就是说，如果很少预测y =1，对应的，设置了一个高临界值，最后你会得到非常高的查准率和非常低的召回率。这两个极端情况，一个有非常高的临界值，一个有非常低的临界值，它们中的任何一个都不是一个好的模型。我们可以通过非常低的查准率或者非常低的召回率，判断这不是一个好模型。如果你只是使用<spanclass="math inline">\(P + R \over2\)</span>，算法3的这个值是最高的。即使你可以通过使用总是预测y =1这样的方法来得到这样的值，但是这并不是一个好的模型。算法1和算法2比算法3更好，但是在这个例子中，查准率和召回率的平均值，算法3是最高的。</p><p>因此我们通常认为查准率和召回率的平均值（算术平均）不是评估算法的好方法。相反地，有一种结合查准率和召回率的不同方式，叫做F值，公式是<span class="math display">\[F_1Score = 2{ PR \over P + R}\]</span> 我们可以通过<spanclass="math inline">\(F_1Score\)</span>来判断算法1有最高的F值，算法2第二，算法3是最低的。因此，通过F值我们会在这几个算法中选择算法1。F值也叫做<spanclass="math inline">\(F_1\)</span>值。它的定义会考虑一部分查准率和召回率的平均值，但是它会给查准率和召回率中较低的值更高的权重。因此，你可以看到F值的分子是查准率和召回率的乘积，因此如果查准率等于0，或者召回率等于0，F值也会等于0。因此它结合了查准率和召回率，对于一个较大的F值，查准率和召回率都必须较大。</p><p>有较多的公式，可以结合查准率和召回率，F值公式只是其中一个，但是处于历史原因和习惯问题，人们在机器学习中使用F值。这个术语F值，没有什么特别的意义。</p><h3 id="总结">总结</h3><blockquote><p>后续我又上网搜索了下别人对算术平均和调和平均的理解</p></blockquote><p>算术平均值是一个良好的集中量数，具有反应灵敏、确定严密、简明易解、计算简单、适合进一步演算和较小抽样变化的影响等特点。但是极易受极端数据的影响，每个数据的或大或小的变化都会影响最终结果。</p><p>调和平均数具有以下几个主要特点：</p><p>1、调和平均数易受极端值的影响，且受极小值的影响比受极大值的影响更大。</p><p>2、只要有一个标志值为0，就不能计算调和平均数。</p><p>3、当组距数列有开口组时，其组中值即使按照相邻组距计算，假定性也很大。</p><p>4、调和平均数应用的范围较小。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习-查准率与查全率</title>
    <link href="/%E6%89%80%E6%9C%89/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%9F%A5%E5%87%86%E7%8E%87%E4%B8%8E%E6%9F%A5%E5%85%A8%E7%8E%87/"/>
    <url>/%E6%89%80%E6%9C%89/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%9F%A5%E5%87%86%E7%8E%87%E4%B8%8E%E6%9F%A5%E5%85%A8%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近在看周志华的《机器学习》西瓜书的时候，感觉书上的概念-查准率和查全率描述地有点抽象。于是查阅了一些资料深入学习，有所感悟。</p></blockquote><p><img src="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220105153124644.png" alt="西瓜书上的描述" style="zoom:200%;" /></p><p>参考了另一本书《机器学习实战：基于Scikit-Learn、Keras和TensorFlow》第二版</p><p><img src="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220105160225958.png" alt="image-20220105160225958"  /></p><p>For each instance, it computes a score based on a decisionfunction.</p><p>对于每个实例，它都基于决策函数计算分数。</p><p>If that score is greater than a threshold, it assigns the instance tothe positive class; otherwise it assigns it to the negative class.</p><p>如果该分数大于阈值，则将实例分配给正类；否则，它会将其分配给负类。</p><p>对于这样的二分类问题，我们可以用手写数字识别"5"举例</p><p><img src="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20220105155446546.png" alt="机器学习实战第137页" style="zoom:200%;" /></p><p>在上图中，我们可以看到有三个可以选择的阈值（Variousthresholds），就拿中间的那条竖线而言（对应一个阈值）：在竖线右边的实例，都会被预测为正例-1，在竖线左边的实例，都会被预测为反例-0。其中，中间的竖线右边有5个实例，而真实情况下这5个实例中只有4个手写数字是表示"5"的（第二个看不出来是"5"）。</p><p>查准率表示所有预测为1的样本中预测正确的比率，也就是4/5 =80％。其中4就是预测结果是"5"，真实情况是"5"的实例的个数，也就是真正例TP（TruePositive），预测正确，而5就是中间竖线右边的实例个数，也就是预测结果是"5"，但是不确定它的真实情况是什么，也就是TP+ FP（包括真正例和假正例）。</p><p>查准率P（Precision） <span class="math display">\[P={TP \over TP + FP}\]</span></p><p>在上图中，可以看到在所有的实例中（共12个），真实情况是"5"的个数有6个，包括了正例中的4个和反例中的2个，也就是真正例TP和假反例FN。召回率是指在所有真正为1的样本中预测正确的比率。也就是4/6= 67％。</p><p>召回率R（Recall） <span class="math display">\[R = { TP \over TP + FN }\]</span> 而精度（准确率）是正确预测为1，正确预测为0的样本占总体的比率<span class="math display">\[Acc = { TP + TN \over ALL}\]</span>TP是真正例，TN是真反例，准确率只关心是否预测对了，但是不关心实例本身的属性。</p><p>从上图也可以看出，对于图中的三种可以选取的阈值，当阈值越大（也就是把门的越严格），查准率P在上升，查全率R在下降。</p><p>而阈值越小，查准率P在下降，而查全率R在上升，也可以直观地表明查准率和查全率是一对矛盾的度量。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络习题_第二章_物理层</title>
    <link href="/Hexo/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%A0%E9%A2%98-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <url>/Hexo/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%A0%E9%A2%98-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="一选择题">一、选择题</h2><h3 id="信号是数据在传输过程中的的表现形式">1.信号是数据在传输过程中的()的表现形式。</h3><p>A. 电信号 B. 代码 C. 信息 D. 程序</p><h3 id="数据通信的任务是传输-代码的比特序列">2. 数据通信的任务是传输()代码的比特序列。</h3><p>A. 十进制 B. 帧结构 C. 分组结构 D. 二进制</p><h3 id="信号的电平是连续变化的">3. ( )信号的电平是连续变化的。</h3><p>A. 数字 B. 模拟 C. 脉冲 D. 二进制</p><h3 id="是指将数字信号转变成可以在电话线上传输的模拟信号的过程">4. ()是指将数字信号转变成可以在电话线上传输的模拟信号的过程。</h3><p>A. 解调 B. 采样 C. 调制 D. 压缩</p><h3 id="数据传输速率是指每秒钟传输构成数据二进制代码的-数">5.数据传输速率是指每秒钟传输构成数据二进制代码的( )数。</h3><p>A. 码元 B. 信元 C. 波特 D. 位</p><h3 id="利用模拟通信信道传输数据信号的方法称为">6.利用模拟通信信道传输数据信号的方法称为( )。</h3><p>A. 频带传输 B. 基带传输 C. 异步传输 D. 同步传输</p><h3 id="基带传输是指在数字通信信道上-传输数字数据信号的方法">7.基带传输是指在数字通信信道上( )传输数字数据信号的方法。</h3><p>A. 调制 B. 脉冲编码 C. 直接 D. 间接</p><h3id="数据在通信信道传输的过程中对数据传输的误码率影响最主要的因素是">8.数据在通信信道传输的过程中，对数据传输的误码率影响最主要的因素是()。</h3><p>A. 传输速率 B. 调制解调器 C. 传输介质 D. 噪声强度</p><h3 id="internet上的数据交换采用的是">9 .Internet上的数据交换采用的是()。</h3><p>A. 分组交换 B. 电路交换 C. 报文交换 D. 光交换</p><h3 id="fdm是指">FDM是指( )。</h3><p>A. 频分多路复用 B. 时分多路复用 C. 波分多路复用 D. 码分多路利用</p><h3 id="利用-数字数据可以用模拟信号来表示">11.利用()，数字数据可以用模拟信号来表示。</h3><p>A. 调制解调器 B. 编码解码器 C. 串联放大器 D. 电话网络</p><h3id="在数据通信系统中传输介质的功能是">12.在数据通信系统中，传输介质的功能是()。</h3><p>A. 在信源与信宿之间传输信息 B．纠正传输过程中的错误 C.根据环境状况自动调整信号形式 D. 将信号从一端传至另一端</p><h3 id="在光纤中采用的多路复用技术是">13.在光纤中采用的多路复用技术是()。</h3><p>A. 时分多路复用 B. 频分多路复用 C. 波分多路复用 D. 码分多路复用</p><h3id="为了实现长距离传输模拟传输系统都使用放大器来使信号中的能量得到增加其噪声分量">14.为了实现长距离传输，模拟传输系统都使用放大器来使信号中的能量得到增加，其噪声分量()。</h3><p>A. 增大 B. 减小 C. 不变 D. 不一定</p><h3id="复用是一种将若干个彼此独立的信号合并为一个可在同一信道上传输的">15.“复用”是一种将若干个彼此独立的信号合并为一个可在同一信道上传输的()。</h3><p>A. 调制信号 B. 已调信号 C. 复用信号 D. 单边带信号</p><h3 id="物理层-4-个重要特性机械特性功能特性电气特性和">16. 物理层 4个重要特性：机械特性、功能特性、电气特性和（）。</h3><p>A. 规程特性 B. 接口特性 C.协议特性 D. 物理特性</p><h3 id="基带系统使用进行传输的">17 ． 基带系统使用（）进行传输的。</h3><p>A. 模拟信号 B. 调制信号 C. 数字信号 D. 载波信号</p><h3 id="下列关于异步传输说法正确的是">18 ．下列关于异步传输说法正确的是（）。</h3><p>A. 一次传输一个数据块 B. 对时序的要求较高</p><p>C. 收/发端不需要进行同步 D. 数据传输速率低</p><h3 id="低通通道带宽为-5-khz编码采用-512-级分级信号最大数据传输率">19 ．低通通道带宽为 5 KHz,编码采用 512 级分级信号，最大数据传输率（）。</h3><p>A. 32 kbps B. 48 kbps C. 64 kbps D. 90 kbps</p><h3id="在宽带为-8-khz的信道上按奈奎斯特定理每秒能发送的比特数不超过">20.在宽带为8 KHz的信道上，按奈奎斯特定理，每秒能发送的比特数不超过</h3><p>48 kbps,则一个码元离散取值是（）。 A. 4 B. 8 C. 16 D. 24</p><h3id="在宽带为-8-khz的信道上如果-8-种不同的物理状态来表示数据若信噪比">21．在宽带为 8 KHz的信道上，如果 8种不同的物理状态来表示数据，若信噪比</h3><p>S/N为 30 Db,按香农定理，最大限制的数据速率为（）。 A. 24 kbps B. 48kbps C. 40 kbps D. 80 kbps</p><h3id="在脉冲起始时刻有无跳变来表示-0-和-1-在脉冲中间时刻始终发生跳变的编码是">22.在脉冲起始时刻，有无跳变来表示“0 ”和“ 1 ”，在脉冲中间时刻始终发生跳变的编码是（）。</h3><p>A. 曼彻斯特编码 B. 非归零码 C. 差分曼彻斯特编码 D. 8 B/ 10 B</p><h3 id="当数字信号在模拟传输系统中传送时在发送端和接收端分别需要">23 ．当数字信号在模拟传输系统中传送时，在发送端和接收端分别需要（）。</h3><p>A. 调制器和解调器 B. 解调器和调制器 C. 编码器和解码器 D.解码器和编码器</p><h3 id="两台计算机利用电话线路传输数据信号时必备的设备是.">24．两台计算机利用电话线路传输数据信号时必备的设备是().</h3><p>A. 调制解调器 B. 网卡 C. 中继器 D. 集线器</p><h3 id="当通信子网采用方式时我们首先要在通信双方之间建立起逻辑连接">25．当通信子网采用（）方式时，我们首先要在通信双方之间建立起逻辑连接。</h3><p>A. 报文交换 B. 虚电路 C. 数据报 D. 电路交换</p><h3 id="不受电磁干扰或噪声影响的介质是">26．不受电磁干扰或噪声影响的介质是（）。</h3><p>A. 双绞线 B. 光纤 C. 同轴电缆 D. 微波</p><h3 id="报文的内容不按顺序到达目的节点的是方式">27 ．报文的内容不按顺序到达目的节点的是（）方式。</h3><p>A. 电路交换 B. 报文交换 C.虚电路交换 D. 数据报交换</p><h3 id="在中继系统中中继器处于">28 ．在中继系统中，中继器处于（）。</h3><p>A. 物理层 B.数据链路层 C. 网络层 D. 高层</p><h3 id="关于时延说法正确的是">29 ． 关于时延说法正确的是（）。</h3><p>A. 发送时延=信道长度/电磁波在信道上的传播速度</p><p>B. 传播时延=数据块长度/信道带宽</p><p>C. 总时延=传播时延+发送时延+排队时延</p><p>D. 提高链路带宽减小了数据的传播时延</p><h3 id="下列说法错误的是">30 ． 下列说法错误的是（）。</h3><p>A. 在虚电路方式中，信息从源节点传送到目的节点采用“存储转发”方式</p><p>B. 在数据报方式中，信息从源节点传送到目的节点采用“存储转发”方式</p><p>C. 电路交换比分组交换实时性好</p><p>D. 报文交换方式适合交互式通信</p><h3 id="物理层传输的是">31 .物理层传输的是（）。</h3><p>A．原始比特 B.分组 C.信元 D.帧</p><h3 id="在电缆中采用屏蔽可以带来什么好处">32.在电缆中采用屏蔽可以带来什么好处？（）</h3><p>A．减少信号衰减 B.减少电磁干扰辐射</p><p>C．减少物理损坏 D.减少电缆的阻抗</p><h3 id="调制解调技术主要用于的通信方式中">33.调制解调技术主要用于（）的通信方式中。</h3><p>A．模拟信道传输数字数据 B.模拟信道传输模拟数据</p><p>C．数字信道传输数字数据 D.数字信道传输模拟数据</p><h3 id="下列说法中哪一项是正确的">34.下列说法中，哪一项是正确的？（）</h3><p>A．虚电路与线路交换没有实质不同</p><p>B．在通信的两个站点间只能建立一条虚电路</p><p>C．虚电路有连接建立，数据传输，连接拆除 3 个阶段</p><p>D．虚电路的各个结点需要为每个分组作路由选择判定</p><h3 id="当数字信号在模拟传输系统中传送时在发送端和接收端分别需要-1">35.当数字信号在模拟传输系统中传送时，在发送端和接收端分别需要（）。</h3><p>A．调制器和解调器 B解调器和调制器</p><p>C. 编码器和解码器 D解码器和编码器</p><h3id="物理层的-4-个特性中规定了每种信号的电平信号的脉冲宽度允许的数据传输速率和最大传输距离">36.物理层的 4个特性中，（）规定了每种信号的电平，信号的脉冲宽度，允许的数据传输速率和最大传输距离。</h3><p>A．机械特性 B电气特性 C功能特性 D规程特性</p><h3 id="为了将数字信号传输得更远可以采用的设备是">37.为了将数字信号传输得更远，可以采用的设备是（）。</h3><p>A．中继器 B放大器 C网桥 D路由器</p><h3id="在无噪声情况下若某通信链路的带宽为-3-khz采用-4-个相位每个相位具有-4-种振幅的qam调制技术则该通信链路的最大数据传输率是">38.在无噪声情况下，若某通信链路的带宽为 3 kHz，采用 4 个相位，每个相位具有4 种振幅的QAM调制技术，则该通信链路的最大数据传输率是（）</h3><p>A. 12 kbps B. 24 kbps C. 48 kbps D. 96 kbps</p><h3 id="传递需进行调制编码">39 .（）传递需进行调制编码。</h3><p>A.数字数据在数字信道上 B.数字数据在模拟信道上</p><p>C.模拟数据在数字信道上 D.模拟数据在模拟信道上</p><h3 id="数据传输速率公式s-tlog-2-n中t的含义是">40 .数据传输速率公式：S=Tlog 2 N中，T的含义是。</h3><p>A.单位脉冲幅度 B.单位脉冲宽度 C.信号传输速率 D.脉冲的有效值</p><h3 id="两个实体间数据传输和交换是">41 .两个实体间数据传输和交换是()</h3><p>A.数据通信 B.数据控制 C.数据传输 D.信息交换</p><h3 id="在多数情况下网络接口卡实现的功能包括">42.在多数情况下，网络接口卡实现的功能包括( )。</h3><p>A.物理层协议和数据链路层协议 B.物理层协议和网络层协议C.数据链路层协议 D.网络层协议</p><h3 id="下列说法哪一个是正确的">43 .下列说法哪一个是正确的</h3><p>A、当码元的离散值个数N= 2 ，则波特率等于比特率; B、 600 波特和 600bps是一个意思; C、每秒传送l 00 个码元也就是每秒传送 100 个比特; D、每秒50 波特的传输速率是很低的</p><h3 id="模拟通信系统中产生的调制信号一定是">44.模拟通信系统中产生的调制信号一定是（ ）。</h3><p>A.数字信号 B.连续信号 C.语音信号 D.离散信号</p><h3 id="用bps作单位的有多选">45 .用bps作单位的有(多选)</h3><p>A.位速率 B.波特率 C.数据传输率 D.误码率</p><h3 id="下列对基带传输和宽带传输的说法正确的是多选">46.下列对基带传输和宽带传输的说法正确的是(多选)</h3><p>A.基带传输是将数据直接转换为脉冲信号加到电缆上传输出去B.宽带传输是将数据加到载波信号上传送出去C.基带传输采用“控制载波信号状态”的传输技术D.在通信中，依据数据流的方向可以分为基带传输和宽带传输</p><h3 id="下述哪个说法是正确的">47 .下述哪个说法是正确的？</h3><p>(A)细同轴电缆传输速率最高。 (B) 光纤电缆支持电缆运行几十公里。 (C)屏蔽双绞线电缆对电磁干扰不敏感。 (D) 以上说法都不对。</p><h3 id="下述哪一个电缆类型支持最大的电缆长度">48.下述哪一个电缆类型支持最大的电缆长度？</h3><p>(A)无屏蔽双绞线(B)屏蔽双绞线(C)粗同轴电缆(D)细同轴电缆</p><h3 id="下述哪一个电缆类型支持最大的电缆长度-1">49.下述哪一个电缆类型支持最大的电缆长度？</h3><p>(A)无屏蔽双绞线 (B)屏蔽双绞线 (C)粗同轴电缆 (D)细同轴电缆</p>]]></content>
    
    
    <categories>
      
      <category>所有</category>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络习题_第一章_概述</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%A0%E9%A2%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%A0%E9%A2%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一选择题">一、选择题</h2><h3 id="以下不属于协议组成要素的是d">1.以下不属于协议组成要素的是（<code>D</code>）。</h3><p>A. 语法 B. 语义 C. 时序（同步） D. 字符</p><p>解析：网络协议组成要素：语法、语义、同步（时序）</p><h3 id="局域网的简称为a">2. 局域网的简称为（<code>A</code>）。</h3><p>A. LAN B. WAN C. CAN D. MAN</p><p>解析：</p><p>1.局域网(Local Area NetWork, LAN)，</p><p>2.城域网(Metropolitan Area NetWork, MAN)，</p><p>3.广域网(Wide Area NetWork, WAN)，</p><p>4.个人区域网(Personal Area NetWork, PAN)</p><h3 id="完成路径选择功能是在osi模型的c">3.完成路径选择功能是在OSI模型的（<code>C</code>）。</h3><p>A. 物理层 B. 数据链路层 C. 网络层 D. 传输层</p><p>解析：简单说明OSI参考模型中各个分层的主要作用</p><p>7.应用层：针对特定应用的协议</p><p>6.表示层：设备固有数据格式和网络标准数据格式的转换</p><p>5.会话层：通信管理，负责建立和断开通信连接，管理传输层以下的分层</p><p>4.管理两个节点之间的数据传输，负责可靠传输</p><p>3.网络层：地址管理和路由选择</p><p>2.数据链路层：互连设备之间传送和识别数据帧</p><p>1.物理层：以“0”、"1"代表电压的高低、灯光的闪灭，界定连接器和网线的规格</p><h3 id="osi参考模型将整个网络的功能划分d个层次">4.OSI参考模型将整个网络的功能划分（<code>D</code>）个层次</h3><p>（A） 1 （B） 3 （C） 5 （D） 7</p><h3 id="在同一个信道上的同一时刻能够进行双向数据传输的通信方式是c">5.在同一个信道上的同一时刻，能够进行双向数据传输的通信方式是（<code>C</code>）。</h3><p>A.单工 B.半双工 C.全双工 D.上述三种均不是</p><p>解析：</p><p><strong>单工</strong>数据传输只支持数据在一个方向上传输；<strong>半双工</strong>数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；<strong>全双工</strong>数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。</p><h3 id="tcpip体系结构中的tcp和ip所提供的服务分别为d">6.TCP/IP体系结构中的TCP和IP所提供的服务分别为(<code>D</code>)。</h3><p>A. 链路层服务和网络层服务 B. 网络层服务和传输层服务</p><p>C. 传输层服务和应用层服务 D. 传输层服务和网络层服务</p><p>解析：<strong>TCP/IP（Transmission Control Protocol/InternetProtocol，传输控制协议／网际协议）是指能够在多个不同网络间实现信息传输的协议簇。</strong></p><h3 id="用于不同网段的网络互连的设备一般采用c">7.用于不同网段的网络互连的设备一般采用（<code>C</code>）。</h3><p>A. 中继器 B. 交换机 C. 路由器 D. 网关</p><p>解析：主要用于实现两个不同网络互联的设备是路由器，路由器是负责不同广域网中各局域网之间的地址查找、信息包翻译和交换，实现计算机网络设备与通信设备的连接和信息传递，是实现局域网和广域网互联的主要设备。</p><h3 id="ip协议提供的服务是c">8.IP协议提供的服务是(<code>C</code>)。</h3><p>A. 可靠服务 B.有确认的服务</p><p>C. 不可靠无连接数据报服务 D. 以上都不对</p><p>解析：IP协议提供的服务类型是<strong>无连接的数据报服务</strong>。TCP提供<strong>面向连接的传输服务</strong></p><h3 id="把两个报文发往同一目的地时先发的报文c">9.把两个报文发往同一目的地时，先发的报文（<code>C</code>）</h3><p>（A）先到 （B）后到 （C）不一定先到 （D）同时到达</p><h3 id="数据链路层的数据单位称为-c">10. 数据链路层的数据单位称为（<code>C</code>）。</h3><p>A.比特 B.字节 C.帧 D.分组</p><h3id="在osi参考模型中实现端到端的应答分组排序和流量控制功能的协议层是c">11.在OSI参考模型中，实现端到端的应答、分组排序和流量控制功能的协议层是(<code>C</code>)。</h3><p>A. 数据链路层 B. 网络层 C. 传输层 D. 会话层</p><p>解析：传输层负责两个端节点之间的可靠网络通信和流量控制，即面向连接的通信，端到端的流量控制，差错控制。</p><h3id="在osi参考模型中对等实体在一次交互作用中传输的信息单位称为c它包括控制信息和用户数据两部分">12.在OSI参考模型中，对等实体在一次交互作用中传输的信息单位称为(<code>C</code>)，它包括控制信息和用户数据两部分。</h3><p>A. 接口数据单元 B. 服务数据单元</p><p>C. 协议数据单元 D. 交互数据单元</p><p>解析：在OSI参考模型中，对等实体在一次交互作用中传送的信息单位称为协议数据单元PDU，它包括控制信息和用户数据两部分。</p><h3 id="b是各层向其上层提供的一组操作">13.（<code>B</code>）是各层向其上层提供的一组操作</h3><p>（A）网络 （B）服务 （C）协议 （D）实体</p><p>解析：在网络体系结构中，服务就是网络中各层向其相邻上层提供的一组操作，是相邻两层之间的界面。由于网络分层结构中的单向依赖关系，使得网络中相邻层之间的界面也是单向性的：下层是服务提供者，上层是服务用户。</p><h3 id="internet的核心协议是b">14.Internet的核心协议是(<code>B</code>)</h3><p>A．X． 25 B．TCP／IP C．ICMP D．UDP</p><h3id="随着电信和信息技术的发展国际上出现了所谓三网融合的趋势下列不属于三网之一的是d">15.随着电信和信息技术的发展，国际上出现了所谓“三网融合”的趋势，下列不属于三网之一的是(<code>D</code>)</h3><p>A．传统电信网 B．计算机网(主要指互联网)</p><p>C．有线电视网 D．卫星通信网</p><p>解析：“三网”简单的来讲就是实现有线电视、电信以及计算机通信三者之间的融合</p><h3 id="下列属于internet服务的是d">16.下列属于Internet服务的是（<code>D</code>）。</h3><p>A 远程登录 B 电子邮件 C WWW D 以上全是</p><p>解析：<strong>Internet提供的服务有：</strong></p><ol type="1"><li><p>远程登录服务(Telnet)</p></li><li><p>文件传输服务(FTP)</p></li><li><p>电子邮件服务(E-Mail)</p></li><li><p>网络新闻服务(Usenet)</p></li><li><p>名址服务(Finger、Whois、X.500、Netfind)</p></li><li><p>文档查询索引服务(Archie、WAIS)</p></li><li><p>信息浏览服务(Gopher、WWW)</p></li><li><p>其它信息服务(Talk、IRC、MUD)</p></li></ol><h3 id="在osi参考模型中第n层与它之上的第n-1-层的关系是a">17.在OSI参考模型中，第N层与它之上的第N+ 1层的关系是（<code>A</code>）。</h3><p>A．第N层为第N+ 1 层提供服务 B．第N+ 1层将从第N层接收的报文添加一个报头 C．第N层使用第N+ 1 层提供的服务D．第N层与第N+ 1 层相互没有影响</p><h3 id="在osi参考模型中能实现路由选择拥塞控制与互联功能的层是c">18.在OSI参考模型中能实现路由选择，拥塞控制与互联功能的层是（<code>C</code>）。</h3><p>A．传输层 B．应用层 C．网络层 D．物理层</p><p>解析：传输层是向用户提供可靠的端对端服务。应用层是为应用程序提供网络服务，包含了各种用户普遍使用的应用层协议。网络层主要是实现路径选择、拥塞控制与互联功能。物理层是使原始的比特流能够在物理介质上传输。</p><h3 id="集线器和路由器分别运行于osi参考模型的d">19.集线器和路由器分别运行于OSI参考模型的（<code>D</code>）。</h3><p>A．数据链路层和物理层 B．网络层和传输层 C．传输层和数据链路层D．物理层和网络层</p><p>解析：物理层：（中继器，集线器） 数据链路： （网桥，交换机）网络层：（路由器） 传输层： (网关)</p><h3 id="osi参考模型将整个网络的功能分成-7-个层次来实现a">20.OSI参考模型将整个网络的功能分成 7个层次来实现，（<code>A</code>）。</h3><p>A．层与层之间的联系通过接口进行 B．层与层之间的联系通过协议进行C．各对等层之间通过协议进行通信D．除物理层以外，各对等层之间均存在直接的通信关系</p><p>解析：osi的划分层次的原则是: 1、网中各节点都有相同的层次。2、不同节点的同等层次具有相同的功能。3、同一节点能相邻层之间通过接口通信。4、每一层使用下层提供的服务，并向其上层提供服务。5、不同节点的同等层按照协议实现对等层之间的通信。</p><h3 id="计算机网络中广泛使用的交换技术是c">21.计算机网络中广泛使用的交换技术是（<code>C</code>）。</h3><p>A.信源交换 B.报文交换 C.分组交换 D.线路交换</p><h3 id="计算机网络中可以共享的资源包括a">22.计算机网络中可以共享的资源包括（<code>A</code>）。</h3><p>A.硬件、软件、数据 B.主机、外设、软件 C.硬件、程序、数据D.主机、程序、数据</p><p>解析：计算机网络中可以共享的资源包括：硬件、软件、数据、通信信道。资源共享是人们建立计算机网络的主要目的之一。计算机资源包括硬件资源、软件资源、数据资源和通信信道。</p><p>硬件资源的共享可以提高设备的利用率，避免设备的重复投资，如利用计算机网络建立网络打印机。</p><p>软件资源和数据资源的共享可以充分利用已有的信息资源，减少软件开发过程中的劳动，避免大型数据库的重复建设。</p><p>通信信道资源的共享就是将同一个信道供多个用户同时使用。</p><p>在实际工作中，经常会遇到多个用户(计算机或终端)要同时与一个主机相连。若每个用户都用独立的信道与主机相连，则往往要消耗很多的通信线路资源。因此，只要有可能，就应尽量采用信道共享。信道共享可以提高信道资源的利用率。</p><h3 id="osi环境下下层能向上层提供两种不同形式的服务是d">23.OSI环境下，下层能向上层提供两种不同形式的服务是（<code>D</code>）。</h3><p>A.面对连接的服务与面向对象的服务 B.面向对象的服务与无连接的服务C.面向对象的服务与面向客户的服务 D.面对连接的服务与无连接的服务</p><h3 id="早期的计算机网络系统是由d组成">24.早期的计算机网络系统是由(<code>D</code>)组成。</h3><p>A计算机一通讯线路一计算机 B.Pc_通讯线路一PC机 C.终端一通讯线路一终端D.计算机一通讯线路一终端</p><h3 id="计算机网络可分为三类它们是d">25.计算机网络可分为三类，它们是（<code>D</code>）。</h3><p>A.Internet、Intranet、Extranet B.广播式网络、移动网络、点-点式网络C.X. 25 、ATM、B-ISDN D.LAN、MAN、WAN</p><h3 id="把计算机网络分为局域网和广域网其分类依据是a">26.把计算机网络分为局域网和广域网，其分类依据是（<code>A</code>）。</h3><p>A.网络的地理覆盖范围 B.网络的传输介质</p><p>C.网络的拓扑结构 D.网络的成本价格</p><h3 id="下列哪一项不是组成计算机网络必须的设备d">27.下列哪一项不是组成计算机网络必须的设备（<code>D</code>）。</h3><p>A、计算机系统 B、网络适配器 C、传输介质 D、网络打印机</p><h3 id="下列选项中不属于网络体系结构所描述的内容是c">28.下列选项中，不属于网络体系结构所描述的内容是（<code>C</code>）。</h3><p>A.网络的层次 B.每一层使用的协议</p><p>C.协议的内部实现细节 D.每一层必须完成的功能</p><p>解析：计算机网络的各层及其协议的集合称为体系结构，分层就涉及到对各层功能的划分，因此A、B、D正确。体系结构是抽象的，它不包括各层协议的具体实现细节。《计算机网络》中在讲解网络层次时，仅有讲各层的协议和功能，而内部实现细节则没有提及。内部实现细节是由具体设备厂家来确定的。</p><h3 id="在osi参考模型中自下而上第一个提供端到端服务的层次是b">29.在OSI参考模型中，自下而上第一个提供端到端服务的层次是（<code>B</code>）。</h3><p>A.数据链路层 B.传输层 C.会话层 D.应用层</p><h2 id="二综合应用题">二、综合应用题</h2><h3 id="计算机网络的发展可划分为几个阶段每个阶段各有何特点">1.计算机网络的发展可划分为几个阶段?每个阶段各有何特点?</h3><ol type="1"><li>第一阶段：(20 世纪 60 年代)以单个计算机为中心的面向终端的计算机网络系统。这种网络系统是以批处理信息为主要目的。它的缺点是：如果计算机的负荷较重，会导致系统响应时间过长；单机系统的可靠性一般较低，一旦计算机发生故障，将导致整个网络系统的瘫痪。</li><li>第二阶段：(20 世纪 70 年代)以分组交换网为中心的多主机互连的计算机网络系统。分组交换技术的出现，不仅大大推动了当时的计算机网络技术的发展，而且也是现代计算机网络技术发展的重要基础。</li><li>第三阶段：(20 世纪 80 年代)具有统一的网络体系结构，遵循国际标准化协议的计算机网络。这些网络体系结构的出现，使得一个公司生产的各种类型的计算机和网络设备可以非常方便地进行互连。</li><li>第四阶段：(20 世纪 90 年代)网络互连与高速网络。进入 20 世纪 90年代后， 网络进一步向着开放、高速、高性能方向发展。</li></ol><h3 id="试从多个方面比较电线路交换报文交换和分组交换的主要优缺点">2.试从多个方面比较电（线）路交换、报文交换和分组交换的主要优缺点。</h3><ol type="1"><li><p>电路交换，它的主要特点是：</p><ul><li><p>① 在通话的全部时间内用户独占分配的传输线路或信道带宽，即采用的是静态分配策略；</p></li><li><p>② 通信双方建立的通路中任何一点出现了故障，就会中断通话，必须重新拨号建立连接，方可继续，这对十分紧急而重要的通信是不利的。显然，这种交换技术适应模拟信号的数据传输。然而在计算机网络中还可以传输数字信号。数字信号通信与模拟信号通信的本质区别在于数字信号的离散性和可存储性。这些特性使得它在数据传输过程中不仅可以间断分时发送，而且可以进行再加工、再处理。</p></li><li><p>③ 计算机数据的产生往往是“突发式”的，比如当用户用键盘输入数据和编辑文件时，或计算机正在进行处理而未得出结果时，通信线路资源实际上是空闲的，从而造成通信线路资源的极大浪费。</p></li></ul></li><li><p>分组交换具有高效、灵活、可靠等优点。但传输时延较电路交换要大，不适用于实时数据业务的传输。</p></li><li><p>报文交换传输时延最大。</p></li></ol><h3 id="计算机网络可从哪几个方面进行分类">3.计算机网络可从哪几个方面进行分类？</h3><ol type="1"><li>按交换方式：有电路交换、报文交换、分组交换、帧中继交换、信元交换等。</li><li>按拓扑结构：有集中式网络、分散式网络、分布式网络。其中，集中式网络的特点是网络信息流必须经过中央处理机或网络交换节点(如星形拓扑 32结构)；分布式网络的特点是任何一个节点都至少和其他两个节点直接相连(如网状形拓扑结构)，是主干网常采用的一种结构；分散式网络实际上是星形网和网状形网的混合网。</li><li>按作用范围：有广域网(WAN)、局域网(LAN)、城域网(MAN)。其中，广域网的作用范围为几十至几千公里，又称为远程网；局域网的作用范围常限制在一个单位或一个校园(1 km)内，但数据传输速率高(10 Mb/s 以上)；城域网常介于广域网和局域网之间，局限在一个城市(5～50 km)内。</li><li>按使用范围：有公用网和专用网。其中，公用网都是由国家的电信部门建造和控制管理的；专用网是某个单位或部门为本系统的特定业务需要而建造的，不对单位或部门以外的人员开放</li></ol><h3 id="面向连接服务与无连接报务各自的特点是什么">4.面向连接服务与无连接报务各自的特点是什么？</h3><p>​ 所谓连接，就是两个对等实体为进行数据通信而进行的一种结合。面向连接服务是在数据交换之前，必须先建立连接。当数据交换结束后，则应终止这个连接。</p><p>​ 面向连接服务具有连接建立、数据传输和连接释放这三个阶段。在传送数据时按序传送的。因面面向连接服务提供可靠的数据传输服务。在无连接服务的情况下，两个实体之间的通信不需要先建立好一个连接，因此其下层的有关资源不需要事先进行预留。这些资源在数据传输时动态地进行分配。</p><p>​ 无连接服务的另一特征是它不需要通信的两个实体同时期是活跃的（即处于激活态）。当发送端有实体正在进行发送时，它才是活跃的。这时接收端的实体并不一定必须是活跃的。只有当接收端的实体正在进行接收时，它才必须是活跃的。</p><p>​ 无连接服务的优点是灵活方便和比较迅速。但无连接服务不能防止报文的丢失、重复或失序。无连接服务特别适合于传送少量零星的报文。</p><h3 id="协议与服务有何区别有何关系">5.协议与服务有何区别？有何关系？</h3><ul><li><p>网络协议：为进行网络中的数据交换而建立的规则、标准或约定。由以下三个要素组成：</p><ul><li><p>（1）语法：即数据与控制信息的结构或格式。</p></li><li><p>（2）语义：即需要发出何种控制信息，完成何种动作以及做出何种响应。</p></li><li><p>（3）同步：即事件实现顺序的详细说明。</p></li></ul></li><li><p>协议是控制两个对等实体进行通信的规则的集合。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务，而要实现本层协议，还需要使用下面一层提供服务。 协议和服务的概念的区分：</p><ul><li>1、协议的实现保证了能够向上一层提供服务。本层的服务用户只能看见服务而无法看见下面的协议。下面的协议对上面的服务用户是透明的。</li><li>2、协议是“水平的”，即协议是控制两个对等实体进行通信的规则。但服务是“垂直的”，即服务是由下层通过层间接口向上层提供的。上层使用所提供的服务必须与下层交换一些命令，这些命令在OSI 中称为服务原语。</li></ul></li></ul><h3 id="试述五层协议的网络体系结构的要点包括各层的主要功能">6.试述五层协议的网络体系结构的要点，包括各层的主要功能。</h3><p>所谓五层协议的网络体系结构是为便于学习计算机网络原理而采用的综 合了OSI 七层模型和 TCP/IP 的四层模型而得到的五层模型。</p><p>各层的主要功能：</p><ul><li>（1）应用层：应用层确定进程之间通信的性质以满足用户的需要。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理（user agent),来完成一些为进行语义上有意义的信息交换所必须的功能。</li><li>(2）运输层：任务是负责主机中两个进程间的通信。因特网的运输层可使用两种不同的协议。即面向连接的传输控制协议 TCP和无连接的用户数据报协议 UDP。面向连接的服务能够提供可靠的交付。无连接服务则不能提供可靠的交付。只是 best-effort delivery.</li><li>(3)网络层：网络层负责为分组选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。</li><li>（4）数据链路层：数据链路层的任务是将在网络层交下来的数据报组装成帧（frame)，在两个相邻结点间的链路上实现帧的无差错传输。</li><li>（5）物理层：物理层的任务就是透明地传输比特流。“透明地传送比特流”指实际电路传送后比特流没有发生变化。物理层要考虑用多大的电压代表“1”或“0”，以及当发送端发出比特“1”时，接收端如何识别出这是“1”而不是“0”。物理层还要确定连接电缆的插头应当有多少根脚以及各个脚如何连接。</li></ul><h3 id="列出osi参考模型和tcpip参考模型的主要相同点和不同点">7.列出OSI参考模型和TCP/IP参考模型的主要相同点和不同点。</h3><ul><li>相同：都基于分层协议，都有网络层、传输层和应用层；传输服务都能提供可靠的端对端的字节流。</li><li>不同：层数目不同；TCP/IP 支持网络互连，OSI 不支持网络互连； TCP/IP网络 层只提供无连接的服务，OSI中既有面向连接的服务，也有无连接的服务。</li></ul><h3 id="简述什么是计算机网络的拓扑结构有哪些常见的拓扑结构">8.简述什么是计算机网络的拓扑结构，有哪些常见的拓扑结构。</h3><p>计算机网络的拓扑结构是指网络中通信线路和站点（计算机或设备）的几何排列形式。计算机网络按网络拓扑结构分，可分为星型网络、总线型网络、树型网络、环型网络和网状型网络</p><h3 id="什么是计算机网络">9. 什么是计算机网络?</h3><ul><li>a．为了方便用户，将分布在不同地理位置的计算机资源实现信息交流和资源的共享。</li><li><ol start="2" type="a"><li>计算机资源主要指计算机硬件、软件与数据。数据是信息的载体。</li></ol></li><li>c．计算机网络的功能包括网络通信、资源管理、网络服务、网络管理和互动操作的能力。</li><li>d．计算机网络技术是计算机技术与通信技术的结合，形成计算机网络的雏形。</li></ul><h3 id="计算机网络采用层次结构模型有什么好处">10.计算机网络采用层次结构模型有什么好处？</h3><p>层次结构能简化处理，使处理条理化。体现对复杂问题采取“分而治之”的模块化方法，降低复杂问题的处理难度，同一层次具有相同的处理功能。</p><h3 id="计算机网络与多终端分时系统分布式系统的主要区别是什么">11.计算机网络与多终端分时系统，分布式系统的主要区别是什么?</h3><ol type="1"><li>计算机网络与多终端分时系统的区别：计算机网络中的各个计算机(工作站)本身拥有计算资源，它能独立工作，完成一定的计算任务，同时用户还可通过本地计算机或工作站使用网络中其他计算机的资源(CPU、大容量外存或信息等)。而多终端分时系统终端(无论是本地的还是远程的)只是主机和用户之间的接口，它本身并不拥有计算资源，全部集中在主机中，主机以自己拥有的资源分时地为各终端用户服务。</li><li>计算机网络与分布式系统的区别：分布式系统在计算机网络基础上为用户提供了透明的集成应用环境，用户可以用名字或命令调用网络中的任何资源或进行远程的数据处理，不必计及这些资源或数据的地理位置。而计算机网络则往往不要求这种透明性，甲地的用户要利用乙地的计算机必须通过自己的终端显式地指定地点和设备名。分布式系统比计算机网络更为高级。</li><li>多机系统专指同一机房中的许多大型主机互连组成的功能强大、能高速并行处理的计算机系统。对这种系统互连的要求是高带宽和多样的连通性。计算机之间的通信速度能够达到访问主存的速度，即每秒达数十兆位。而计算机网络是远远达不到的，广域网的通信速率是每秒数十千位，局域网的通信速率是10Mb/s。计算机网络的传输开销较大，而多机系统的开销则是不必要的。多机系统要求多样灵活的连通性，即使做不到完全直接互边，也要求能够快速地变换互连模式经适应并行计算的要求，而计算机网络则由于距离的限制，在网络中的互连相当有限</li></ol><h3 id="在局域网中常用的规则型拓扑结构有哪些">13.在局域网中常用的规则型拓扑结构有哪些。</h3><p>答：星型、环型、总线型</p><h3 id="什么是多机系统">14. 什么是多机系统？</h3><p>多机系统专指同一机房中的许多大型主机互连组成的功能强大、能高速并行处理的计算机系统。对这种系统互连的要求是高带宽和多样的连通性。所谓高带宽就是要求计算机之间的通信速度能够达到访问主存的速度</p><h3id="因特网的两大组成部分边缘部分和核心部分的特点是什么它们的工作方式各有什么特点">15.因特网的两大组成部分（边缘部分和核心部分）的特点是什么？它们的工作方式各有什么特点？</h3><ul><li><p>边缘部分：由所有连接在因特网上的主机组成。由用户直接使用。</p></li><li><p>核心部分：由大量网络和连接这些网络的路由器组成，为边缘部分提供服务。</p></li></ul><p>工作方式：</p><ul><li><p>边缘部分：采用客户服务器方式和对等通信方式。</p></li><li><p>核心部分：主要采用分组交换技术。</p></li></ul><h3id="客户服务器方式与对等通信方式的主要区别是什么有没有相同的地方">16.客户服务器方式与对等通信方式的主要区别是什么，有没有相同的地方。</h3><table><thead><tr><th>区别</th><th>客户服务器方式</th><th>对等通信方式</th></tr></thead><tbody><tr><td>处理请求</td><td>一点对多点</td><td>点对点</td></tr><tr><td>服务器</td><td>有一个总是打开的主机称为 服务器</td><td>没有一个总是打开的主机称 为服务器</td></tr><tr><td>服务请求方与提 供方</td><td>客户是服务请求方，服务器是 服务提供方</td><td>任意一对主机成为对等方， 不作区分</td></tr><tr><td>IP 地址</td><td>服务器具有固定、周知的 IP 地址。</td><td>参与的主机IP地址可以改变</td></tr></tbody></table><p>相同之处：二者所描述的都是进程之间服务和被服务的关系。</p><h3id="解释以下名词协议栈实体对等层协议数据单元服务访问点客户服务器客户-服务器方式">17.解释以下名词：协议栈、实体、对等层、协议数据单元、服务访问点、客户、服务器、客户-服务器方式</h3><ul><li>协议栈：协议栈是指网络中各层协议的总和</li><li>实体：任何可发送或接收信息的硬件或软件进程。</li><li>对等层：不同机器的同一层。</li><li>协议数据单元：在 OSI 参考模型中，对等层之间传送的数据单位。服务访问点（SAP）：在同一系统中相邻两层的实体进行交互（即交换信息）的地方。</li><li>客户和服务器指通信中所涉及的两个应用进程，客户-服务器方式描述的是进程之间服务与被服务的关系。客户首先发起连接建立请求，而服务器接收连接建立请求。</li></ul>]]></content>
    
    
    <categories>
      
      <category>所有</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux实验1-系统安装与基本使用</title>
    <link href="/Linux/Linux%E5%AE%9E%E9%AA%8C1-%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/Linux/Linux%E5%AE%9E%E9%AA%8C1-%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="linux系统实验报告">《Linux系统》实验报告</h2><p>Ø 课 程 Linux系统与大数据应用</p><p>Ø 实验名称 实验 1 系统安装与基本使用</p><p>Ø 专 业 计算机科学与技术</p><p>Ø 班 级 1901</p><p>Ø 姓 名 黄江涛</p><p>Ø 学 号 191310630</p><p>Ø 完成报告日期 2021/9/9</p><h3 id="一实验内容"><strong>一、实验内容</strong></h3><h5id="linux系统的安装在vmware的虚拟机上安装ubuntu系统">（1）Linux系统的安装，在VMware的虚拟机上安装Ubuntu系统。</h5><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/clip_image002.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h5 id="系统桌面环境的安装与使用">（2）系统桌面环境的安装与使用。</h5><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210910104619592.png"alt="image-20210910104619592" /><figcaption aria-hidden="true">image-20210910104619592</figcaption></figure><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210910104626676.png"alt="image-20210910104626676" /><figcaption aria-hidden="true">image-20210910104626676</figcaption></figure><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210910104639945.png"alt="image-20210910104639945" /><figcaption aria-hidden="true">image-20210910104639945</figcaption></figure><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210910104644140.png"alt="image-20210910104644140" /><figcaption aria-hidden="true">image-20210910104644140</figcaption></figure><p>重启系统之后显示安装成功</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210910104710149.png"alt="image-20210910104710149" /><figcaption aria-hidden="true">image-20210910104710149</figcaption></figure><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210910104714671.png"alt="image-20210910104714671" /><figcaption aria-hidden="true">image-20210910104714671</figcaption></figure><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210910104722689.png"alt="image-20210910104722689" /><figcaption aria-hidden="true">image-20210910104722689</figcaption></figure><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210910104727652.png"alt="image-20210910104727652" /><figcaption aria-hidden="true">image-20210910104727652</figcaption></figure><h5id="字符终端之间以及与桌面之间的切换">（3）字符终端之间以及与桌面之间的切换。</h5><p>字符界面1：</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210910104746113.png"alt="image-20210910104746113" /><figcaption aria-hidden="true">image-20210910104746113</figcaption></figure><p>字符界面3：</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210910104801812.png"alt="image-20210910104801812" /><figcaption aria-hidden="true">image-20210910104801812</figcaption></figure><p>返回图形界面：</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210910105026221.png"alt="image-20210910105026221" /><figcaption aria-hidden="true">image-20210910105026221</figcaption></figure><h5 id="关闭和启动系统">（4）关闭和启动系统。</h5><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210910105032354.png"alt="image-20210910105032354" /><figcaption aria-hidden="true">image-20210910105032354</figcaption></figure><h5 id="目录相对地址的使用">（5）目录相对地址的使用。</h5><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210910105036166.png"alt="image-20210910105036166" /><figcaption aria-hidden="true">image-20210910105036166</figcaption></figure><h5 id="使用-echo命令">（6）使用 echo命令。</h5><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210910105040479.png"alt="image-20210910105040479" /><figcaption aria-hidden="true">image-20210910105040479</figcaption></figure><h5 id="使用管道">（7）使用管道。</h5><h5 id="使用命令显示文件的内容">（8）使用命令显示文件的内容。</h5><h5 id="使用vi或vim编辑器">（9）使用vi或vim编辑器。</h5><h5 id="使用-uname命令显示计算机及操作系统相关信息">（10）使用uname命令显示计算机及操作系统相关信息。</h5><h5 id="使用-hostname命令显示或修改计算机主机名">（11）使用hostname命令显示或修改计算机主机名。</h5><h5 id="使用-ls-命令显示文件的属性">（12）使用 ls命令显示文件的属性。</h5><h5id="命令的排列可同时按先后顺序执行两个命令">（13）命令的排列，可同时按先后顺序执行两个命令。</h5><h5 id="使用通配符">（14）使用通配符。</h5><h5 id="使用-tab-键">（15）使用 Tab 键。</h5><h5 id="退出当前用户的命令">（16）退出当前用户的命令。</h5>]]></content>
    
    
    <categories>
      
      <category>所有</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法学习-排序算法</title>
    <link href="/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="排序算法">排序算法</h3><blockquote><p>所谓排序，就是使一串记录按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。</p></blockquote><h4 id="排序算法的分类">排序算法的分类</h4><p>排序算法可以按如下图分类：</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210830172540795.png"alt="image-20210830172540795" /><figcaption aria-hidden="true">image-20210830172540795</figcaption></figure><h4 id="各算法时间复杂度">各算法时间复杂度</h4><p>各个算法所对应的时间复杂度如下图</p><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/849589-20180402133438219-1946132192.png" /></p><h4 id="冒泡排序">冒泡排序</h4><h5 id="算法介绍">算法介绍</h5><p>冒泡排序需要重复的走访要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有需要交换，也就是说数组已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h5 id="算法描述">算法描述</h5><ol type="1"><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol>]]></content>
    
    
    <categories>
      
      <category>所有</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法学习-概述</title>
    <link href="/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%A6%82%E8%BF%B0/"/>
    <url>/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="算法学习">算法学习</h3><ul><li><h4 id="排序算法学习-排序算法01---江客">排序：<ahref="http://localhost:4000/算法/算法学习-排序算法01/">算法学习-排序算法01- 江客</a></h4></li><li><h4 id="双指针">双指针</h4></li><li><h4 id="查找">查找</h4></li><li><h4 id="分治">分治</h4></li><li><h4 id="动态规划">动态规划</h4></li><li><h4 id="递归">递归</h4></li><li><h4 id="回溯">回溯</h4></li><li><h4 id="贪心">贪心</h4></li><li><h4 id="位运算">位运算</h4></li><li><h4 id="深度优先搜索">深度优先搜索</h4></li><li><h4 id="广度优先搜索">广度优先搜索</h4></li><li><h4 id="图">图</h4></li></ul>]]></content>
    
    
    <categories>
      
      <category>所有</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习笔记04</title>
    <link href="/%E6%89%80%E6%9C%89/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004/"/>
    <url>/%E6%89%80%E6%9C%89/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004/</url>
    
    <content type="html"><![CDATA[<h3 id="索引">索引</h3><p>索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制。一张表的一个字段可以添加一个索引，当然，多个字段联合起来也可以添加索引。索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制。</p><p>对于一本字典来说，查找某个汉字有两种方式：</p><blockquote><p>第一种方式：一页一页挨着找，直到找到为止，这种查找方式属于全字典扫描。效率比较低。第二种方式：先通过目录（索引）去定位一个大概的位置，然后直接定位到这个位置，做局域性扫描，缩小扫描的范围，快速的查找。这种查找方式属于通过索引检索，效率较高。</p></blockquote><p>MySQL在查询方面主要就是两种方式：</p><ul><li>第一种方式：全表扫描</li><li>第二种方式：根据索引检索。</li></ul><blockquote><p>注意： 在实际中，汉语字典前面的目录是排序的，按照a b c d ef....排序，为什么排序呢？因为只有排序了才会有区间查找这一说！（缩小扫描范围其实就是扫描某个区间罢了！）</p></blockquote><h4 id="索引的数据结构">索引的数据结构</h4><p>在mysql数据库当中索引也是需要排序的，并且这个所以的排序和TreeSet数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！在mysql当中索引是一个B-Tree数据结构。</p><p>遵循左小又大原则存放。采用中序遍历方式遍历取数据。</p><h4 id="索引的实现原理">索引的实现原理</h4><p>假设有一张用户表：t_user</p><table><thead><tr><th style="text-align: center;">id(PK)</th><th style="text-align: center;">name</th><th style="text-align: center;">硬盘物理存储编号</th></tr></thead><tbody><tr><td style="text-align: center;">100</td><td style="text-align: center;">zhangsan</td><td style="text-align: center;">0x1111</td></tr><tr><td style="text-align: center;">120</td><td style="text-align: center;">lisi</td><td style="text-align: center;">0x2222</td></tr><tr><td style="text-align: center;">99</td><td style="text-align: center;">wangwu</td><td style="text-align: center;">0x8888</td></tr><tr><td style="text-align: center;">88</td><td style="text-align: center;">zhaoliu</td><td style="text-align: center;">0x9999</td></tr><tr><td style="text-align: center;">101</td><td style="text-align: center;">jack</td><td style="text-align: center;">0x6666</td></tr><tr><td style="text-align: center;">55</td><td style="text-align: center;">lucy</td><td style="text-align: center;">0x5555</td></tr><tr><td style="text-align: center;">130</td><td style="text-align: center;">tom</td><td style="text-align: center;">0x7777</td></tr></tbody></table><ul><li><p>提醒1：在任何数据库当中主键上都会自动添加索引对象，id字段上自动有索引，因为id是PK。另外在mysql当中，一个字段上如果有unique约束的话，也会自动创建索引对象。</p></li><li><p>提醒2：在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号。</p></li><li><p>提醒3：在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，MyISAM存储引擎中，索引存储在一个.MYI文件中。在InnoDB存储引擎中索引存储在一个逻辑名称叫做tablespace的当中。在MEMORY存储引擎当中索引被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个树的形式存在。（自平衡二叉树：B-Tree）</p></li></ul><p>在mysql当中，主键上，以及unique字段上都会自动添加索引的！！！！</p><h4 id="添加索引的条件">添加索引的条件</h4><ol type="1"><li>条件1：数据量庞大（到底有多么庞大算庞大，这个需要测试，因为每一个硬件环境不同）+</li><li>条件2：该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段总是被扫描。</li><li>条件3：该字段很少的DML(insert deleteupdate)操作。（因为DML之后，索引需要重新排序。）</li></ol><p>建议不要随意添加索引，因为索引也是需要维护的，太多的话反而会降低系统的性能。建议通过主键查询，建议通过unique约束的字段进行查询，效率是比较高的。</p><h4 id="索引的创建与删除">索引的创建与删除</h4><p>创建索引：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> emp_ename_index <span class="hljs-keyword">on</span> emp(ename);<br>给emp表的ename字段添加索引，起名：emp_ename_index<br></code></pre></td></tr></table></figure><p>删除索引：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> emp_ename_index <span class="hljs-keyword">on</span> emp;<br>将emp表上的emp_ename_index索引对象删除。<br></code></pre></td></tr></table></figure><h4 id="索引失效">索引失效</h4><h5 id="失效的第1种情况">失效的第1种情况：</h5><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%T&#x27;</span>;<br></code></pre></td></tr></table></figure><p>ename上即使添加了索引，也不会走索引，为什么？原因是因为模糊匹配当中以“%”开头了！ 尽量避免模糊查询的时候以“%”开始。这是一种优化的手段/策略。</p><h5 id="失效的第2种情况">失效的第2种情况：</h5><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename = <span class="hljs-string">&#x27;KING&#x27;</span> <span class="hljs-keyword">or</span> job = <span class="hljs-string">&#x27;MANAGER&#x27;</span>;<br></code></pre></td></tr></table></figure><p>使用or的时候会失效，如果使用or那么要求or两边的条件字段都要有索引，才会走索引，如果其中一边有一个字段没有索引，那么另一个字段上的索引也会失效。所以这就是为什么不建议使用or的原因。</p><h5 id="失效的第3种情况">失效的第3种情况：</h5><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> emp_job_sal_index <span class="hljs-keyword">on</span> emp(job,sal);<br>mysql&gt; <span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> job = <span class="hljs-string">&#x27;MANAGER&#x27;</span>;<br></code></pre></td></tr></table></figure><p>使用复合索引的时候，没有使用左侧的列查找，索引失效 什么是复合索引？两个字段，或者更多的字段联合起来添加一个索引，叫做复合索引。</p><h5 id="失效的第4种情况">失效的第4种情况：</h5><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> emp_sal_index <span class="hljs-keyword">on</span> emp(sal);<br>mysql&gt; <span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal+<span class="hljs-number">1</span> = <span class="hljs-number">800</span>;<br></code></pre></td></tr></table></figure><p>在where当中索引列参加了运算，索引失效。 mysql&gt; create indexemp_sal_index on emp(sal);</p><h5 id="失效的第5种情况">失效的第5种情况：</h5><pre><code class="hljs">explain select * from emp where lower(ename) = &#39;smith&#39;;</code></pre><p>在where当中索引列使用了函数</p><h5 id="失效的第6...">失效的第6...</h5><h5 id="失效的第7...">失效的第7...</h5><h4 id="索引的分类">索引的分类</h4><ul><li>单一索引：一个字段上添加索引。</li><li>复合索引：两个字段或者更多的字段上添加索引。</li><li>主键索引：主键上添加索引。</li><li>唯一性索引：具有unique约束的字段上添加索引。</li><li>.....</li></ul><p>注意：唯一性比较弱的字段上添加索引用处不大。</p><h3 id="视图">视图</h3><p>view:站在不同的角度去看待同一份数据。</p><p>创建视图对象：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> dept2_view <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> dept2;<br></code></pre></td></tr></table></figure><p>删除视图对象：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">drop</span> <span class="hljs-built_in">view</span> dept2_view;<br></code></pre></td></tr></table></figure><p>注意：只有DQL语句才能以view的形式创建。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> view_name <span class="hljs-keyword">as</span> 这里的语句必须是DQL语句;<br></code></pre></td></tr></table></figure><h4 id="视图的操作">视图的操作</h4><p>我们可以面向视图对象进行增删改查，对视图对象的增删改查，会导致原表被操作！（视图的特点：通过对视图的操作，会影响到原表数据。）</p><p>//面向视图查询</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> dept2_view; <br></code></pre></td></tr></table></figure><p>// 面向视图插入</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> dept2_view(deptno,dname,loc) <span class="hljs-keyword">values</span>(<span class="hljs-number">60</span>,<span class="hljs-string">&#x27;SALES&#x27;</span>, <span class="hljs-string">&#x27;BEIJING&#x27;</span>);<br></code></pre></td></tr></table></figure><p>// 查询原表数据</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> dept2;<br></code></pre></td></tr></table></figure><p>// 面向视图删除</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">mysql&gt; <span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> dept2_view;<br></code></pre></td></tr></table></figure><p>// 查询原表数据</p><pre><code class="hljs">mysql&gt; select * from dept2;Empty set (0.00 sec)</code></pre><p>// 创建视图对象</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> <br>emp_dept_view<br><span class="hljs-keyword">as</span><br><span class="hljs-keyword">select</span> <br><span class="hljs-built_in">e</span>.ename,<span class="hljs-built_in">e</span>.sal,d.dname<br><span class="hljs-keyword">from</span><br>emp <span class="hljs-built_in">e</span><br><span class="hljs-keyword">join</span><br>dept d<br><span class="hljs-keyword">on</span><br><span class="hljs-built_in">e</span>.deptno = d.deptno;<br></code></pre></td></tr></table></figure><p>// 查询视图对象</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp_dept_view;<br></code></pre></td></tr></table></figure><p>// 面向视图更新</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">update</span> emp_dept_view <span class="hljs-keyword">set</span> sal = <span class="hljs-number">1000</span> <span class="hljs-keyword">where</span> dname = <span class="hljs-string">&#x27;ACCOUNTING&#x27;</span>;<br></code></pre></td></tr></table></figure><p>// 原表数据被更新</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><h4 id="视图的作用">视图的作用</h4><blockquote><p>方便，简化开发，利于维护</p></blockquote><p>假设有一条非常复杂的SQL语句，而这条SQL语句需要在不同的位置上反复使用。每一次使用这个sql语句的时候都需要重新编写，很长，很麻烦，怎么办？可以把这条复杂的SQL语句以视图对象的形式新建。在需要编写这条SQL语句的位置直接使用视图对象，可以大大简化开发。并且利于后期的维护，因为修改的时候也只需要修改一个位置就行，只需要修改视图对象所映射的SQL语句。</p><p>面向视图开发的时候，使用视图的时候可以像使用table一样。可以对视图进行增删改查等操作。视图不是在内存当中，视图对象也是存储在硬盘上的，不会消失。</p><p>视图对应的语句只能是DQL语句。但是视图对象创建完成之后，可以对视图进行增删改查等操作。</p><h4 id="增删改查crud">增删改查（CRUD）</h4><ul><li>C:Create（增）<br /></li><li>R:Retrive（查：检索）</li><li>U:Update（改）<br /></li><li>D:Delete（删）</li></ul><h3 id="dba常用命令">DBA常用命令</h3><ul><li><h4 id="数据导出">数据导出</h4><ul><li><p>导出数据库到D盘</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">mysqldump xxxxxx&gt;D:<span class="hljs-string">\xxxxxx.sql</span> -uyourname -pyourpassword<br></code></pre></td></tr></table></figure></li><li><p>导出数据库指定的表到D盘</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">mysqldump xxxxxx yourtable&gt;D:<span class="hljs-string">\xxxxxx.sql</span> -uyourname -pyourpassword<br></code></pre></td></tr></table></figure></li></ul></li><li><h4 id="数据导入">数据导入</h4><ul><li><p>登录到mysql数据库服务器上</p></li><li><p>创建数据库xxxxxx</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> xxxxxx;<br></code></pre></td></tr></table></figure></li><li><p>使用数据库xxxxxx</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">use</span> xxxxxx<br></code></pre></td></tr></table></figure></li><li><p>使用D盘下的sql文件初始化数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> D:\xxxxxx.sql<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="数据库设计三范式">数据库设计三范式</h3><ul><li>第一范式：要求任何一张表必须有主键，每一个字段原子性不可再分。</li><li>第二范式：建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，不要产生部分依赖。</li><li>第三范式：建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，不要产生传递依赖。</li></ul><p>设计数据库表的时候，按照以上的范式进行，可以避免表中数据的冗余，空间的浪费。</p><h4 id="第一范式">第一范式</h4><blockquote><p>最核心，最重要的范式，所有表的设计都需要满足。必须有主键，并且每一个字段都是原子性不可再分。</p></blockquote><h4 id="第二范式">第二范式</h4><blockquote><p>建立在第一范式的基础之上，要求所有非主键字段必须完全依赖主键，不要产生部分依赖。</p></blockquote><h4 id="第三范式">第三范式</h4><blockquote><p>第三范式建立在第二范式的基础之上要求所有非主键字典必须直接依赖主键，不要产生传递依赖。</p></blockquote><h3 id="表的设计">表的设计</h3><ul><li>一对多：一对多，两张表，多的表加外键！</li><li>多对多：多对多，三张表，关系表两个外键！</li><li>一对一：一张表字段太多，太庞大。这个时候要拆分表。一对一，外键唯一！</li></ul><h4 id="总结">总结</h4><blockquote><p>数据库设计三范式是理论上的。实践和理论有的时候有偏差。</p></blockquote><p>最终的目的都是为了满足客户的需求，有的时候会拿冗余换执行速度。</p><p>因为在sql当中，表和表之间连接次数越多，效率越低。（笛卡尔积）</p><p>有的时候可能会存在冗余，但是为了减少表的连接次数，这样做也是合理的，</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习笔记03</title>
    <link href="/%E6%89%80%E6%9C%89/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003/"/>
    <url>/%E6%89%80%E6%9C%89/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003/</url>
    
    <content type="html"><![CDATA[<h3 id="删除表中数据">删除表中数据</h3><h4 id="使用delete属于dml语句">使用delete（属于DML语句）</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//删除dept_bak表中的数据</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> dept_bak; <span class="hljs-comment">//这种删除数据的方式比较慢。</span><br></code></pre></td></tr></table></figure><p>特点：</p><ul><li>表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放！！！</li><li>这种删除缺点是：删除效率比较低。</li><li>这种删除优点是：支持回滚，后悔了可以再恢复数据！！！</li></ul><h4 id="使用truncate属于ddl操作">使用truncate（属于DDL操作）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> dept_bak;<br></code></pre></td></tr></table></figure><p>特点：</p><ul><li>这种删除效率比较高，表被一次截断，物理删除。</li><li>这种删除缺点：不支持回滚。</li><li>这种删除优点：快速。</li></ul><blockquote><p>如何选择：大表非常大，上亿条记录？？？？删除的时候，使用delete，也许需要执行1个小时才能删除完！效率较低。可以选择使用truncate删除表中的数据。只需要不到1秒钟的时间就删除结束。效率较高。但是使用truncate之前，必须仔细询问客户是否真的要删除，并警告删除之后不可恢复！</p></blockquote><h3 id="约束">约束</h3><h4 id="概念">概念</h4><p>约束对应的英语单词：constraint。在创建表的时候，我们可以给表中的字段加上一些约束，来保证这个表中数据的完整性、有效性！！！</p><p>约束的作用就是为了保证：表中的数据有效！！</p><h4 id="分类">分类</h4><ol type="1"><li>非空约束：not null</li><li>唯一性约束: unique</li><li>主键约束: primary key （简称PK）</li><li>外键约束：foreign key（简称FK）</li><li>检查约束：check（mysql不支持，oracle支持）</li></ol><h4 id="介绍">介绍</h4><ol type="1"><li><p>非空约束</p><p>not null约束的字段不能为NULL。</p></li><li><p>唯一性约束: unique</p><p>unique约束的字段不能重复，但是可以为NULL。</p><p>表级约束</p><p>需要给多个字段联合起来添加某一个约束的时候，需要使用表级约束。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_vip(<br>id <span class="hljs-type">int</span>,<br><span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>email <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br><span class="hljs-keyword">unique</span>(<span class="hljs-type">name</span>,email) // 约束没有添加在列的后面，这种约束被称为表级约束。<br>);<br></code></pre></td></tr></table></figure></li><li><p>主键约束</p><p>主键约束：就是一种约束。主键字段：该字段上添加了主键约束，这样的字段叫做：主键字段主键值：主键字段中的每一个值都叫做：主键值。</p><p>主键值是每一行记录的唯一标识。 主键值是每一行记录的身份证号！！！</p><p>记住：任何一张表都应该有主键，没有主键，表无效！！</p><p>主键的特征：not null +unique（主键值不能是NULL，同时也不能重复！）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-number">1</span>个字段做主键，叫做：单一主键<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_vip(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary key</span>,  //列级约束<br><span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>);<br></code></pre></td></tr></table></figure><p>表级约束主要是给多个字段联合起来添加约束</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// id和<span class="hljs-type">name</span>联合起来做主键：复合主键！！！！<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_vip(<br>id <span class="hljs-type">int</span>,<br><span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>email <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br><span class="hljs-keyword">primary key</span>(id,<span class="hljs-type">name</span>)<br>);<br></code></pre></td></tr></table></figure><blockquote><p>在实际开发中不建议使用：复合主键。建议使用单一主键！因为主键值存在的意义就是这行记录的身份证号，只要意义达到即可，单一主键可以做到。复合主键比较复杂，不建议使用！！！</p></blockquote><p>一张表，主键约束只能添加1个。（主键只能有1个。）</p><p>主键值建议使用：int、bigint、char等类型。</p><p>不建议使用：varchar来做主键。主键值一般都是数字，一般都是定长的！</p></li><li><p>外键约束</p><p>外键约束：一种约束（foreign key） 外键字段：该字段上添加了外键约束外键值：外键字段当中的每一个值。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus">t_class 班级表<br><span class="hljs-function"><span class="hljs-title">classno</span><span class="hljs-params">(pk)</span></span>classname<br>------------------------------------------------------<br><span class="hljs-number">100</span>北京市大兴区亦庄镇第二中学高三<span class="hljs-number">1</span>班<br><span class="hljs-number">101</span>北京市大兴区亦庄镇第二中学高三<span class="hljs-number">1</span>班<br>   <br>t_student 学生表<br><span class="hljs-function"><span class="hljs-title">no</span><span class="hljs-params">(pk)</span></span>name<span class="hljs-built_in">cno</span>(FK引用t_class这张表的classno)<br>----------------------------------------------------------------<br><span class="hljs-number">1</span>jack<span class="hljs-number">100</span><br><span class="hljs-number">2</span>lucy<span class="hljs-number">100</span><br><span class="hljs-number">3</span>lilei<span class="hljs-number">100</span><br><span class="hljs-number">4</span>hanmeimei<span class="hljs-number">100</span><br><span class="hljs-number">5</span>zhangsan<span class="hljs-number">101</span><br><span class="hljs-number">6</span>lisi<span class="hljs-number">101</span><br><span class="hljs-number">7</span>wangwu<span class="hljs-number">101</span><br><span class="hljs-number">8</span>zhaoliu<span class="hljs-number">101</span><br></code></pre></td></tr></table></figure><p>当cno字段没有任何约束的时候，可能会导致数据无效。可能出现一个102，但是102班级不存在。所以为了保证cno字段中的值都是100和101，需要给cno字段添加外键约束。那么：cno字段就是外键字段。cno字段中的每一个值都是外键值。</p><p>注意： t_class是父表 t_student是子表</p><p>​ 删除表的顺序？ ​ 先删子，再删父。</p><p>​ 创建表的顺序？ ​ 先创建父，再创建子。</p><p>​ 删除数据的顺序？ ​ 先删子，再删父。</p><p>​ 插入数据的顺序？ ​ 先插入父，再插入子。</p><blockquote><p>思考：子表中的外键引用的父表中的某个字段，被引用的这个字段必须是主键吗？不一定是主键，但至少具有unique约束。外键值可以为NULL。</p></blockquote></li></ol><h3 id="主键分类">主键分类</h3><ul><li>自然主键：主键值是一个自然数，和业务没关系。</li><li>业务主键：主键值和业务紧密关联，例如拿银行卡账号做主键值。这就是业务主键！</li></ul><blockquote><p>在实际开发中使用业务主键多，还是使用自然主键多一些？自然主键使用比较多，因为主键只要做到不重复就行，不需要有意义。业务主键不好，因为主键一旦和业务挂钩，那么当业务发生变动的时候，可能会影响到主键值，所以业务主键不建议使用。尽量使用自然主键。</p></blockquote><h3 id="存储引擎">存储引擎</h3><blockquote><p>存储引擎是MySQL中特有的一个术语，其它数据库中没有。（Oracle中有，但是不叫这个名字）实际上存储引擎是一个表存储/组织数据的方式。不同的存储引擎，表存储数据的方式不同。</p></blockquote><p>在建表的时候可以在最后小括号的")"的右边使用：</p><ul><li>ENGINE来指定存储引擎。</li><li>CHARSET来指定这张表的字符编码方式。</li></ul><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">CREATE TABLE `t_student` (<br>  `no` int(<span class="hljs-number">11</span>) <span class="hljs-literal">NOT</span> NULL AUTO_INCREMENT,<br>  `name` varchar(<span class="hljs-number">255</span>) DEFAULT NULL,<br>  `cno` int(<span class="hljs-number">11</span>) DEFAULT NULL,<br>  PRIMARY KEY (`no`),<br>  KEY `cno` (`cno`),<br>  CONSTRAINT `t_student_ibfk_1` FOREIGN KEY (`cno`) REFERENCES `t_class` (`classno`)<br>) ENGINE=InnoDB AUTO_INCREMENT=<span class="hljs-number">11</span> DEFAULT CHARSET=utf8<br></code></pre></td></tr></table></figure><ul><li>mysql默认的存储引擎是：<code>InnoDB</code></li><li>mysql默认的字符编码方式是：<code>utf8</code></li></ul><h4 id="myisam存储引擎">MyISAM存储引擎</h4><p>它管理的表具有以下特征： 使用三个文件表示每个表：</p><ul><li><p>格式文件 — 存储表结构的定义（mytable.frm）</p></li><li><p>数据文件 — 存储表行的内容（mytable.MYD）</p></li><li><p>索引文件 —存储表上索引（mytable.MYI）：索引是一本书的目录，缩小扫描范围，提高查询效率的一种机制。</p><p>可被转换为压缩、只读表来节省空间</p></li></ul><blockquote><p>提示一下：对于一张表来说，只要是主键，或者加有unique约束的字段上会自动创建索引。</p></blockquote><p>MyISAM存储引擎特点：</p><ul><li>可被转换为压缩、只读表来节省空间</li><li>这是这种存储引擎的优势！！！！</li><li>MyISAM不支持事务机制，安全性低。</li></ul><h4 id="innodb存储引擎">InnoDB存储引擎</h4><p>这是mysql默认的存储引擎，同时也是一个重量级的存储引擎。InnoDB支持事务，支持数据库崩溃后自动恢复机制。InnoDB存储引擎最主要的特点是：非常安全。</p><p>它管理的表具有下列主要特征：</p><ul><li>每个 InnoDB 表在数据库目录中以.frm 格式文件表示</li><li>InnoDB 表空间 tablespace被用于存储表的内容（表空间是一个逻辑名称。表空间存储数据+索引。）</li><li>提供一组用来记录事务性活动的日志文件</li><li>用 COMMIT(提交)、SAVEPOINT 及ROLLBACK(回滚)支持事务处理</li><li>提供全 ACID 兼容</li><li>在 MySQL 服务器崩溃后提供自动恢复</li><li>多版本（MVCC）和行级锁定</li><li>支持外键及引用的完整性，包括级联删除和更新</li></ul><p>InnoDB最大的特点就是支持事务：</p><ul><li>以保证数据的安全。效率不是很高，并且也不能压缩，不能转换为只读，</li><li>不能很好的节省存储空间。</li></ul><h4 id="memory存储引擎">MEMORY存储引擎</h4><p>使用 MEMORY 存储引擎的表，其数据存储在内存中，且行的长度固定，这两个特点使得 MEMORY 存储引擎非常快。</p><p>MEMORY 存储引擎管理的表具有下列特征：</p><ul><li>在数据库目录内，每个表均以.frm 格式的文件表示。</li><li>表数据及索引被存储在内存中。（目的就是快，查询快！）</li><li>表级锁机制。</li><li>不能包含 TEXT 或 BLOB 字段。</li></ul><p>MEMORY 存储引擎以前被称为HEAP 引擎。</p><blockquote><p>MEMORY引擎优点：查询效率是最高的。不需要和硬盘交互。MEMORY引擎缺点：不安全，关机之后数据消失。因为数据和索引都是在内存当中。</p></blockquote><h3 id="事务">事务</h3><p>一个事务其实就是一个完整的业务逻辑。是一个最小的工作单元。不可再分。</p><blockquote><p>什么是一个完整的业务逻辑？ 假设转账，从A账户向B账户中转账10000.将A账户的钱减去10000（update语句） 将B账户的钱加上10000（update语句）这就是一个完整的业务逻辑。</p><p>以上的操作是一个最小的工作单元，要么同时成功，要么同时失败，不可再分。这两个update语句要求必须同时成功或者同时失败，这样才能保证钱是正确的。</p></blockquote><p>只有DML语句才会有事务这一说，其它语句和事务无关！！！</p><p>insert delete update</p><p>只要你的操作一旦涉及到数据的增、删、改，那么就一定要考虑安全问题。</p><p>本质上，一个事务其实就是多条DML语句同时成功，或者同时失败！</p><p>事务：就是批量的DML语句同时成功，或者同时失败！</p><h4 id="事务的提交与回滚">事务的提交与回滚</h4><blockquote><p>在事务的执行过程中，每一条DML的操作都会记录到“事务性活动的日志文件”中。在事务的执行过程中，我们可以提交事务，也可以回滚事务。</p></blockquote><ul><li><p>提交事务清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中。提交事务标志着，事务的结束。并且是一种全部成功的结束。</p></li><li><p>回滚事务将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件回滚事务标志着，事务的结束。并且是一种全部失败的结束。</p></li></ul><p>mysql默认情况下是支持自动提交事务的。（自动提交）</p><p>每执行一条DML语句，则提交一次！</p><p>将mysql的自动提交机制关闭掉</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">start</span> <span class="hljs-keyword">transaction</span>;<br></code></pre></td></tr></table></figure><h4 id="事务的特性">事务的特性</h4><h5 id="a原子性">A：原子性</h5><ul><li>说明事务是最小的工作单元。不可再分。</li></ul><h5 id="c一致性">C：一致性</h5><ul><li>所有事务要求，在同一个事务当中，所有操作必须同时成功，或者同时失败，以保证数据的一致性。</li></ul><h5 id="i隔离性">I：隔离性</h5><ul><li>A事务和B事务之间具有一定的隔离。教室A和教室B之间有一道墙，这道墙就是隔离性。</li><li>A事务在操作一张表的时候，另一个事务B也操作这张表会那样？？？</li></ul><h5 id="d持久性">D：持久性</h5><ul><li>事务最终结束的一个保障。事务提交，就相当于将没有保存到硬盘上的数据保存到硬盘上！</li></ul><h4 id="事务的隔离性">事务的隔离性</h4><p>事务和事务之间4个隔离级别：</p><ol type="1"><li><p>读未提交：read uncommitted（最低的隔离级别）</p><p>事务A可以读取到事务B未提交的数据。</p><p>这种隔离级别存在的问题就是： 脏读现象！(Dirty Read)我们称读到了脏数据。这种隔离级别一般都是理论上的，大多数的数据库隔离级别都是二档起步！</p></li><li><p>读已提交：read committed</p><p>事务A只能读取到事务B提交之后的数据。</p><p>这种隔离级别解决了什么问题？</p><p>解决了脏读的现象。</p><p>这种隔离级别存在什么问题？</p><p>不可重复读取数据。</p><p>什么是不可重复读取数据呢？</p><p>在事务开启之后，第一次读到的数据是3条，当前事务还没有结束，可能第二次再读取的时候，读到的数据是4条，3不等于4，称为不可重复读取。</p><p>这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实。oracle数据库默认的隔离级别是：read committed</p></li><li><p>可重复读：repeatable read</p><p>事务A开启之后，不管是多久，每一次在事务A中读取到的数据都是一致的。即使事务B将数据已经修改，并且提交了，事务A读取到的数据还是没有发生改变，这就是可重复读。</p><p>可重复读解决了什么问题？ 解决了不可重复读取数据。</p><p>可重复读存在的问题是什么？ 可能会出现幻影读。</p><p>每一次读取到的数据都是幻象。不够真实！</p><p>早晨9点开始开启了事务，只要事务不结束，到晚上9点，读到的数据还是那样！读到的是假象。不够绝对的真实。</p><p>mysql中默认的事务隔离级别就是这个！！！！！！！！！！！</p></li><li><p>序列化/串行化：serializable</p><p>这是最高隔离级别，效率最低。解决了所有的问题。这种隔离级别表示事务排队，不能并发！ synchronized，线程同步（事务同步）每一次读取到的数据都是最真实的，并且效率是最低的。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习笔记02</title>
    <link href="/%E6%89%80%E6%9C%89/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/"/>
    <url>/%E6%89%80%E6%9C%89/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/</url>
    
    <content type="html"><![CDATA[<h3 id="连接查询">连接查询</h3><p>从一张表中单独查询，称为单表查询。</p><p>emp表和dept表联合起来查询数据，从emp表中取员工名字，从dept表中取部门名字。这种跨表查询，多张表联合起来查询数据，被称为连接查询。</p><h4 id="连接查询的分类">连接查询的分类</h4><p>根据语法的年代分类：</p><ul><li>SQL92：1992年的时候出现的语法</li><li>SQL99：1999年的时候出现的语法</li></ul><p>根据表连接的方式分类：</p><ul><li>内连接：<ul><li>等值连接</li><li>非等值连接</li><li>自连接</li></ul></li><li>外连接：<ul><li>左外连接（左连接）</li><li>右外连接（右连接）</li></ul></li><li>全连接</li></ul><h4 id="笛卡尔积现象">笛卡尔积现象</h4><p>当两张表进行连接查询，没有任何条件限制的时候，最终查询结果条数，是两张表条数的乘积，这种现象被称为：笛卡尔积现象。（笛卡尔发现的，这是一个数学现象。）</p><h4id="如何避免笛卡尔积现象匹配次数仍不变只是避免现象">如何避免笛卡尔积现象（匹配次数仍不变，只是避免现象）</h4><p>连接时加条件，满足这个条件的记录被筛选出来！</p><p>思考：最终查询的结果条数是14条，但是匹配的过程中，匹配的次数减少了吗？还是56次，只不过进行了四选一。次数没有减少。</p><p>注意：通过笛卡尔积现象得出，表的连接次数越多效率越低，尽量避免表的连接次数。</p><h4 id="内连接之等值连接">内连接之等值连接</h4><blockquote><p>案例：查询每个员工所在部门名称，显示员工名和部门名？ emp e和deptd表进行连接。条件是：e.deptno = d.deptno</p></blockquote><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">SQL92语法：<br><span class="hljs-keyword">select</span> <br><span class="hljs-built_in">e</span>.ename,d.dname<br><span class="hljs-keyword">from</span><br>emp <span class="hljs-built_in">e</span>, dept d<br><span class="hljs-keyword">where</span><br><span class="hljs-built_in">e</span>.deptno = d.deptno;<br></code></pre></td></tr></table></figure><p>sql92的缺点：结构不清晰，表的连接条件，和后期进一步筛选的条件，都放到了where后面。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">SQL99语法：<br><span class="hljs-keyword">select</span> <br><span class="hljs-built_in">e</span>.ename,d.dname<br><span class="hljs-keyword">from</span><br>emp <span class="hljs-built_in">e</span><br><span class="hljs-keyword">join</span><br>dept d<br><span class="hljs-keyword">on</span><br><span class="hljs-built_in">e</span>.deptno = d.deptno;<br>//默认就是内连接<br>//inner可以省略（带着inner可读性更好！！！一眼就能看出来是内连接）<br><span class="hljs-keyword">select</span> <br><span class="hljs-built_in">e</span>.ename,d.dname<br><span class="hljs-keyword">from</span><br>emp <span class="hljs-built_in">e</span><br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span><br>dept d<br><span class="hljs-keyword">on</span><br><span class="hljs-built_in">e</span>.deptno = d.deptno; // 条件是等量关系，所以被称为等值连接。<br></code></pre></td></tr></table></figure><p>sql99优点：表连接的条件是独立的，连接之后，如果还需要进一步筛选，再往后继续添加where。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">SQL99语法：<br><span class="hljs-selector-tag">select</span> <br>...<br><span class="hljs-selector-tag">from</span><br><span class="hljs-selector-tag">a</span><br>join<br><span class="hljs-selector-tag">b</span><br>on<br><span class="hljs-selector-tag">a</span>和<span class="hljs-selector-tag">b</span>的连接条件<br>where<br>筛选条件<br></code></pre></td></tr></table></figure><h4 id="外连接vs内连接">外连接VS内连接</h4><p>内连接</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">内连接：（A和B连接，AB两张表没有主次关系。平等的。）<br><span class="hljs-keyword">select</span> <br><span class="hljs-built_in">e</span>.ename,d.dname<br><span class="hljs-keyword">from</span><br>emp <span class="hljs-built_in">e</span><br><span class="hljs-keyword">join</span><br>dept d<br><span class="hljs-keyword">on</span><br><span class="hljs-built_in">e</span>.deptno = d.deptno; //内连接的特点：完成能够匹配上这个条件的数据查询出来。<br></code></pre></td></tr></table></figure><p>外连接（右外连接）</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <br><span class="hljs-built_in">e</span>.ename,d.dname<br><span class="hljs-keyword">from</span><br>emp <span class="hljs-built_in">e</span> <br><span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> <br>dept d<br><span class="hljs-keyword">on</span><br><span class="hljs-built_in">e</span>.deptno = d.deptno;<br><br>// outer是可以省略的，带着可读性强。<br><span class="hljs-keyword">select</span> <br><span class="hljs-built_in">e</span>.ename,d.dname<br><span class="hljs-keyword">from</span><br>emp <span class="hljs-built_in">e</span> <br><span class="hljs-keyword">right</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> <br>dept d<br><span class="hljs-keyword">on</span><br><span class="hljs-built_in">e</span>.deptno = d.deptno;<br></code></pre></td></tr></table></figure><blockquote><p>right代表什么：表示将join关键字右边的这张表看成主表，主要是为了将这张表的数据全部查询出来，捎带着关联查询左边的表。在外连接当中，两张表连接，产生了主次关系。</p></blockquote><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">外连接（左外连接）：<br><span class="hljs-keyword">select</span> <br><span class="hljs-built_in">e</span>.ename,d.dname<br><span class="hljs-keyword">from</span><br>dept d <br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <br>emp <span class="hljs-built_in">e</span><br><span class="hljs-keyword">on</span><br><span class="hljs-built_in">e</span>.deptno = d.deptno;<br><br>// outer是可以省略的，带着可读性强。<br><span class="hljs-keyword">select</span> <br><span class="hljs-built_in">e</span>.ename,d.dname<br><span class="hljs-keyword">from</span><br>dept d <br><span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> <br>emp <span class="hljs-built_in">e</span><br><span class="hljs-keyword">on</span><br><span class="hljs-built_in">e</span>.deptno = d.deptno;<br></code></pre></td></tr></table></figure><blockquote><p>带有right的是右外连接，又叫做右连接。带有left的是左外连接，又叫做左连接。 任何一个右连接都有左连接的写法。任何一个左连接都有右连接的写法。</p></blockquote><p>思考：外连接的查询结果条数一定是 &gt;=内连接的查询结果条数？正确。</p><h3 id="子查询">子查询</h3><p>select语句中嵌套select语句，被嵌套的select语句称为子查询。</p><h4 id="子查询可以出现的地方">子查询可以出现的地方</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span><br>..(<span class="hljs-keyword">select</span>).<br><span class="hljs-keyword">from</span><br>..(<span class="hljs-keyword">select</span>).<br><span class="hljs-keyword">where</span><br>..(<span class="hljs-keyword">select</span>).<br></code></pre></td></tr></table></figure><h3 id="关于dql语句的总结">关于DQL语句的总结</h3><p>编写顺序</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">select</span> <br><span class="hljs-params">...</span><br>from<br><span class="hljs-params">...</span><br><span class="hljs-keyword">where</span><br><span class="hljs-params">...</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br><span class="hljs-params">...</span><br>having<br><span class="hljs-params">...</span><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span><br><span class="hljs-params">...</span><br>limit<br><span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p>执行顺序</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">from</span><br><span class="hljs-keyword">join</span><br>on<br><span class="hljs-keyword">where</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br><span class="hljs-keyword">avg</span>, <span class="hljs-keyword">sum</span>...<br>having<br><span class="hljs-keyword">select</span><br>distinct<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span><br>limit..<br></code></pre></td></tr></table></figure><h3 id="表的创建">表的创建</h3><p>建表属于DDL语句，DDL包括：create drop alter。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">create</span> <span class="hljs-built_in">table</span> 表名(字段名<span class="hljs-number">1</span> 数据类型, 字段名<span class="hljs-number">2</span> 数据类型, 字段名<span class="hljs-number">3</span> 数据类型);<br><br><span class="hljs-built_in">create</span> <span class="hljs-built_in">table</span> 表名(<br>字段名<span class="hljs-number">1</span> 数据类型, <br>字段名<span class="hljs-number">2</span> 数据类型, <br>字段名<span class="hljs-number">3</span> 数据类型<br>);<br></code></pre></td></tr></table></figure><h3 id="mysql中的数据类型">MySQL中的数据类型</h3><table><thead><tr><th style="text-align: center;">数据类型</th><th style="text-align: center;">描述</th><th style="text-align: center;">特点</th><th style="text-align: center;">优点</th><th style="text-align: center;">缺点</th></tr></thead><tbody><tr><td style="text-align: center;">varchar(最长255)</td><td style="text-align: center;">可变长度的字符串</td><td style="text-align: center;">会根据实际的数据长度动态分配空间。</td><td style="text-align: center;">比较智能，节省空间。</td><td style="text-align: center;">需要动态分配空间，速度慢。</td></tr><tr><td style="text-align: center;">char(最长255)</td><td style="text-align: center;">定长字符串</td><tdstyle="text-align: center;">不管实际的数据长度是多少，分配固定长度的空间去存储数据。</td><td style="text-align: center;">不需要动态分配空间，速度快。</td><td style="text-align: center;">使用不当可能会导致空间的浪费。</td></tr><tr><td style="text-align: center;">int(最长11)</td><td style="text-align: center;">数字中的整数型</td><td style="text-align: center;">等同于java的int。</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">bigint</td><td style="text-align: center;">数字中的长整型</td><td style="text-align: center;">等同于java中的long。</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">float</td><td style="text-align: center;">单精度浮点型数据</td><td style="text-align: center;">等同于java中的float。</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">double</td><td style="text-align: center;">双精度浮点型数据</td><td style="text-align: center;">等同于java中的double。</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">date</td><td style="text-align: center;">短日期类型</td><td style="text-align: center;">默认格式：%Y-%m-%d</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">datetime</td><td style="text-align: center;">长日期类型</td><td style="text-align: center;">默认格式：%Y-%m-%d %h:%i:%s</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">clob</td><td style="text-align: center;">字符大对象</td><tdstyle="text-align: center;">最多可以存储4G的字符串。比如：存储一篇文章，存储一个说明。</td><tdstyle="text-align: center;">超过255个字符的都要采用CLOB字符大对象来存储。</td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">blob</td><td style="text-align: center;">二进制大对象</td><tdstyle="text-align: center;">专门用来存储图片、声音、视频等流媒体数据。往BLOB类型的字段上插入数据的时候，例如插入一个图片、视频等。</td><td style="text-align: center;"></td><td style="text-align: center;">需要使用IO流才行。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习笔记01</title>
    <link href="/%E6%89%80%E6%9C%89/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
    <url>/%E6%89%80%E6%9C%89/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
    
    <content type="html"><![CDATA[<h3id="数据库数据库管理系统sql相关概念">数据库、数据库管理系统、SQL相关概念</h3><h4 id="数据库">数据库：</h4><p>英文单词DataBase，简称DB。按照一定格式存储数据的一些文件的组合。</p><p>顾名思义：存储数据的仓库，实际上就是一堆文件。</p><p>这些文件中存储了具有特定格式的数据。</p><h4 id="数据库管理功能">数据库管理功能</h4><p>DataBaseManagement，简称DBMS。数据库管理系统是专门用来管理数据库中数据的，数据库管理系统可以对数据库当中的数据进行增删改查。</p><p>常见的数据库管理系统： MySQL、Oracle、MSSqlServer、DB2、sybase等....</p><h4 id="sql结构化查询语言">SQL：结构化查询语言</h4><p>程序员需要学习SQL语句，程序员通过编写SQL语句，然后DBMS负责执行SQL语句，最终来完成数据库中数据的增删改查操作。</p><p>SQL是一套标准，程序员主要学习的就是SQL语句，这个SQL在mysql中可以使用，同时在Oracle中也可以使用，在DB2中也可以使用。</p><h4 id="三者之间的关系">三者之间的关系</h4><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">DBMS</span><span class="hljs-literal">--</span><span class="hljs-comment">执行</span><span class="hljs-literal">--</span>&gt; <span class="hljs-comment">SQL</span> <span class="hljs-literal">--</span><span class="hljs-comment">操作</span><span class="hljs-literal">--</span>&gt; <span class="hljs-comment">DB</span><br></code></pre></td></tr></table></figure><h3 id="表table">表(Table)</h3><p>数据库当中最基本的单元是表：table。</p><p>数据库当中是以表格的形式表示数据的，因为表比较直观。</p><p>任何一张表都有行和列：</p><ul><li>行（row）：被称为数据/记录。</li><li>列（column）：被称为字段。</li></ul><p>每一个字段都有：字段名、数据类型、约束等属性。</p><ul><li><p>字段名可以理解，是一个普通的名字，见名知意就行。</p></li><li><p>数据类型：字符串，数字，日期等。</p></li><li><p>约束：约束也有很多，其中一个叫做唯一性约束，这种约束添加之后，该字段中的数据不能重复。</p></li></ul><h3 id="sql语句的分类">SQL语句的分类</h3><p>SQL语句有很多，最好进行分门别类，这样更容易记忆。分为：</p><ul><li>DQL（Data Query Language）</li><li>DML（Data Manipulation Language）</li><li>DDL（Data Definition Language）</li><li>TCL（Transactional Control Language）</li><li>DCL（Data Control Language）</li></ul><table><thead><tr><th style="text-align: center;">语句种类</th><th style="text-align: center;">名称</th><th style="text-align: center;">介绍</th><th style="text-align: center;">代表</th></tr></thead><tbody><tr><td style="text-align: center;">DQL</td><td style="text-align: center;">数据查询语句</td><td style="text-align: center;">凡是带有select关键字的都是查询语句</td><td style="text-align: center;">select...</td></tr><tr><td style="text-align: center;">DML</td><td style="text-align: center;">数据操作语句</td><tdstyle="text-align: center;">凡是对表当中的数据进行增删改的都是DML</td><td style="text-align: center;">insert、delete、update</td></tr><tr><td style="text-align: center;">DDL</td><td style="text-align: center;">数据定义语句</td><tdstyle="text-align: center;">凡是带有create、drop、alter的都是DDL。</td><td style="text-align: center;">create、drop、alter</td></tr><tr><td style="text-align: center;">TCL</td><td style="text-align: center;">事务控制语句</td><tdstyle="text-align: center;">用于快速原型开发、脚本编程、GUI和测试等方面</td><td style="text-align: center;">commit、rollback</td></tr><tr><td style="text-align: center;">DCL</td><td style="text-align: center;">数据控制语言</td><td style="text-align: center;">授予或回收访问数据库的某种特权</td><td style="text-align: center;">grant、revoke</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习-语言基础-继承</title>
    <link href="/Java/Java%E5%AD%A6%E4%B9%A0-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E7%BB%A7%E6%89%BF/"/>
    <url>/Java/Java%E5%AD%A6%E4%B9%A0-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="java学习-语言基础-继承">Java学习-语言基础-继承</h2><ul><li>类、超类和子类</li><li>Object：所有类的超类</li><li>泛型数组列表</li><li>对象包装器与自动装箱</li><li>参数数量可变的方法</li><li>枚举类</li><li>反射</li><li>继承的设计技巧</li></ul>]]></content>
    
    
    <categories>
      
      <category>所有</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>继承</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习-语言基础-面向对象</title>
    <link href="/Java/Java%E5%AD%A6%E4%B9%A0-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/Java/Java%E5%AD%A6%E4%B9%A0-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="java学习-语言基础-面向对象">Java学习-语言基础-面向对象</h2><ul><li>面向对象程序设计概述</li><li>使用预定义类</li><li>用户自定义类</li><li>静态域与静态方法</li><li>方法参数</li><li>对象构造</li><li>包</li><li>类路径</li><li>文档注释</li><li>类设计技巧</li></ul><h4 id="面向对象程序设计概述">面向对象程序设计概述</h4><p>面向对象程序设计（简称OOP）是当今主流的程序设计泛型。面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。在OOP中，不必关心对象的具体实现，只要能够满足用户的需求即可。</p><h4 id="类">类</h4><p>类（class）是构造对象的模板或蓝图。由类构造（construct）对象的过程称为创建类的实例（instance）。</p>]]></content>
    
    
    <categories>
      
      <category>所有</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java位运算符</title>
    <link href="/Java/Java%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/Java/Java%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="java位运算符">Java位运算符</h1><p>Java定义的位运算（bitwiseoperators）直接对整数类型的位进行操作，这些整数类型包括long，int，short，char 和 byte。</p><p>位运算符主要用来对操作数二进制的位进行运算。按位运算表示按每个二进制位（bit）进行计算，其操作数和运算结果都是整型值。</p><p>Java 语言中的位运算符分为位逻辑运算符和位移运算符两类。</p><h2 id="位逻辑运算符">位逻辑运算符</h2><p>位逻辑运算符包含 4 个：&amp;（与）、|（或）、~（非）和^（异或）。除了 ~（即位取反）为单目运算符外，其余都为双目运算符。</p><table><thead><tr><th style="text-align: center;">运算符</th><th style="text-align: center;">含义</th><th style="text-align: center;">实例</th><th style="text-align: center;">结果</th></tr></thead><tbody><tr><td style="text-align: center;">&amp;</td><td style="text-align: center;">按位进行与运算（AND）</td><td style="text-align: center;">4 &amp; 5</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;">|</td><td style="text-align: center;">按位进行或运算（OR）</td><td style="text-align: center;">4</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;">^</td><td style="text-align: center;">按位进行异或运算（XOR）</td><td style="text-align: center;">4 ^ 5</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">~</td><td style="text-align: center;">按位进行取反运算（NOT）</td><td style="text-align: center;">~ 4</td><td style="text-align: center;">-5</td></tr></tbody></table><h4 id="位与运算符">位与运算符</h4><p>位与运算符为<code>&amp;</code>，其运算规则是：参与运算的数字，低位对齐，高位不足的补零，如果对应的二进制位同时为1，那么计算结果才为 1，否则为 0。因此，任何数与 0进行按位与运算，其结果都为 0。</p><p>例如下面的表达式：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-number">100</span><span class="hljs-meta">&amp;0</span><br></code></pre></td></tr></table></figure><p>图 1 所示为这个运算过程，结果为 0。</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/3-1P9301F126492.jpg"alt="图 1 100位与0的运算过程" /><figcaption aria-hidden="true">图 1 100位与0的运算过程</figcaption></figure><p>下面是两个非零的数字进行位与运算的过程。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span> = <span class="hljs-number">5</span>,<span class="hljs-keyword">y</span> = <span class="hljs-number">12</span>; <span class="hljs-regexp">//</span> 创建整型变量保存两个数<span class="hljs-keyword">int</span> z = <span class="hljs-keyword">x</span>&amp;<span class="hljs-keyword">y</span>; <span class="hljs-regexp">//</span> 对这两个数进行位与运算，结果保存到z<br></code></pre></td></tr></table></figure><p>这两行语句执行后变量 Z 的值是 4，图 2 所示为这个运算过程。</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/3-1P9301F21U53.jpg"alt="图 2 5位与12的运算过程" /><figcaption aria-hidden="true">图 2 5位与12的运算过程</figcaption></figure><h4 id="位或运算符">位或运算符</h4><p>位或运算符为<code>|</code>，其运算规则是：参与运算的数字，低位对齐，高位不足的补零。如果对应的二进制位只要有一个为1，那么结果就为 1；如果对应的二进制位都为 0，结果才为 0。</p><p>下面是一个使用位或运算符的表达式。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-number">11</span><span class="hljs-string">|7</span><br></code></pre></td></tr></table></figure><p>运算结果为 15，图 3 所示为其运算过程。</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/3-1P9301F239E8.jpg"alt="图 3 11位或7的运算过程" /><figcaption aria-hidden="true">图 3 11位或7的运算过程</figcaption></figure><h4 id="位异或运算符">位异或运算符</h4><p>位异或运算符为<code>^</code>，其运算规则是：参与运算的数字，低位对齐，高位不足的补零，如果对应的二进制位相同（同时为0 或同时为 1）时，结果为 0；如果对应的二进制位不相同，结果则为 1。</p><p>下面是一个使用位异或运算符的表达式。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">11</span>^<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>运算结果为 12，图 4 所示为其运算过程。</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/3-1P9301F315J4.jpg"alt="图 4 11位异或7的运算过程" /><figcaption aria-hidden="true">图 4 11位异或7的运算过程</figcaption></figure><p>提示：在有的高级语言中，将运算符<code>^</code>作为求幂运算符，要注意区分。</p><h4 id="位取反运算符">位取反运算符</h4><p>位取反运算符为<code>~</code>，其运算规则是：只对一个操作数进行运算，将操作数二进制中的1 改为 0，0 改为 1。</p><p>下面是一个使用位取反运算符的表达式。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml">~10<br></code></pre></td></tr></table></figure><p>运算结果为 65525，图 5 所示为其运算过程。</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/3-1P9301F932230.jpg"alt="图 5 对10位取反的运算过程" /><figcaption aria-hidden="true">图 5 对10位取反的运算过程</figcaption></figure><p>我们可以使用如下的程序来检查这个运算结果。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.printf(&quot;%d \n&quot;,~i);<br></code></pre></td></tr></table></figure><p>编译执行以上程序，会发现输出的结果是 -11，而不是65525。这是因为取反之后的结果是十六进制数，而在上面的程序中使用 %d将输出转换为了十进制数。</p><p>可以使用如下语句查看十六进制结果。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.printf(&quot;%x \n&quot;,~i);<br></code></pre></td></tr></table></figure><p>可以看到输出结果为 fff5，将它转换为二进制是1111111111110101。这个二进制数的最高位为1，表示这个数为负数。除最高位外，按位取反再加 1，即得到二进制原码1000000000001011，用十进制数表示即为 -11。</p><p>注意：位运算符的操作数只能是整型或者字符型数据以及它们的变体，不用于float、double 或者 long 等复杂的数据类型。</p><h2 id="位移运算符">位移运算符</h2><p>位移运算符用来将操作数向某个方向（向左或者右）移动指定的二进制位数。表中列出了 Java 语言中的两个位移运算符，它们都属于双目运算符。</p><table><thead><tr><th>运算符</th><th>含义</th><th>实例</th><th>结果</th></tr></thead><tbody><tr><td>»</td><td>右移位运算符</td><td>8»1</td><td>4</td></tr><tr><td>«</td><td>左移位运算符</td><td>9«2</td><td>36</td></tr></tbody></table><h4 id="左位移运算符">左位移运算符</h4><p>左移位运算符为<code>«</code>，其运算规则是：按二进制形式把所有的数字向左移动对应的位数，高位移出（舍弃），低位的空位补零。</p><p>例如，将整数 11 向左位移 1 位的过程如图 6 所示。</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/3-1P9301F955462.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>图 6 对11左移1位运算过程</p><p>从图 6 中可以看到，原来数的所有二进制位都向左移动 1位。原来位于左边的最高位 0 被移出舍弃，再向尾部追加 0补位。最终到的结果是 22，相当于原来数的 2 倍。</p><h4 id="右位移运算符">右位移运算符</h4><p>右位移运算符为<code>»</code>，其运算规则是：按二进制形式把所有的数字向右移动对应的位数，低位移出（舍弃），高位的空位补零。</p><p>例如，将整数 11 向右位移 1 位的过程如图 7 所示。</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/3-1P9301G0343F.jpg"alt="图 7 对11右移1位运算过程" /><figcaption aria-hidden="true">图 7 对11右移1位运算过程</figcaption></figure><p>从图 7 中可以看到，原来数的所有二进制位都向右移动 1位。原来位于右边的最低位 1 被移出舍弃，再向最高位追加 0补位。最终到的结果是 5，相当于原数整除 2 的结果。</p><h2 id="复合位赋值运算符">复合位赋值运算符</h2><p>所有的二进制位运算符都有一种将赋值与位运算组合在一起的简写形式。复合位赋值运算符由赋值运算符与位逻辑运算符和位移运算符组合而成。表3 列出了组合后的复合位赋值运算符。</p><table><thead><tr><th>运算符</th><th>含义</th><th>实例</th><th>结果</th></tr></thead><tbody><tr><td>&amp;=</td><td>按位与赋值</td><td>num1 &amp;= num2</td><td>等价于 num 1=num 1 &amp; num2</td></tr><tr><td>|=</td><td>按位或赋值</td><td>num1 |= num2</td><td>等价于 num 1=num 1 | num2</td></tr><tr><td>^=</td><td>按位异或赋值</td><td>num1 ^= num2</td><td>等价于 num 1=num 1 ^ num2</td></tr><tr><td>-=</td><td>按位取反赋值</td><td>num1 ~= num2</td><td>等价于 num 1=num 1 ~ num2</td></tr><tr><td>«=</td><td>按位左移赋值</td><td>num1 «= num2</td><td>等价于 num 1=num 1 « num2</td></tr><tr><td>»=</td><td>按位右移赋值</td><td>num1 »= num2</td><td>等价于 num 1=num 1 » num2</td></tr></tbody></table><p>下面的程序定义了几个 int型变量，然后运用位赋值简写的形式将运算后的值赋给相应的变量：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> c = <span class="hljs-number">3</span>;<br><br>a &amp;= <span class="hljs-number">4</span>;<br>a |= <span class="hljs-number">4</span>;<br>a ^= c;<br>a -= <span class="hljs-number">6</span>;<br>b &gt;&gt;= <span class="hljs-number">1</span>;<br>c &lt;&lt;= <span class="hljs-number">1</span>;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;a = &quot; + a);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;b = &quot; + b);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;c = &quot; + c);<br></code></pre></td></tr></table></figure><p>该程序的输出为：</p><p>a = 1 b = 1 c = 6</p>]]></content>
    
    
    <categories>
      
      <category>所有</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习-语言基础-基础语法</title>
    <link href="/Java/Java%E5%AD%A6%E4%B9%A0-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/Java/Java%E5%AD%A6%E4%B9%A0-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="java语言基础-基础语法">Java语言基础-基础语法</h2><h4 id="java的基本程序设计结构">00-Java的基本程序设计结构</h4><ul><li><p>简单的Java应用程序</p></li><li><p>注释</p></li><li><p>数据类型</p></li><li><p>变量</p></li><li><p>运算符</p></li><li><p>字符串</p></li><li><p>输入输出</p></li><li><p>控制流</p></li><li><p>大数值</p></li><li><p>数组</p></li></ul><h4 id="简单的java应用程序">01-简单的Java应用程序</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This is the first sample program in Core Java Chapter 3</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.01 1997-03-22</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Gary Cornell</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FirstSample</span><br>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>)<br>   &#123;<br>      <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;We will not use &#x27;Hello, World!&#x27;&quot;</span>);<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol type="1"><li>关键字<code>Public</code>称为<code>访问修饰符</code>，这些修饰符用于控制程序的其他部分对这段代码的访问级别。</li><li>关键字<code>class</code>表明Java程序中的全部内容都包含在类中。这里，只需要将类作为一个加载程序逻辑的容器，程序逻辑定义了应用程序的行为。</li><li>关键字<code>class</code>后面紧跟类名。Java中定义类名的规则很宽松。名字必须以字母开头，后面可以跟字母和数字的任意组合，长度上基本没有限制。但是不能使用Java保留字作为类名。</li><li>标准的命名规范为：类名是以大写字母开头的名词。如果名字由多个单词组成，每个单词的第一个字母都应该大写。</li><li>源代码的文件名必须与公共类的名字相同，并用<code>.java</code>作为扩展名。因此，存储这段源代码的文件名必须为<code>FirstSample.java</code>。</li><li>Java中的所有函数都属于某个类的方法（标准术语称其为方法，而不是成员函数）。</li><li>如果<code>main</code>方法正常退出，那么Java应用程序的推出代码为0，表示成功地运行了程序。如果需要在终止程序时返回其他的代码，那就需要调用<code>System.exit</code>方法。</li></ol><p><code>注意：根据Java语言规范，main方法必须申明为public。在Jaav SE 1.4及以后的版本中强制main方法是public的。</code></p><h4 id="注释">02-注释</h4><ol type="1"><li>使用<code>//</code>，其注释内容从<code>//</code>开始到本行结尾。</li><li>使用<code>/*</code>和<code>*/</code>将一段比较长的注释括起来。</li><li>以<code>/**</code>开始，以<code>*/</code>结束，用于自动生成文档。</li></ol><p><code>在Java中，/* */注释不能嵌套。也就是说，不能简单地把代码用/*和*/括起来作为注释，因为这段代码本身可能也包含一个*/</code></p><h4 id="数据类型">03-数据类型</h4><p>Java是一种强类型语言。这就意味着必须为每一个变量申明一种类型。在Java中，一共有8种基本类型。</p><ul><li>4种整型</li><li>2种浮点类型</li><li>1种用于表示<code>Unicode</code>编码的字符单元的字符类型<code>char</code></li><li>1种用于表示真值的<code>boolean</code>类型</li></ul><p><code>Java有一个能够表示任意精度的算术包，通常称为“大数值”。虽然被称为大数值，但它并不是一种新的Java类型，而是一个Java对象。</code></p><ol type="1"><li><h5 id="整型">整型</h5><p>整型用于表示没有小数部分的数值，它允许是负数。Java提供4种整型。</p><table><thead><tr><th style="text-align: left;">类型</th><th style="text-align: center;">存储需求</th><th style="text-align: center;">取值范围</th></tr></thead><tbody><tr><td style="text-align: left;">int</td><td style="text-align: center;">4字节</td><td style="text-align: center;">-2 147 483 648 ~ 2 147 483647（正好超过20亿）</td></tr><tr><td style="text-align: left;">short</td><td style="text-align: center;">2字节</td><td style="text-align: center;">-32 768 ~ 32 767</td></tr><tr><td style="text-align: left;">long</td><td style="text-align: center;">8字节</td><td style="text-align: center;">-9 223 372 036 854 775 808 ~ 9 223 372036 854 775 807</td></tr><tr><td style="text-align: left;">byte</td><td style="text-align: center;">1字节</td><td style="text-align: center;">-128 ~ 127</td></tr></tbody></table><ol type="1"><li><code>btye</code>——<code>short</code>——<code>int</code>——<code>long</code>，2倍关系，等比增长。</li><li><code>Java中，整型的范围与运行Java代码的机器无关</code></li><li>长整型数值有一个后缀L或l（如4000000000L）。</li><li>十六进制数值有一个前缀0X或0x（如0xCAFE）。</li><li>八进制有一个前缀0，例如，010对应8进制中的8。八进制表示法比较容易混淆，建议最好不要使用八进制常数。</li><li>从Java7开始，加上前缀0B或0b就可以写二进制数。例如，0b1001就是9。另外，同样是从Java7开始，还可以为数字字面量加上下划线，如用1_000_000（或0b1111_0100_0010_0100_0000）表示一百万。这些下划线只是为了让人们更好读。Java编译器会去除这些下划线。</li><li><code>注意：Java没有任何无符号（unsigned）形式的int、long、short、或byte类型。</code></li></ol></li><li><h5 id="浮点类型">浮点类型</h5><p>浮点类型用于表示小数部分的数值。在Java中有两种浮点类型。</p><table><thead><tr><th style="text-align: left;">类型</th><th style="text-align: center;">存储需求</th><th style="text-align: center;">取值范围</th></tr></thead><tbody><tr><td style="text-align: left;">float</td><td style="text-align: center;">4字节</td><td style="text-align: center;">大约± 3.402 82347E+38F（有效位数为6-7位）</td></tr><tr><td style="text-align: left;">double</td><td style="text-align: center;">8字节</td><td style="text-align: center;">大约± 1.797 693 134 862 31570E+308（有效位数为15位）</td></tr></tbody></table><p>double表示这种类型的数值精度是float类型的两倍（有人称之为双精度数值）。绝大部分应用程序都采用double类型。在很多情况下，float类型的精度很难满足需求。实际上，只有很少的情况适合使用float类型，例如，需要单精度数据的库，或者需要存储大量的数据。</p><p>floa类型的数值有一个后缀F或f（例如，3.14F）。没有后缀F的浮点数值（如3.14）默认为double类型。当然，也可以在浮点数值后面添加后缀D或d（例如，3.14D）</p><p>所有的浮点数值计算都遵循IEEE754规范。具体来说，下面是用于表示溢出和出错情况的三个特殊的浮点数值。</p><ul><li>正无穷大</li><li>负无穷大</li><li>NaN（Not a Number）</li></ul><p>例如，一个正整数除以0的结果是正无穷大。计算0/0或者负数的平方根结果为NaN。</p><p><code>常量Double.POSITIVE_INFINITY、Double.NEGEATIVE_INFINITY和Double.NaN（以及相应的float类型的常量）分别表示这三种特殊的值。</code></p><p>注意：所有NaN（非数值）的值都认为是不相同的。然而，可以使用Double.isNaN方法。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">x</span> == Double.<span class="hljs-symbol">NaN</span>)<span class="hljs-comment">//永远是false</span><br><span class="hljs-keyword">if</span> (Double.isNaN(<span class="hljs-variable language_">x</span>))<span class="hljs-comment">// 检查x是否是（非数值）</span><br></code></pre></td></tr></table></figure><p><code>警告：浮点数值不适用于无法接受舍入误差的金融计算中。例如，命令System.out.println(2.0 - 1.1)将打印出0.8999999999999999，而不是人们想象中的0.9。这种舍入误差的主要原因是浮点数值采用二进制系统表示，而在二进制系统中无法精确地表示分数1/10。这就好像十进制无法精确地表示分数1/3一样。如果在数值计算中不允许有任何舍入误差，就应该使用BigDecimal类。</code></p></li><li><h5 id="浮点类型-1">浮点类型</h5><p><code>char</code>类型原本用于表示单个字符。如今，有些<code>Unicode</code>字符可以用一个<code>char</code>值描述，另外一些<code>Unicode</code>值需要两个<code>char</code>值。</p><p><code>char</code>类型的字面量值要用单引号括起来。例如：<code>'A'</code>是编码值为65所对应的字符常量。它与<code>"A"</code>不同，<code>"A"</code>是包含一个字符A的字符串。</p><p><code>char</code>类型的值可以表示为十六进制值，其范围从<code>\u0000</code>到<code>\Uffff</code>。</p><p>除了转移序列<code>\u</code>之外，还有一些用于表示特殊字符的转义序列，所有这些转义序列都可以出现在加引号的字符字面量或字符串中。</p><table><thead><tr><th style="text-align: center;">转义序列</th><th style="text-align: center;">名称</th><th style="text-align: center;">Unicode值</th></tr></thead><tbody><tr><td style="text-align: center;"><code>\b</code></td><td style="text-align: center;">退格</td><td style="text-align: center;">008</td></tr><tr><td style="text-align: center;"><code>\t</code></td><td style="text-align: center;">制表</td><td style="text-align: center;">009</td></tr><tr><td style="text-align: center;"><code>\n</code></td><td style="text-align: center;">换行</td><td style="text-align: center;">00a</td></tr><tr><td style="text-align: center;"><code>\r</code></td><td style="text-align: center;">回车</td><td style="text-align: center;">00d</td></tr><tr><td style="text-align: center;"><code>\"</code></td><td style="text-align: center;">双引号</td><td style="text-align: center;">022</td></tr><tr><td style="text-align: center;"><code>\'</code></td><td style="text-align: center;">单引号</td><td style="text-align: center;">027</td></tr><tr><td style="text-align: center;"><code>\\</code></td><td style="text-align: center;">反斜杠</td><td style="text-align: center;">05e</td></tr></tbody></table><p><code>警告：Unicode转义字符会在解析代码之前得到处理。例如，"\u0022+\u0022"并不是一个由引号(U+0022)包围加号构成的字符串。实际上，\u0022会在解析之前转换为"，这会得到""+""，也就是一个空串。</code></p><p>更隐蔽地，一定要当心注释中的<code>\u</code>。注释</p><p>​ <code>// \u00A0 is a newline</code></p><p>会产生一个语法错误，因为读程序时<code>\u00A0</code>会替换成一个换行符。</p><p>类似地，下面这个注释</p><p>​ <code>// Look inside c:\users</code></p><p>也会产生一个语法错误，因为<code>\u</code>后面并未跟着4个十六进制数。</p><p>在Java中，char类型描述了UTF-16编码中的一个代码单元。</p><p>我们强烈建议不要在程序中使用char类型，除非确实需要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理。</p></li><li><h5 id="boolean类型">boolean类型</h5><p><code>boolean</code>（布尔）类型有两个值：<code>false</code>和<code>true</code>，用来判断逻辑条件。<code>整型值和布尔值之间不能进行相互转换</code>。</p><p><code>注意：在C++中，数值甚至指针可以代替boolean值。值0相当于布尔值false，非0值相当于布尔值true。在Java中则不是这样。</code>因此，Java程序员不会遇到下述麻烦：</p><p>​ <code>if (x = 0) // oops... meant x == 0</code></p><p>在C++中这个测试可以编译运行，其结果总是<code>false</code>。而在Java中，这个测试将不能通过编译，其原因是整数表达式<code>x = 0</code>不能转换为布尔值。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>所有</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Hexo写博客时的图片插入问题</title>
    <link href="/Hexo/%E5%85%B3%E4%BA%8EHexo%E5%86%99%E5%8D%9A%E5%AE%A2%E6%97%B6%E7%9A%84%E5%9B%BE%E7%89%87%E6%8F%92%E5%85%A5%E9%97%AE%E9%A2%98/"/>
    <url>/Hexo/%E5%85%B3%E4%BA%8EHexo%E5%86%99%E5%8D%9A%E5%AE%A2%E6%97%B6%E7%9A%84%E5%9B%BE%E7%89%87%E6%8F%92%E5%85%A5%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="关于markdown">关于MarkDown</h4><p><code>MarkDown</code>是一种轻量级标记语言，它可以导出<code>HTML</code>、<code>WORD</code>、<code>图像</code>、<code>PDF</code>、<code>EPUB</code>等多种格式的文档。使用<code>MarkDown</code>写文章有如下好处：</p><ul><li>MarkDown可以在任何地方使用，兼容<code>MacOS</code>、<code>Windows</code>、<code>Linux</code>等平台</li><li>博客网站比如简书、<code>GitHub</code>、<code>CSDN</code>，<code>GitChat</code>等都支持<code>MarkDown</code>，所以只需要写一个<code>MarkDown</code>文件，并通过将文件上传至各平台就可以实现在多个博客网站发表文章</li><li>专注文字内容而不是排版样式，不同于<code>Word</code>等软件需要考虑设置排版</li><li>正宗的官方技术文档都是使用<code>MarkDown</code>书写的，使用<code>MarkDown</code>写文章有助于熟悉其语法，提升自己写文档的能力</li><li>写作的过程也是思考的过程，写文章不仅有助于加强自己对所涉及内容的进一步熟悉与认知，还能提升自己的语言组织能力与写作水平</li></ul><p>综上所述，收益无穷！</p><h4 id="使用markdown的相关问题">使用MarkDown的相关问题</h4><p>在写文章的时候，我们可以插入图片和相关资源使得文章更加丰富生动，但是在本地写<code>MarkDown</code>文件时，上传的本地图片是无法实现在网络上或是在另外一台设备上访问的。</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210812164957225.png"alt="image-20210812164957225" /><figcaption aria-hidden="true">image-20210812164957225</figcaption></figure><p>比如上面这张图片是我截图然后粘贴的，文件存放在电脑本地，如果直接发布到<code>Hexo</code>自己的博客网站，或者是<code>CSDN</code>，<code>简书</code>等博客平台是无法访问的，又或者是我们将MarkDown文件发给别人时，对方也是无法查看插入的本地图片的。</p><p>那么在使用<code>Hexo</code>框架写我们的文章时，怎么实现在网络上看到我们插入的图片呢？这里我主要介绍两种方法，分别都是我实现过的，在这里总结经验。</p><h4 id="办法一同名目录-相对路径">办法一：同名目录 + 相对路径</h4><ol type="1"><li><p>在使用<code>Hexo</code>写博客时，每一篇文章创建一个同名目录，并在这个同名目录中放置需要插入的图片文件，在<code>MarkDown</code>文章中插入使用图片的相对路径，然后在部署博客的时候也一同将这个文件夹上传到服务器。</p><ol type="1"><li><p>修改配置文件<code>_config.yml</code>使得每一次新建文章的时候自动生成同名目录。<imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210812170117912.png"alt="image-20210812170117912" /></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-params">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>修改MarkDown编辑器配置，实现粘贴图片时自动将图片文件复制一份到所对应的同名目录。</p><p>我使用的Typora编辑MarkDown文件，通过<code>ctrl + ,</code>打开Typora的设置，并按图片中完成相关设置。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">./<span class="hljs-variable">$&#123;filename&#125;</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210812171134932.png"alt="image-20210812171134932" /><figcaption aria-hidden="true">image-20210812171134932</figcaption></figure><p>完成这样的设置后，每当我们在<code>Typora</code>中粘贴图片的时候就会将图片复制到同名目录下。</p><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/20210812171437.png" /></p><p>但是需要注意的是，这样上传到<code>Hexo</code>依旧不能解决图片无法访问的问题，因为图片的路径还是本地的路径，只是这个图片所属的本地的文件夹是和文章同名的。</p><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/20210812171655.png" /></p><p>解决办法：将绝对路径变成相对路径，这样在<code>Hexo</code>服务器上就会自动的在与文章同名的那个文件夹里面找图片文件，所以只需要删去前面的一部分，只留下图片的文件名。</p><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/20210812172606.png" /></p><p>由于当前<code>MarkDown</code>文件内的所有插入的图片都自动地放在一个文件夹里，所以他们的路径的前缀都是一样的，可以使用<code>Typora</code>的快捷操作将前缀全部替换成空白。</p><p>具体方法：<code>ctrl + H</code>打开替换</p><p><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/20210812172540.png" /></p><p>总结这个方法：</p><ol type="1"><li>本地看不到图片的效果，但是上传至<code>Hexo</code>后是可以查看的，能解决<code>Hexo</code>上查看本地图片的问题。</li><li>但是仍然不能解决<code>Hexo</code>以外的诸多博客平台的本地图片访问问题，对于<code>CSDN</code>、简书来说它都有自己的图床，所以可以上传到对应平台的图床，然后用网络的链接访问图片。</li><li>使得<code>Hexo</code>文件变得臃肿，随着博客文章的积累，用到的图片会在每次部署和上传到服务器时一并被携带上传，造成部署和上传的压力，使得上传的速度变得很慢。</li><li>由于博客部署在<code>GitHub Pages</code>，就会导致加载博客文章时，一大部分时间用于请求<code>Github Pages</code>服务器加载图片文件，再加上<code>Github Pages</code>服务器在大陆访问有时很慢的情况，使得博客网页加载奇慢无比。</li></ol><p>综上，这个办法并不是长久有效的。</p></li></ol></li></ol><h4 id="方法二oss对象存储-picgo图床">方法二：OSS对象存储 +PicGo（图床）</h4><p>这个方法其实就是自己搭建一个<code>图床</code>，当然你也可以将图片放在网上的各种免费的图床上。</p><p>但是我们需要面临一些问题</p><ol type="1"><li>网络图床有可能突然就不维护了，那么我们放的图片也就不翼而飞了，而如果你的图片又没有备份的话，那么所有用到这些图片的文件都会被涉及到，这些图片也就访问不了，消失在网络的大海里。</li><li>免费的图床有额度限制，一般可用的空间不会太大。</li><li>本地写文章时不够简便，需要每张图片手动上传。</li></ol><p>为了解决上诉问题，可以使用OSS对象存储配合<code>PicGo</code>自己搭建一个图床供自己使用，岂不美哉。</p><p>关于<code>OSS</code>的概念就不介绍了，可以理解为利用它创建一个自己的云盘，然后通过链接访问这些资源。</p><p>具体可在阿里云的<code>OSS</code>介绍里了解：<ahref="https://help.aliyun.com/product/31815.html">阿里云帮助中心-阿里云，领先的云计算服务提供商(aliyun.com)</a></p><ol type="1"><li><h5 id="购买oss服务">购买OSS服务</h5><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210812180005563.png"alt="image-20210812180005563" /><figcaption aria-hidden="true">image-20210812180005563</figcaption></figure><p>博客加上日常使用的话40G就够了，而且9块钱一年，可以说并不贵。</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210812180045807.png"alt="image-20210812180045807" /><figcaption aria-hidden="true">image-20210812180045807</figcaption></figure></li><li><h5 id="创建bucket">创建Bucket</h5><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210812180159497.png"alt="image-20210812180159497" /><figcaption aria-hidden="true">image-20210812180159497</figcaption></figure></li><li><h5 id="下载picgo">下载PicGo</h5><p>下载地址：<ahref="https://github.com/Molunerfinn/PicGo/releases">Releases ·Molunerfinn/PicGo (github.com)</a></p></li><li><h5 id="配置picgo">配置PicGo</h5><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210812180706635.png"alt="image-20210812180706635" /><figcaption aria-hidden="true">image-20210812180706635</figcaption></figure></li><li><h5 id="配置typora">配置Typora</h5><p>在设置里面将插入图片时的操作设置为上传图片，然后上传服务设置为PicGo，那么每次粘贴图片的时候就会自动的上传到图床上，并生成网络连接</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210812180816894.png"alt="image-20210812180816894" /><figcaption aria-hidden="true">image-20210812180816894</figcaption></figure></li><li><h5 id="大功告成">大功告成</h5><p>自动上传的文件</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210812181038227.png"alt="image-20210812181038227" /><figcaption aria-hidden="true">image-20210812181038227</figcaption></figure><p>生成的链接</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210812181115779.png"alt="image-20210812181115779" /><figcaption aria-hidden="true">image-20210812181115779</figcaption></figure></li></ol><h4 id="总结">总结</h4><ol type="1"><li>使用自己搭建图床的方法可以长久的存储自己的资源</li><li>操作更加的简单</li><li>会产生一些费用，不过轻量使用的话，一年要不了多少钱</li><li>后续还可以配合自己的域名使用，不过考虑到域名备案的问题，我并没有这样实现。</li><li>欢迎访问我的博客！<a href="https://jettsblog.top/">江客(jettsblog.top)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>所有</category>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>OSS</tag>
      
      <tag>阿里云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode配置C++环境超简单过程</title>
    <link href="/C/VSCode%E9%85%8D%E7%BD%AEC-%E7%8E%AF%E5%A2%83%E8%B6%85%E7%AE%80%E5%8D%95%E8%BF%87%E7%A8%8B/"/>
    <url>/C/VSCode%E9%85%8D%E7%BD%AEC-%E7%8E%AF%E5%A2%83%E8%B6%85%E7%AE%80%E5%8D%95%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="在vscode中写c的相关配置">在VSCode中写C++的相关配置</h1><h2 id="懒人福音">懒人福音</h2><p><ahref="https://blog.csdn.net/qq_41523096/article/details/104628484">20秒一键配置 VSCode (Visual Studio Code) C/C++开发环境 !_12 26 25的博客-CSDN博客</a></p><p>参考上述教程配置好VSCode后，便可以使用VSCode写C++程序了，但是这样的配置会导致.cpp代码文件和.exe二进制可执行文件全部都与.vscode文件夹放在一起，显得十分的混乱而不整洁。</p><h2 id="强迫症福音">强迫症福音</h2><p>通过对配置文件的一些修改便可以实现cpp代码文件与exe程序文件分离，显得更加的工整。</p><p>在.vscode同级目录下建立exe文件夹用于存放编译生成的可执行文件</p><p>在.vscode同级目录下建立代码文件夹用于存放cpp文件</p><ol type="1"><li><p>task.json</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs nix">&#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>    <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;g++&quot;</span>,<br>    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>    <span class="hljs-string">&quot;presentation&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;echo&quot;</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-string">&quot;reveal&quot;</span>: <span class="hljs-string">&quot;always&quot;</span>,<br>      <span class="hljs-string">&quot;focus&quot;</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-string">&quot;panel&quot;</span>: <span class="hljs-string">&quot;shared&quot;</span>,<br>      <span class="hljs-string">&quot;showReuseMessage&quot;</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-string">&quot;clear&quot;</span>: <span class="hljs-literal">false</span><br>    &#125;,<br>    <span class="hljs-string">&quot;args&quot;</span>: [<br>      <span class="hljs-string">&quot;-m32&quot;</span>,<br>      <span class="hljs-string">&quot;-g&quot;</span>,<br>      <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;file&#125;</span>&quot;</span>,<br>      <span class="hljs-string">&quot;-o&quot;</span>,<br>      <span class="hljs-operator">//</span><span class="hljs-string">&quot;<span class="hljs-subst">$&#123;fileDirname&#125;</span>/<span class="hljs-subst">$&#123;fileBasenameNoExtension&#125;</span>.exe&quot;</span><br>      <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;workspaceFolder&#125;</span>/exe/<span class="hljs-subst">$&#123;fileBasenameNoExtension&#125;</span>.exe&quot;</span>],<br>    <span class="hljs-string">&quot;problemMatcher&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;owner&quot;</span>: <span class="hljs-string">&quot;cpp&quot;</span>,<br>      <span class="hljs-string">&quot;fileLocation&quot;</span>: [<span class="hljs-string">&quot;relative&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;workspaceRoot&#125;</span>&quot;</span>],<br>      <span class="hljs-string">&quot;pattern&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;regexp&quot;</span>: <span class="hljs-string">&quot;^(.*):(<span class="hljs-char escape_">\\</span>d+):(<span class="hljs-char escape_">\\</span>d+):<span class="hljs-char escape_">\\</span>s+(warning|error):<span class="hljs-char escape_">\\</span>s+(.*)$&quot;</span>,<br>        <span class="hljs-string">&quot;file&quot;</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-string">&quot;line&quot;</span>: <span class="hljs-number">2</span>,<br>        <span class="hljs-string">&quot;column&quot;</span>: <span class="hljs-number">3</span>,<br>        <span class="hljs-string">&quot;severity&quot;</span>: <span class="hljs-number">4</span>,<br>        <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-number">5</span><br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>launch.json</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-string">&quot;configurations&quot;</span>: [<br>        &#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;(gdb) Launch&quot;</span>,<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>,<br>            <span class="hljs-string">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-string">&quot;targetArchitecture&quot;</span>: <span class="hljs-string">&quot;x86&quot;</span>,<br>            //<span class="hljs-string">&quot;program&quot;</span>: <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;workspaceFolder&#125;</span>/exe/<span class="hljs-variable">$&#123;fileBasenameNoExtension&#125;</span>.exe&quot;</span>,<br>            <span class="hljs-string">&quot;program&quot;</span>: <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;fileDirname&#125;</span>/<span class="hljs-variable">$&#123;fileBasenameNoExtension&#125;</span>.exe&quot;</span>,<br>            <span class="hljs-string">&quot;miDebuggerPath&quot;</span>: <span class="hljs-string">&quot;D:/MinGW/bin/gdb.exe&quot;</span>,<br>            <span class="hljs-string">&quot;args&quot;</span>: [],<br>            <span class="hljs-string">&quot;stopAtEntry&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-string">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;fileDirname&#125;</span>&quot;</span>,<br>            <span class="hljs-string">&quot;externalConsole&quot;</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-string">&quot;preLaunchTask&quot;</span>: <span class="hljs-string">&quot;g++&quot;</span><br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="实现效果">实现效果</h2><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210630000926160-1624984786477.png"alt="image-20210630000926160-1624984786477" /><figcaptionaria-hidden="true">image-20210630000926160-1624984786477</figcaption></figure><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210630000945867.png"alt="image-20210630000945867" /><figcaption aria-hidden="true">image-20210630000945867</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多台电脑同步更新Hexo博客</title>
    <link href="/Hexo/%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0Hexo%E5%8D%9A%E5%AE%A2/"/>
    <url>/Hexo/%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0Hexo%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>在利用Hexo+GithubPages写我们的博客的时候，真正的原始Hexo文件在我们的电脑本地，而GitHub上传的只是Hexo生成的静态网页，即public文件夹里面的内容。</p><p>那么假如我们有两台电脑工作，Hexo最开始搭建在其中一台电脑上，而我们需要在另外一台电脑上同时更新我们的博客，该怎么做呢？</p><p>也就是说，我们需要实现多台电脑间博客项目的迁移与同步。为实现这一点，我们可以利用Git的分支。</p><h1 id="创建分支">创建分支</h1><p>博客搭建好后(博客搭建教程见——<ahref="https://jettsblog.top/Hexo/利用Hexo框架从零开始搭建个人博客/">利用Hexo框架从零开始搭建个人博客- 江客 (jettsblog.top)</a>)，我们在Github上创建分支</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210627092559451.png"alt="image-20210627092559451" /><figcaption aria-hidden="true">image-20210627092559451</figcaption></figure><p>创建一个名为hexo的分支</p><h1 id="设置hexo分支为默认分支">设置hexo分支为默认分支</h1><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210627093723305.png"alt="image-20210627093723305" /><figcaption aria-hidden="true">image-20210627093723305</figcaption></figure><p>将博客项目仓库的Settings-&gt;Branches-&gt;Defaultbranch修改为hexo</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210627093748365.png"alt="image-20210627093748365" /><figcaption aria-hidden="true">image-20210627093748365</figcaption></figure><h1id="将创建的分支的远程仓库克隆到本地">将创建的分支的远程仓库克隆到本地</h1><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210627093914404.png"alt="image-20210627093914404" /><figcaption aria-hidden="true">image-20210627093914404</figcaption></figure><h1id="删去除.git文件夹以外的所有你内容">删去除.git文件夹以外的所有你内容</h1><ol type="1"><li><p>进入克隆到本地的仓库</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210627094256807.png"alt="image-20210627094256807" /><figcaption aria-hidden="true">image-20210627094256807</figcaption></figure></li><li><p>勾选查看隐藏的文件</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210627094400276.png"alt="image-20210627094400276" /><figcaption aria-hidden="true">image-20210627094400276</figcaption></figure></li><li><p>删去除.git文件夹以外的所有文件</p></li><li><p>在克隆的仓库下分别执行以下命令更新删除操作到远程</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> -A<br><span class="hljs-symbol">git</span> commit -m <span class="hljs-string">&quot;--&quot;</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> origin hexo<br></code></pre></td></tr></table></figure><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs nix">jett@HUAWEI-Huang MINGW64 <span class="hljs-symbol">/d/Github/HJTAHMAKBAR.github.io</span> (hexo)<br>$ git branch<br><span class="hljs-operator">*</span> hexo<br><br>jett@HUAWEI-Huang MINGW64 <span class="hljs-symbol">/d/Github/HJTAHMAKBAR.github.io</span> (hexo)<br>$ git add <span class="hljs-operator">-</span>A<br><br>jett@HUAWEI-Huang MINGW64 <span class="hljs-symbol">/d/Github/HJTAHMAKBAR.github.io</span> (hexo)<br>$ git commit <span class="hljs-operator">-</span>m <span class="hljs-string">&quot;--&quot;</span><br>[hexo <span class="hljs-number">91</span>e562f] <span class="hljs-operator">-</span>-<br> <span class="hljs-number">42</span> files changed, <span class="hljs-number">8343</span> deletions(-)<br> delete mode <span class="hljs-number">100644</span> <span class="hljs-number">404</span>.html<br> delete mode <span class="hljs-number">100644</span> CNAME<br> delete mode <span class="hljs-number">100644</span> about<span class="hljs-symbol">/index.html</span><br> delete mode <span class="hljs-number">100644</span> archives<span class="hljs-symbol">/2021/06/index.html</span><br> delete mode <span class="hljs-number">100644</span> archives<span class="hljs-symbol">/2021/index.html</span><br> delete mode <span class="hljs-number">100644</span> archives<span class="hljs-symbol">/index.html</span><br> delete mode <span class="hljs-number">100644</span> categories<span class="hljs-symbol">/index.html</span><br> delete mode <span class="hljs-number">100644</span> <span class="hljs-string">&quot;categories/<span class="hljs-char escape_">\3</span>46<span class="hljs-char escape_">\2</span>11<span class="hljs-char escape_">\2</span>00<span class="hljs-char escape_">\3</span>46<span class="hljs-char escape_">\2</span>34<span class="hljs-char escape_">\2</span>11/index.html&quot;</span><br> delete mode <span class="hljs-number">100644</span> css<span class="hljs-symbol">/gitalk.css</span><br> delete mode <span class="hljs-number">100644</span> css<span class="hljs-symbol">/main.css</span><br> delete mode <span class="hljs-number">100644</span> img<span class="hljs-symbol">/avatar.png</span><br> delete mode <span class="hljs-number">100644</span> img<span class="hljs-symbol">/bg/library.jpg</span><br> delete mode <span class="hljs-number">100644</span> img<span class="hljs-symbol">/bg/pen.jpg</span><br> delete mode <span class="hljs-number">100644</span> img<span class="hljs-symbol">/bg/planet.png</span><br> delete mode <span class="hljs-number">100644</span> img<span class="hljs-symbol">/bg/road.jpg</span><br> delete mode <span class="hljs-number">100644</span> img<span class="hljs-symbol">/bg/skateBoarding.jpg</span><br> delete mode <span class="hljs-number">100644</span> img<span class="hljs-symbol">/bg/sleepyCat.jpg</span><br> delete mode <span class="hljs-number">100644</span> img<span class="hljs-symbol">/cover/cover.png</span><br> delete mode <span class="hljs-number">100644</span> img<span class="hljs-symbol">/cover/helloworld.png</span><br> delete mode <span class="hljs-number">100644</span> img<span class="hljs-symbol">/default.png</span><br> delete mode <span class="hljs-number">100644</span> img<span class="hljs-symbol">/favicon.png</span><br> delete mode <span class="hljs-number">100644</span> img<span class="hljs-symbol">/img/avatar.png</span><br> delete mode <span class="hljs-number">100644</span> img<span class="hljs-symbol">/loading.gif</span><br> delete mode <span class="hljs-number">100644</span> img<span class="hljs-symbol">/police_beian.png</span><br> delete mode <span class="hljs-number">100644</span> index.html<br> delete mode <span class="hljs-number">100644</span> js<span class="hljs-symbol">/boot.js</span><br> delete mode <span class="hljs-number">100644</span> js<span class="hljs-symbol">/color-schema.js</span><br> delete mode <span class="hljs-number">100644</span> js<span class="hljs-symbol">/events.js</span><br> delete mode <span class="hljs-number">100644</span> js<span class="hljs-symbol">/img-lazyload.js</span><br> delete mode <span class="hljs-number">100644</span> js<span class="hljs-symbol">/leancloud.js</span><br> delete mode <span class="hljs-number">100644</span> js<span class="hljs-symbol">/local-search.js</span><br> delete mode <span class="hljs-number">100644</span> js<span class="hljs-symbol">/plugins.js</span><br> delete mode <span class="hljs-number">100644</span> js<span class="hljs-symbol">/utils.js</span><br> delete mode <span class="hljs-number">100644</span> lib<span class="hljs-symbol">/hint/hint.min.css</span><br> delete mode <span class="hljs-number">100644</span> links<span class="hljs-symbol">/index.html</span><br> delete mode <span class="hljs-number">100644</span> local-search.xml<br> delete mode <span class="hljs-number">100644</span> tags<span class="hljs-symbol">/index.html</span><br> delete mode <span class="hljs-number">100644</span> <span class="hljs-string">&quot;tags/<span class="hljs-char escape_">\3</span>45<span class="hljs-char escape_">\2</span>05<span class="hljs-char escape_">\2</span>66<span class="hljs-char escape_">\3</span>44<span class="hljs-char escape_">\2</span>73<span class="hljs-char escape_">\2</span>26/index.html&quot;</span><br> delete mode <span class="hljs-number">100644</span> <span class="hljs-string">&quot;tags/<span class="hljs-char escape_">\3</span>51<span class="hljs-char escape_">\2</span>32<span class="hljs-char escape_">\2</span>17<span class="hljs-char escape_">\3</span>46<span class="hljs-char escape_">\2</span>03<span class="hljs-char escape_">\2</span>63/index.html&quot;</span><br> delete mode <span class="hljs-number">100644</span> xml<span class="hljs-symbol">/local-search.xml</span><br> delete mode <span class="hljs-number">100644</span> <span class="hljs-string">&quot;<span class="hljs-char escape_">\3</span>46<span class="hljs-char escape_">\2</span>11<span class="hljs-char escape_">\2</span>00<span class="hljs-char escape_">\3</span>46<span class="hljs-char escape_">\2</span>34<span class="hljs-char escape_">\2</span>11/<span class="hljs-char escape_">\3</span>44<span class="hljs-char escape_">\2</span>75<span class="hljs-char escape_">\2</span>40<span class="hljs-char escape_">\3</span>45<span class="hljs-char escape_">\2</span>45<span class="hljs-char escape_">\2</span>75<span class="hljs-char escape_">\3</span>44<span class="hljs-char escape_">\2</span>70<span class="hljs-char escape_">\2</span>26<span class="hljs-char escape_">\3</span>47<span class="hljs-char escape_">\2</span>25<span class="hljs-char escape_">\2</span>14/helloworld.png&quot;</span><br> delete mode <span class="hljs-number">100644</span> <span class="hljs-string">&quot;<span class="hljs-char escape_">\3</span>46<span class="hljs-char escape_">\2</span>11<span class="hljs-char escape_">\2</span>00<span class="hljs-char escape_">\3</span>46<span class="hljs-char escape_">\2</span>34<span class="hljs-char escape_">\2</span>11/<span class="hljs-char escape_">\3</span>44<span class="hljs-char escape_">\2</span>75<span class="hljs-char escape_">\2</span>40<span class="hljs-char escape_">\3</span>45<span class="hljs-char escape_">\2</span>45<span class="hljs-char escape_">\2</span>75<span class="hljs-char escape_">\3</span>44<span class="hljs-char escape_">\2</span>70<span class="hljs-char escape_">\2</span>26<span class="hljs-char escape_">\3</span>47<span class="hljs-char escape_">\2</span>25<span class="hljs-char escape_">\2</span>14/index.html&quot;</span><br><br>jett@HUAWEI-Huang MINGW64 <span class="hljs-symbol">/d/Github/HJTAHMAKBAR.github.io</span> (hexo)<br>$ git push origin hexo<br>Enumerating <span class="hljs-params">objects:</span> <span class="hljs-number">3</span>, done.<br>Counting <span class="hljs-params">objects:</span> <span class="hljs-number">100</span>% (<span class="hljs-number">3</span><span class="hljs-operator">/</span><span class="hljs-number">3</span>), done.<br>Delta compression using up to <span class="hljs-number">12</span> threads<br>Compressing <span class="hljs-params">objects:</span> <span class="hljs-number">100</span>% (<span class="hljs-number">1</span><span class="hljs-operator">/</span><span class="hljs-number">1</span>), done.<br>Writing <span class="hljs-params">objects:</span> <span class="hljs-number">100</span>% (<span class="hljs-number">2</span><span class="hljs-operator">/</span><span class="hljs-number">2</span>), <span class="hljs-number">186</span> bytes | <span class="hljs-number">186.00</span> KiB<span class="hljs-operator">/</span>s, done.<br>Total <span class="hljs-number">2</span> (delta <span class="hljs-number">0</span>), reused <span class="hljs-number">0</span> (delta <span class="hljs-number">0</span>), pack-reused <span class="hljs-number">0</span><br>To https:<span class="hljs-symbol">//github.com/HJTAHMAKBAR/HJTAHMAKBAR.github.io.git</span><br>   c5be9db..<span class="hljs-number">91</span>e562f  hexo <span class="hljs-operator">-&gt;</span> hexo<br></code></pre></td></tr></table></figure></li><li><p>将分支克隆到本地的仓库中的.git文件夹复制到博客文件夹中</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210627101258655.png"alt="image-20210627101258655" /><figcaption aria-hidden="true">image-20210627101258655</figcaption></figure></li><li><p>在博客目录下执行命令同步到远程的hexo分支</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> -A<br><span class="hljs-symbol">git</span> commit -m <span class="hljs-string">&quot;备份Hexo(提交的描述)&quot;</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> origin hexo<br></code></pre></td></tr></table></figure><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs nix">jett@HUAWEI-Huang MINGW64 <span class="hljs-symbol">/d/Github/JettsBlog</span> (hexo)<br>$ git add <span class="hljs-operator">-</span>A<br><span class="hljs-params">warning:</span> LF will be replaced by CRLF <span class="hljs-keyword">in</span> package.json.<br>The file will have its original line endings <span class="hljs-keyword">in</span> your working directory<br><span class="hljs-params">warning:</span> LF will be replaced by CRLF <span class="hljs-keyword">in</span> source<span class="hljs-operator">/</span>_posts<span class="hljs-operator">/</span>你好世界.md.<br>The file will have its original line endings <span class="hljs-keyword">in</span> your working directory<br><span class="hljs-params">warning:</span> LF will be replaced by CRLF <span class="hljs-keyword">in</span> source<span class="hljs-symbol">/about/index.md.</span><br>The file will have its original line endings <span class="hljs-keyword">in</span> your working directory<br><br>jett@HUAWEI-Huang MINGW64 <span class="hljs-symbol">/d/Github/JettsBlog</span> (hexo)<br>$ git commit <span class="hljs-operator">-</span>m <span class="hljs-string">&quot;备份Hexo&quot;</span><br>[hexo <span class="hljs-number">3</span>f03216] 备份Hexo<br> <span class="hljs-number">24</span> files changed, <span class="hljs-number">3404</span> insertions(<span class="hljs-operator">+</span>)<br> create mode <span class="hljs-number">100644</span> .github<span class="hljs-symbol">/dependabot.yml</span><br> create mode <span class="hljs-number">100644</span> .gitignore<br> create mode <span class="hljs-number">100644</span> _config.fluid.yml<br> create mode <span class="hljs-number">100644</span> _config.landscape.yml<br> create mode <span class="hljs-number">100644</span> _config.yml<br> create mode <span class="hljs-number">100644</span> package-lock.json<br> create mode <span class="hljs-number">100644</span> package.json<br> create mode <span class="hljs-number">100644</span> scaffolds<span class="hljs-symbol">/draft.md</span><br> create mode <span class="hljs-number">100644</span> scaffolds<span class="hljs-symbol">/page.md</span><br> create mode <span class="hljs-number">100644</span> scaffolds<span class="hljs-symbol">/post.md</span><br> create mode <span class="hljs-number">100644</span> source<span class="hljs-symbol">/CNAME</span><br> create mode <span class="hljs-number">100644</span> <span class="hljs-string">&quot;source/_posts/<span class="hljs-char escape_">\3</span>44<span class="hljs-char escape_">\2</span>75<span class="hljs-char escape_">\2</span>40<span class="hljs-char escape_">\3</span>45<span class="hljs-char escape_">\2</span>45<span class="hljs-char escape_">\2</span>75<span class="hljs-char escape_">\3</span>44<span class="hljs-char escape_">\2</span>70<span class="hljs-char escape_">\2</span>26<span class="hljs-char escape_">\3</span>47<span class="hljs-char escape_">\2</span>25<span class="hljs-char escape_">\2</span>14.md&quot;</span><br> create mode <span class="hljs-number">100644</span> <span class="hljs-string">&quot;source/_posts/<span class="hljs-char escape_">\3</span>44<span class="hljs-char escape_">\2</span>75<span class="hljs-char escape_">\2</span>40<span class="hljs-char escape_">\3</span>45<span class="hljs-char escape_">\2</span>45<span class="hljs-char escape_">\2</span>75<span class="hljs-char escape_">\3</span>44<span class="hljs-char escape_">\2</span>70<span class="hljs-char escape_">\2</span>26<span class="hljs-char escape_">\3</span>47<span class="hljs-char escape_">\2</span>25<span class="hljs-char escape_">\2</span>14/helloworld.png&quot;</span><br> create mode <span class="hljs-number">100644</span> source<span class="hljs-symbol">/about/index.md</span><br> create mode <span class="hljs-number">100644</span> source<span class="hljs-symbol">/img/bg/library.jpg</span><br> create mode <span class="hljs-number">100644</span> source<span class="hljs-symbol">/img/bg/pen.jpg</span><br> create mode <span class="hljs-number">100644</span> source<span class="hljs-symbol">/img/bg/planet.png</span><br> create mode <span class="hljs-number">100644</span> source<span class="hljs-symbol">/img/bg/road.jpg</span><br> create mode <span class="hljs-number">100644</span> source<span class="hljs-symbol">/img/bg/skateBoarding.jpg</span><br> create mode <span class="hljs-number">100644</span> source<span class="hljs-symbol">/img/bg/sleepyCat.jpg</span><br> create mode <span class="hljs-number">100644</span> source<span class="hljs-symbol">/img/cover/cover.png</span><br> create mode <span class="hljs-number">100644</span> source<span class="hljs-symbol">/img/cover/helloworld.png</span><br> create mode <span class="hljs-number">100644</span> source<span class="hljs-symbol">/img/img/avatar.png</span><br> create mode <span class="hljs-number">100644</span> themes<span class="hljs-symbol">/.gitkeep</span><br><br>jett@HUAWEI-Huang MINGW64 <span class="hljs-symbol">/d/Github/JettsBlog</span> (hexo)<br>$ git push origin hexo<br>Enumerating <span class="hljs-params">objects:</span> <span class="hljs-number">36</span>, done.<br>Counting <span class="hljs-params">objects:</span> <span class="hljs-number">100</span>% (<span class="hljs-number">36</span><span class="hljs-operator">/</span><span class="hljs-number">36</span>), done.<br>Delta compression using up to <span class="hljs-number">12</span> threads<br>Compressing <span class="hljs-params">objects:</span> <span class="hljs-number">100</span>% (<span class="hljs-number">26</span><span class="hljs-operator">/</span><span class="hljs-number">26</span>), done.<br>Writing <span class="hljs-params">objects:</span> <span class="hljs-number">100</span>% (<span class="hljs-number">35</span><span class="hljs-operator">/</span><span class="hljs-number">35</span>), <span class="hljs-number">13.91</span> MiB | <span class="hljs-number">777.00</span> KiB<span class="hljs-operator">/</span>s, done.<br>Total <span class="hljs-number">35</span> (delta <span class="hljs-number">0</span>), reused <span class="hljs-number">14</span> (delta <span class="hljs-number">0</span>), pack-reused <span class="hljs-number">0</span><br>To https:<span class="hljs-symbol">//github.com/HJTAHMAKBAR/HJTAHMAKBAR.github.io.git</span><br>   <span class="hljs-number">91</span>e562f..<span class="hljs-number">3</span>f03216  hexo <span class="hljs-operator">-&gt;</span> hexo<br></code></pre></td></tr></table></figure></li><li><p>查看hexo分支的仓库</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210627101634009.png"alt="image-20210627101634009" /><figcaption aria-hidden="true">image-20210627101634009</figcaption></figure></li></ol><h1 id="另一台电脑的操作">另一台电脑的操作</h1><ol type="1"><li><p><strong>git</strong><strong>bash</strong>将远程仓库克隆到本地</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">仓库地址</span><br></code></pre></td></tr></table></figure></li><li><p>然后进入项目目录，安装依赖启动博客服务器，生成静态文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span><br>hexo g<br>hexo s<br></code></pre></td></tr></table></figure><p>执行以上指令后，便可以在浏览器通过http://localhost:4000/访问博客</p></li><li><p>另一台电脑发布文章</p><p>同之前的教程一样，写好文章后</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">hexo clean<br>hexo d -<span class="hljs-selector-tag">g</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="两台电脑同步写博客">两台电脑同步写博客</h1><p>我们的博客仓库有两个分支，<em>master</em>分支和<em>hexo</em>分支</p><p>其中，master分支用于存放Hexo生成的静态资源文件，hexo分支用于存放网站的原始文件</p><p>所以，我们在一台设备上写好一篇文章或进行了博客的修改后</p><p>执行以下命令，将master中的静态资源文件更新</p><p>在博客目录下的cmd中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">hexo clean<br>hexo d -<span class="hljs-selector-tag">g</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210627142332846.png"alt="image-20210627142332846" /><figcaption aria-hidden="true">image-20210627142332846</figcaption></figure><p>执行以下命令，将hexo中的网站原始文件更新</p><p>在博客目录下的git bash中</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> pull<br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> -A<br><span class="hljs-symbol">git</span> commit -m <span class="hljs-string">&quot;描述&quot;</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> origin hexo<br></code></pre></td></tr></table></figure><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210627143023286.png"alt="image-20210627143023286" /><figcaption aria-hidden="true">image-20210627143023286</figcaption></figure><p><strong>大功告成！</strong></p><h1 id="注意事项">注意事项</h1><p>每次有新的操作的时候，别忘了在另一台电脑上更新</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git pull</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>所有</category>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Git</tag>
      
      <tag>Github Pages</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用Hexo框架从零开始搭建个人博客</title>
    <link href="/Hexo/%E5%88%A9%E7%94%A8Hexo%E6%A1%86%E6%9E%B6%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/Hexo/%E5%88%A9%E7%94%A8Hexo%E6%A1%86%E6%9E%B6%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="安装框架"><strong>安装框架</strong></h1><p>安装<strong>Node.js</strong>、<strong>Hexo</strong>、<strong>Git</strong></p><ol type="1"><li><p>安装Git</p><p>在<a href="https://git-scm.com/downloads">Git - Downloads(git-scm.com)</a>下载电脑对应的版本的Git并安装</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210626175500424.png"alt="image-20210626175500424" /><figcaption aria-hidden="true">image-20210626175500424</figcaption></figure></li><li><p>安装<strong>nvm</strong></p><p>下载地址：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/coreybutler/</span>nvm-windows/releases<br></code></pre></td></tr></table></figure></li><li><p>利用<strong>nvm</strong>安装指定的<strong>node.js</strong>版本</p><p>查看电脑中已有的node.js版本情况</p><p>cmd输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nvm list<br></code></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">C:\Users\jett&gt;nvm list<br><br>  * 12.18.3 (Currently using 64-bit executable)<br></code></pre></td></tr></table></figure><p>查看可安装的node.js版本</p><p>cmd中输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nvm list available<br></code></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">C:\Users\jett&gt;nvm list available<br><br>|<span class="hljs-string">   CURRENT    </span>|<span class="hljs-string">     LTS      </span>|<span class="hljs-string">  OLD STABLE  </span>|<span class="hljs-string"> OLD UNSTABLE </span>|<br>|<span class="hljs-string">--------------</span>|<span class="hljs-string">--------------</span>|<span class="hljs-string">--------------</span>|<span class="hljs-string">--------------</span>|<br>|<span class="hljs-string">    16.4.0    </span>|<span class="hljs-string">   14.17.1    </span>|<span class="hljs-string">   0.12.18    </span>|<span class="hljs-string">   0.11.16    </span>|<br>|<span class="hljs-string">    16.3.0    </span>|<span class="hljs-string">   14.17.0    </span>|<span class="hljs-string">   0.12.17    </span>|<span class="hljs-string">   0.11.15    </span>|<br>|<span class="hljs-string">    16.2.0    </span>|<span class="hljs-string">   14.16.1    </span>|<span class="hljs-string">   0.12.16    </span>|<span class="hljs-string">   0.11.14    </span>|<br>|<span class="hljs-string">    16.1.0    </span>|<span class="hljs-string">   14.16.0    </span>|<span class="hljs-string">   0.12.15    </span>|<span class="hljs-string">   0.11.13    </span>|<br>|<span class="hljs-string">    16.0.0    </span>|<span class="hljs-string">   14.15.5    </span>|<span class="hljs-string">   0.12.14    </span>|<span class="hljs-string">   0.11.12    </span>|<br>|<span class="hljs-string">   15.14.0    </span>|<span class="hljs-string">   14.15.4    </span>|<span class="hljs-string">   0.12.13    </span>|<span class="hljs-string">   0.11.11    </span>|<br>|<span class="hljs-string">   15.13.0    </span>|<span class="hljs-string">   14.15.3    </span>|<span class="hljs-string">   0.12.12    </span>|<span class="hljs-string">   0.11.10    </span>|<br>|<span class="hljs-string">   15.12.0    </span>|<span class="hljs-string">   14.15.2    </span>|<span class="hljs-string">   0.12.11    </span>|<span class="hljs-string">    0.11.9    </span>|<br>|<span class="hljs-string">   15.11.0    </span>|<span class="hljs-string">   14.15.1    </span>|<span class="hljs-string">   0.12.10    </span>|<span class="hljs-string">    0.11.8    </span>|<br>|<span class="hljs-string">   15.10.0    </span>|<span class="hljs-string">   14.15.0    </span>|<span class="hljs-string">    0.12.9    </span>|<span class="hljs-string">    0.11.7    </span>|<br>|<span class="hljs-string">    15.9.0    </span>|<span class="hljs-string">   12.22.1    </span>|<span class="hljs-string">    0.12.8    </span>|<span class="hljs-string">    0.11.6    </span>|<br>|<span class="hljs-string">    15.8.0    </span>|<span class="hljs-string">   12.22.0    </span>|<span class="hljs-string">    0.12.7    </span>|<span class="hljs-string">    0.11.5    </span>|<br>|<span class="hljs-string">    15.7.0    </span>|<span class="hljs-string">   12.21.0    </span>|<span class="hljs-string">    0.12.6    </span>|<span class="hljs-string">    0.11.4    </span>|<br>|<span class="hljs-string">    15.6.0    </span>|<span class="hljs-string">   12.20.2    </span>|<span class="hljs-string">    0.12.5    </span>|<span class="hljs-string">    0.11.3    </span>|<br>|<span class="hljs-string">    15.5.1    </span>|<span class="hljs-string">   12.20.1    </span>|<span class="hljs-string">    0.12.4    </span>|<span class="hljs-string">    0.11.2    </span>|<br>|<span class="hljs-string">    15.5.0    </span>|<span class="hljs-string">   12.20.0    </span>|<span class="hljs-string">    0.12.3    </span>|<span class="hljs-string">    0.11.1    </span>|<br>|<span class="hljs-string">    15.4.0    </span>|<span class="hljs-string">   12.19.1    </span>|<span class="hljs-string">    0.12.2    </span>|<span class="hljs-string">    0.11.0    </span>|<br>|<span class="hljs-string">    15.3.0    </span>|<span class="hljs-string">   12.19.0    </span>|<span class="hljs-string">    0.12.1    </span>|<span class="hljs-string">    0.9.12    </span>|<br>|<span class="hljs-string">    15.2.1    </span>|<span class="hljs-string">   12.18.4    </span>|<span class="hljs-string">    0.12.0    </span>|<span class="hljs-string">    0.9.11    </span>|<br>|<span class="hljs-string">    15.2.0    </span>|<span class="hljs-string">   12.18.3    </span>|<span class="hljs-string">   0.10.48    </span>|<span class="hljs-string">    0.9.10    </span>|<br><br>This is a partial list. For a complete list, visit https://nodejs.org/download/release<br></code></pre></td></tr></table></figure></li><li><p>选择一个node.js版本进行安装(12.18.3)</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nvm</span> install <span class="hljs-number">12</span>.<span class="hljs-number">18</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></li><li><p>查看是否安装成功</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br></code></pre></td></tr></table></figure></li><li><p>提示如下，说明安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">C:\Users\jett&gt;node -v<br>v12.18.3<br></code></pre></td></tr></table></figure></li><li><p>安装<strong>hexo</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>可能出现的问题：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">C:<span class="hljs-string">\Users\jett&gt;npm</span> install -g hexo-cli<br>D:<span class="hljs-string">\Program</span> Files<span class="hljs-string">\nodejs\hexo</span> -&gt; D:<span class="hljs-string">\Program</span> Files<span class="hljs-string">\nodejs\node_modules\hexo-cli\bin\hexo</span><br><span class="hljs-built_in">npm</span> WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@~<span class="hljs-number">2.3</span>.<span class="hljs-number">2</span> (node_modules<span class="hljs-string">\hexo-cli\node_modules\chokidar\node_modules\fsevents):</span><br><span class="hljs-built_in">npm</span> WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform <span class="hljs-keyword">for</span> fsevents@<span class="hljs-number">2.3</span>.<span class="hljs-number">2</span>: wanted &#123;<span class="hljs-string">&quot;os&quot;</span>:<span class="hljs-string">&quot;darwin&quot;</span>,<span class="hljs-string">&quot;arch&quot;</span>:<span class="hljs-string">&quot;any&quot;</span>&#125; (current: &#123;<span class="hljs-string">&quot;os&quot;</span>:<span class="hljs-string">&quot;win32&quot;</span>,<span class="hljs-string">&quot;arch&quot;</span>:<span class="hljs-string">&quot;x64&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><p>此警告并不是表明真的有什么问题，只是你的某些包依赖<code>fsevents</code>包,而<code>fsevents</code>包是MacOS系统下，在Windows/Linux下会提示警告，但不会安装。</p><p><strong>处理方法</strong>：<strong>忽略</strong>。</p><p><strong>至此，框架已经安装完毕。</strong></p></li></ol><h1 id="博客初始化"><strong>博客初始化</strong></h1><ol type="1"><li><p>在<strong>D</strong>盘目录<strong>Github</strong>下新建文件夹<strong>JettsBlog</strong>，在此目录下进入cmd，然后执行</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210626185428222.png"alt="image-20210626185428222" /><figcaption aria-hidden="true">image-20210626185428222</figcaption></figure></li><li><p>查看Hexo是否搭建好，运行本地的Hexo服务器</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p>控制台信息：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">D:\Github\JettsBlog&gt;hexo s<br><span class="hljs-keyword">INFO</span>  Validating config<br><span class="hljs-keyword">INFO</span>  <span class="hljs-keyword">Start</span> processing<br><span class="hljs-keyword">INFO</span>  Hexo <span class="hljs-keyword">is</span> running at http://localhost:<span class="hljs-number">4000</span> . Press Ctrl+C <span class="hljs-keyword">to</span> stop.<br></code></pre></td></tr></table></figure></li><li><p>在浏览器访问http://localhost:4000<imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210626185620370.png"alt="image-20210626185620370" /></p></li></ol><h1 id="开始配置博客"><strong>开始配置博客</strong></h1><ol type="1"><li><p>下载一个主题</p><p>在<a href="https://hexo.io/themes/">Themes |Hexo</a>中选择一个主题(Fluid)</p><p>主题的项目地址：<ahref="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev/hexo-theme-fluid:一款 Material Design 风格的 Hexo 主题 / An elegant Material-Design themefor Hexo (github.com)</a></p></li><li><p>根据主题的项目文档进行主题的安装与配置</p><ol type="1"><li><p>安装主题</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-theme-fluid</span><br></code></pre></td></tr></table></figure></li><li><p>然后在博客目录下创建 <code>_config.fluid.yml</code>，将主题的 <ahref="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">_config.yml</a>内容复制进去。此文件可以在本地主题文件夹D:_modules-theme-fluid下找到。</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210626190417304.png"alt="image-20210626190417304" /><figcaption aria-hidden="true">image-20210626190417304</figcaption></figure><p>在D:_config.fluid.yml文件</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210626190538965.png"alt="image-20210626190538965" /><figcaption aria-hidden="true">image-20210626190538965</figcaption></figure><p>将主题目录下的<ahref="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">_config.yml</a>中的内容复制到_config.fluid.yml文件中</p></li><li><p>修改 Hexo 博客目录中的 <code>_config.yml</code></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">theme:</span> fluid<br></code></pre></td></tr></table></figure><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210626190834137.png"alt="image-20210626190834137" /><figcaption aria-hidden="true">image-20210626190834137</figcaption></figure></li><li><p>创建<strong>关于页</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> page about<br></code></pre></td></tr></table></figure><p>在博客的source文件夹下的about文件夹下找到index.md</p><p>在Front-matter后添加</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">layout</span>: <span class="hljs-keyword">about</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210626203851192.png"alt="image-20210626203851192" /><figcaption aria-hidden="true">image-20210626203851192</figcaption></figure><p><strong>至此，博客的主题已经初始化完成。</strong></p><p>接下来需要根据自己的需要更改主题文件中的配置，比如网站标题，背景图片，相关内容等</p><p>主题的配置详细教程见主题项目的相关文档<ahref="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev/hexo-theme-fluid:一款 Material Design 风格的 Hexo 主题 / An elegant Material-Design themefor Hexo (github.com)</a></p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210626191616671.png"alt="image-20210626191616671" /><figcaption aria-hidden="true">image-20210626191616671</figcaption></figure></li></ol></li></ol><h1 id="将博客部署到网上"><strong>将博客部署到网上</strong></h1><ol type="1"><li><p>在<strong>github</strong>上创建一个仓库，名字严格按照格式：<strong>xxxx.github.io</strong>，其中<strong>xxx</strong>就是你注册GitHub的用户，例如</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210626195402198.png"alt="image-20210626195402198" /><figcaption aria-hidden="true">image-20210626195402198</figcaption></figure></li><li><p>打开git bash</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210626192756242.png"alt="image-20210626192756242" /><figcaption aria-hidden="true">image-20210626192756242</figcaption></figure></li><li><p>创建密钥</p><p>将自己的邮箱替换命令中的<strong>youremail</strong>项</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;youremail&quot;</span><br></code></pre></td></tr></table></figure><p>git bash输出信息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs swift">jett<span class="hljs-meta">@HUAWEI</span><span class="hljs-operator">-</span><span class="hljs-type">Huang</span> <span class="hljs-type">MINGW64</span> <span class="hljs-operator">~</span><br>$ ssh<span class="hljs-operator">-</span>keygen <span class="hljs-operator">-</span>t rsa <span class="hljs-operator">-</span><span class="hljs-type">C</span> <span class="hljs-string">&quot;2277401179@qq.com&quot;</span><br><span class="hljs-type">Generating</span> <span class="hljs-keyword">public</span><span class="hljs-operator">/</span><span class="hljs-keyword">private</span> rsa key pair.<br><span class="hljs-type">Enter</span> file <span class="hljs-keyword">in</span> which to save the key (<span class="hljs-regexp">/c/</span><span class="hljs-type">Users</span><span class="hljs-regexp">/jett/</span>.ssh<span class="hljs-operator">/</span>id_rsa):<br><span class="hljs-type">Created</span> directory &#x27;<span class="hljs-regexp">/c/</span><span class="hljs-type">Users</span><span class="hljs-regexp">/jett/</span>.ssh&#x27;.<br><span class="hljs-type">Enter</span> passphrase (empty <span class="hljs-keyword">for</span> no passphrase):<br><span class="hljs-type">Enter</span> same passphrase again:<br><span class="hljs-type">Your</span> identification has been saved <span class="hljs-keyword">in</span> <span class="hljs-regexp">/c/</span><span class="hljs-type">Users</span><span class="hljs-regexp">/jett/</span>.ssh<span class="hljs-operator">/</span>id_rsa<br><span class="hljs-type">Your</span> <span class="hljs-keyword">public</span> key has been saved <span class="hljs-keyword">in</span> <span class="hljs-regexp">/c/</span><span class="hljs-type">Users</span><span class="hljs-regexp">/jett/</span>.ssh<span class="hljs-operator">/</span>id_rsa.pub<br><span class="hljs-type">The</span> key fingerprint <span class="hljs-keyword">is</span>:<br>(这里是你的key fingerprint和邮箱)<br><span class="hljs-type">The</span> key&#x27;s randomart image <span class="hljs-keyword">is</span>:<br>(这里是你的key&#x27;s randomart image)<br><br></code></pre></td></tr></table></figure></li><li><p>查看生成的密钥文件</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210626193527928.png"alt="image-20210626193527928" /><figcaption aria-hidden="true">image-20210626193527928</figcaption></figure><p><code>id_rsa</code>是你这台电脑的私人秘钥，不能给别人看的，<code>id_rsa.pub</code>是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。</p></li><li><p>在Github进行设置</p><p>在GitHub的setting中，找到SSHkeys的设置选项，点击<code>New SSH key</code>把你的<code>id_rsa.pub</code>里面的信息复制进去</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210626193735726.png"alt="image-20210626193735726" /><figcaption aria-hidden="true">image-20210626193735726</figcaption></figure><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210626193922973.png"alt="image-20210626193922973" /><figcaption aria-hidden="true">image-20210626193922973</figcaption></figure></li><li><p>将Hexo部署到Github</p><p>打开站点配置文件 <code>_config.yml</code>，在最后的修改信息如下</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/HJTAHMAKBAR/HJTAHMAKBAR.github.io.git</span><br></code></pre></td></tr></table></figure><p>其中repo中的地址是博客的GitHub项目地址，也就是刚才所新建的仓库地址</p></li><li><p>安装<strong>部署</strong>插件</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure></li><li><p>执行<strong>部署</strong>命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">hexo <span class="hljs-title function_">clean</span><span class="hljs-params">(清楚生成的<span class="hljs-keyword">public</span>文件夹，<span class="hljs-keyword">public</span>中就是要上传到Github的内容，即渲染出的网页的文件)</span><br>hexo <span class="hljs-title function_">generate</span><span class="hljs-params">(可简写为hexo g)</span><br>hexo <span class="hljs-title function_">deploy</span><span class="hljs-params">(可简写为hexo d)</span><br>(后面两行命令可以简写为hexo d -g)<br></code></pre></td></tr></table></figure><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210626195755281.png"alt="image-20210626195755281" /><figcaption aria-hidden="true">image-20210626195755281</figcaption></figure><p><strong>至此，本地的Hexo已经部署到Github上</strong></p></li><li><p>开启Github Pages</p><p>在项目的Settings下的Pages中，可以看到博客的地址</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210626195944721.png"alt="image-20210626195944721" /><figcaption aria-hidden="true">image-20210626195944721</figcaption></figure><p><strong>此时，已经可以通过这个地址在线访问自己的博客了</strong></p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210626200053519.png"alt="image-20210626200053519" /><figcaption aria-hidden="true">image-20210626200053519</figcaption></figure></li></ol><h1 id="为博客绑定一个域名">为博客绑定一个域名</h1><ol type="1"><li><p>购买域名(阿里云)</p><ol type="1"><li><p>在<ahref="https://wanwang.aliyun.com/domain/">域名注册_域名查询_域名申请_域名购买_域名续费_国际域名-万网-阿里云旗下品牌(aliyun.com)</a>中购买一个自己想要的域名</p></li><li><p>ping自己的博客地址</p><p>在本地的cmd上执行</p><p>其中xxx是GitHub账号名</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">ping</span> xxx.github.io<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">C:\Users\jett&gt;ping hjtahmakbar.github.io<br><br>正在<span class="hljs-built_in"> Ping </span>hjtahmakbar.github.io [185.199.111.153] 具有 32 字节的数据:<br>来自 185.199.111.153 的回复: 字节=32 时间=40ms <span class="hljs-attribute">TTL</span>=52<br>来自 185.199.111.153 的回复: 字节=32 时间=41ms <span class="hljs-attribute">TTL</span>=52<br>来自 185.199.111.153 的回复: 字节=32 时间=41ms <span class="hljs-attribute">TTL</span>=52<br>来自 185.199.111.153 的回复: 字节=32 时间=40ms <span class="hljs-attribute">TTL</span>=52<br><br>185.199.111.153 的<span class="hljs-built_in"> Ping </span>统计信息:<br>    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，<br>往返行程的估计时间(以毫秒为单位):<br>    最短 = 40ms，最长 = 41ms，平均 = 40ms<br></code></pre></td></tr></table></figure><p>其中185.199.111.153是我们需要的服务器地址</p></li></ol></li><li><p>解析域名</p><p>在阿里云的控制台中找到云解析DNS(域名解析)</p><p>添加两条记录</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210626200935329.png"alt="image-20210626200935329" /><figcaption aria-hidden="true">image-20210626200935329</figcaption></figure></li><li><p>在GitHub Pages设置我们的域名</p><p>填入自己的域名</p><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210626201101821.png"alt="image-20210626201101821" /><figcaption aria-hidden="true">image-20210626201101821</figcaption></figure><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/image-20210626201140900.png"alt="image-20210626201140900" /><figcaption aria-hidden="true">image-20210626201140900</figcaption></figure><p>大功告成，至此，我们已经可以通过域名访问我们的博客！</p><p>接下来，就可以开始写文章，以及对博客的配置和功能的更改！</p></li></ol><h1 id="后续操作"><strong>后续操作</strong></h1><ol type="1"><li>博客各板块信息显示</li><li>安装评论插件</li><li>配置在线MarkDown编辑</li><li>文章插入图片</li><li>将博客收录与百度、必应、谷歌等搜索引擎</li></ol>]]></content>
    
    
    <categories>
      
      <category>所有</category>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>GithubPages</tag>
      
      <tag>Git</tag>
      
      <tag>nvm</tag>
      
      <tag>Nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好世界！</title>
    <link href="/%E6%89%80%E6%9C%89/%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/"/>
    <url>/%E6%89%80%E6%9C%89/%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="开始学习吧">开始学习吧！</h1><blockquote><p>此学期之学已毕矣，且吾之大学时日已过半矣。吾愈之觉迷，以学者薄，以学者浅。故决始因此夏学诸新之术，习算法，著文章，为业锥求一可自道，并于学之中，续续录，写吾感，享所得，故作此博客以记之。</p></blockquote><p>2021年6月15日，期末考完，大二结束，感到迷茫。决定利用暑假学习专业方向的技术，刷算法，写博客，思考，总结。</p><p>利用<strong>Hexo</strong>框架在<strong>GitHubPages</strong>搭建了自己的博客，不知道说什么，就以这句话作为一个开始吧。</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Hello World!<br></code></pre></td></tr></table></figure><figure><imgsrc="https://jett-image-host.oss-cn-shanghai.aliyuncs.com/img/helloworld.png"alt="helloworld" /><figcaption aria-hidden="true">helloworld</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>所有</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
      <tag>随想</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
